#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TimeWatch

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "NGDBackend_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "UnrealProject_structs.hpp"


namespace SDK
{

// Enum TimeWatch.EGameModeType
// NumValues: 0x0006
enum class EGameModeType : uint8
{
	Undefined                                = 0,
	DeathMatch                               = 1,
	Capture                                  = 2,
	Tutorial                                 = 3,
	Domination                               = 4,
	EGameModeType_MAX                        = 5,
};

// Enum TimeWatch.ETWCauseOfDeath
// NumValues: 0x0005
enum class ETWCauseOfDeath : uint8
{
	Explosion                                = 0,
	Damage_Enemy                             = 1,
	Damage_Friendly                          = 2,
	Damage_Paradox                           = 3,
	ETWCauseOfDeath_MAX                      = 4,
};

// Enum TimeWatch.ETWBasicPlayerAction
// NumValues: 0x0008
enum class ETWBasicPlayerAction : uint8
{
	None                                     = 0,
	Crouch                                   = 1,
	Slide                                    = 2,
	RightClickUse                            = 4,
	Jump                                     = 8,
	LeftClickUse                             = 22,
	Sprint                                   = 50,
	ETWBasicPlayerAction_MAX                 = 51,
};

// Enum TimeWatch.EFluxCapacitorStates
// NumValues: 0x000D
enum class EFluxCapacitorStates : uint8
{
	WAITING_DATA                             = 0,
	CHAR_SELECTION                           = 1,
	PRE_MATCH                                = 2,
	START                                    = 3,
	FORWARD                                  = 4,
	REVERSE                                  = 5,
	CURLING                                  = 6,
	PREPARE_LOOP                             = 7,
	LASTLOOP_REVIEW                          = 8,
	GAME_ENDED                               = 9,
	RESTART                                  = 10,
	AFTER_CURL                               = 11,
	EFluxCapacitorStates_MAX                 = 12,
};

// Enum TimeWatch.EChatChannel
// NumValues: 0x0004
enum class EChatChannel : uint8
{
	All                                      = 0,
	Team                                     = 1,
	NONE                                     = 2,
	EChatChannel_MAX                         = 3,
};

// Enum TimeWatch.ERuleAcceptType
// NumValues: 0x0004
enum class ERuleAcceptType : uint8
{
	LESS                                     = 0,
	EQUAL                                    = 1,
	MORE                                     = 2,
	ERuleAcceptType_MAX                      = 3,
};

// Enum TimeWatch.ETWMatchmakingType
// NumValues: 0x000C
enum class ETWMatchmakingType : uint8
{
	CasualSinglesFlexmatchPoll               = 0,
	CasualDoublesFlexmatchPoll               = 1,
	CasualDoublesWithPartyLobbyPoll          = 2,
	CasualDoublesWithPartyFlexmatchPoll      = 3,
	RankedSinglesFlexmatchPoll               = 4,
	RankedDoublesFlexmatchPoll               = 5,
	RankedDoublesWithPartyLobbyPoll          = 6,
	RankedDoublesWithPartyFlexmatchPoll      = 7,
	CustomMatchLobbyPoll                     = 8,
	CustomMatchGameSessionPoll               = 9,
	None                                     = 10,
	ETWMatchmakingType_MAX                   = 11,
};

// Enum TimeWatch.ELobbyReplicableField
// NumValues: 0x000B
enum class ELobbyReplicableField : uint32
{
	Map                                      = 0,
	PlayersSetup                             = 1,
	MatchPoints                              = 2,
	ClonesCount                              = 3,
	HealthPackMode                           = 4,
	WeaponMode                               = 5,
	OvertimeMode                             = 6,
	PassiveAbilitiesMode                     = 7,
	LoopLength                               = 8,
	HealingMode                              = 9,
	ELobbyReplicableField_MAX                = 10,
};

// Enum TimeWatch.ECameraPointType
// NumValues: 0x0003
enum class ECameraPointType : uint8
{
	Spectator                                = 0,
	LoopReview                               = 1,
	ECameraPointType_MAX                     = 2,
};

// Enum TimeWatch.EEndGameReason
// NumValues: 0x0006
enum class EEndGameReason : uint32
{
	None                                     = 0,
	MatchComplete                            = 1,
	Forfeit                                  = 2,
	Suspended                                = 3,
	COUNT                                    = 4,
	EEndGameReason_MAX                       = 5,
};

// Enum TimeWatch.EFluxBarrelState
// NumValues: 0x0005
enum class EFluxBarrelState : uint8
{
	ARMED                                    = 0,
	FUSE                                     = 1,
	EXPLODING                                = 2,
	USED                                     = 3,
	EFluxBarrelState_MAX                     = 4,
};

// Enum TimeWatch.EFluxTimelineState
// NumValues: 0x0005
enum class EFluxTimelineState : uint8
{
	STOPPED                                  = 0,
	FORWARD                                  = 1,
	REWINDING                                = 2,
	PREFORWARD                               = 3,
	EFluxTimelineState_MAX                   = 4,
};

// Enum TimeWatch.EProjectileState
// NumValues: 0x0005
enum class EProjectileState : uint8
{
	Created                                  = 0,
	Simulating                               = 1,
	PendingDestruction                       = 2,
	Destroyed                                = 3,
	EProjectileState_MAX                     = 4,
};

// Enum TimeWatch.EFriendState
// NumValues: 0x0004
enum class EFriendState : uint8
{
	Online                                   = 0,
	Offline                                  = 1,
	Party                                    = 2,
	EFriendState_MAX                         = 3,
};

// Enum TimeWatch.EWeaponType
// NumValues: 0x0008
enum class EWeaponType : uint8
{
	WT_None                                  = 0,
	WT_HandGun                               = 1,
	WT_Rifle                                 = 2,
	WT_SMG                                   = 3,
	WT_GrenadeLauncher                       = 4,
	WT_Shotgun                               = 5,
	WT_LaserBeam                             = 6,
	WT_MAX                                   = 7,
};

// Enum TimeWatch.EADSStates
// NumValues: 0x0006
enum class EADSStates : uint8
{
	NONE                                     = 0,
	START_SHOWING                            = 1,
	SHOWN                                    = 2,
	START_HIDING                             = 3,
	HIDDEN                                   = 4,
	EADSStates_MAX                           = 5,
};

// Enum TimeWatch.EFluxLoopResult
// NumValues: 0x0004
enum class EFluxLoopResult : uint8
{
	Continue                                 = 0,
	Reset                                    = 1,
	GameFinished                             = 2,
	EFluxLoopResult_MAX                      = 3,
};

// Enum TimeWatch.ETWTargetDataFilterTeam
// NumValues: 0x0004
enum class ETWTargetDataFilterTeam : uint8
{
	TW_TDFT_Any                              = 0,
	TW_TDFT_NoAlly                           = 1,
	TW_TDFT_NoEnemy                          = 2,
	TW_TDFT_MAX                              = 3,
};

// Enum TimeWatch.ETWTargetDataFilterSelf
// NumValues: 0x0004
enum class ETWTargetDataFilterSelf : uint8
{
	TW_TDFS_Any                              = 0,
	TW_TDFS_NoSelf                           = 1,
	TW_TDFS_NoOthers                         = 2,
	TW_TDFS_MAX                              = 3,
};

// Enum TimeWatch.ETWAbilityForwardEndPolicy
// NumValues: 0x0004
enum class ETWAbilityForwardEndPolicy : uint8
{
	Interrupted                              = 0,
	PauseAndResume                           = 1,
	PauseAndResumeForCaster                  = 2,
	ETWAbilityForwardEndPolicy_MAX           = 3,
};

// Enum TimeWatch.ETWAbilityNetExecutionPolicy
// NumValues: 0x0005
enum class ETWAbilityNetExecutionPolicy : uint8
{
	LocallyPredicted                         = 0,
	LocallyPredictedAndServerInitiated       = 1,
	ServerInitiated                          = 2,
	ServerOnly                               = 3,
	ETWAbilityNetExecutionPolicy_MAX         = 4,
};

// Enum TimeWatch.ETWAbilityInstancingPolicy
// NumValues: 0x0005
enum class ETWAbilityInstancingPolicy : uint8
{
	InstancedPerWorld                        = 0,
	InstancedPerPlayer                       = 1,
	InstancedPerAvatar                       = 2,
	InstancedPerExecution                    = 3,
	ETWAbilityInstancingPolicy_MAX           = 4,
};

// Enum TimeWatch.ETWAbilityReExecutionPolicy
// NumValues: 0x0004
enum class ETWAbilityReExecutionPolicy : uint8
{
	LogicAndCosmetics                        = 0,
	CosmeticsOnly                            = 1,
	Unrecorded                               = 2,
	ETWAbilityReExecutionPolicy_MAX          = 3,
};

// Enum TimeWatch.ETWAbilityCastPolicy
// NumValues: 0x0004
enum class ETWAbilityCastPolicy : uint8
{
	AliveCasterOnly                          = 0,
	DeadCasterOnly                           = 1,
	AlwaysCast                               = 2,
	ETWAbilityCastPolicy_MAX                 = 3,
};

// Enum TimeWatch.ECaptureState
// NumValues: 0x0005
enum class ECaptureState : uint8
{
	Reach                                    = 0,
	Contested                                = 1,
	Clear                                    = 2,
	Defend                                   = 3,
	ECaptureState_MAX                        = 4,
};

// Enum TimeWatch.EButtonStyle
// NumValues: 0x0006
enum class EButtonStyle : uint8
{
	EMPTY                                    = 0,
	UNSELECTED                               = 1,
	SELECTED                                 = 2,
	ACTIVE                                   = 3,
	FORCEHOVER                               = 4,
	EButtonStyle_MAX                         = 5,
};

// Enum TimeWatch.EDMScoreState
// NumValues: 0x0005
enum class EDMScoreState : uint32
{
	Locked                                   = 0,
	Empty                                    = 1,
	Full                                     = 2,
	None                                     = 3,
	EDMScoreState_MAX                        = 4,
};

// Enum TimeWatch.EAnnouncerEventTypes
// NumValues: 0x0006
enum class EAnnouncerEventTypes : uint8
{
	Generic                                  = 0,
	Positive                                 = 1,
	Negative                                 = 2,
	NegativeForOthers                        = 3,
	PositiveForOthers                        = 4,
	EAnnouncerEventTypes_MAX                 = 5,
};

// Enum TimeWatch.ETWCrowdReactionScoringCriteria
// NumValues: 0x0005
enum class ETWCrowdReactionScoringCriteria : uint8
{
	None                                     = 0,
	Event                                    = 1,
	Clone                                    = 2,
	LoopStack                                = 4,
	ETWCrowdReactionScoringCriteria_MAX      = 5,
};

// Enum TimeWatch.ETWLocalizedLanguage
// NumValues: 0x000D
enum class ETWLocalizedLanguage : uint8
{
	None                                     = 0,
	English                                  = 1,
	Spanish                                  = 2,
	Portuguese                               = 3,
	French                                   = 4,
	German                                   = 5,
	Italian                                  = 6,
	Russian                                  = 7,
	Korean                                   = 8,
	Japanese                                 = 9,
	ChineseTraditional                       = 10,
	ChineseSimplified                        = 11,
	ETWLocalizedLanguage_MAX                 = 12,
};

// Enum TimeWatch.ETWChallengeBackendRequirementType
// NumValues: 0x0003
enum class ETWChallengeBackendRequirementType : uint8
{
	None                                     = 0,
	PlayerLevel                              = 2,
	ETWChallengeBackendRequirementType_MAX   = 3,
};

// Enum TimeWatch.EChallengeDifficulty
// NumValues: 0x0005
enum class EChallengeDifficulty : uint32
{
	Begginer                                 = 0,
	Medium                                   = 1,
	Advanced                                 = 2,
	GameModes                                = 3,
	EChallengeDifficulty_MAX                 = 4,
};

// Enum TimeWatch.ETWMatchQueueType
// NumValues: 0x000A
enum class ETWMatchQueueType : uint8
{
	None                                     = 0,
	CasualSingles                            = 1,
	CasualDoubles                            = 2,
	CasualDoublesWithParty                   = 3,
	RankedSingles                            = 4,
	RankedDoubles                            = 5,
	RankedDoublesWithParty                   = 6,
	Newcomer                                 = 7,
	Custom                                   = 8,
	ETWMatchQueueType_MAX                    = 9,
};

// Enum TimeWatch.EOvertimeMode
// NumValues: 0x0004
enum class EOvertimeMode : uint8
{
	Normal                                   = 0,
	ResetClones                              = 1,
	ResetEverything                          = 2,
	EOvertimeMode_MAX                        = 3,
};

// Enum TimeWatch.EHealthPackHealingMode
// NumValues: 0x0004
enum class EHealthPackHealingMode : uint8
{
	Instant                                  = 0,
	HealOverTime                             = 1,
	AreaHealing                              = 2,
	EHealthPackHealingMode_MAX               = 3,
};

// Enum TimeWatch.EHealthPackMode
// NumValues: 0x0004
enum class EHealthPackMode : uint8
{
	Normal                                   = 0,
	None                                     = 1,
	Refilling                                = 2,
	EHealthPackMode_MAX                      = 3,
};

// Enum TimeWatch.ETWMatchType
// NumValues: 0x0008
enum class ETWMatchType : uint8
{
	None                                     = 0,
	Casual_1v1                               = 1,
	Casual_2v2                               = 2,
	Ranked_1v1                               = 4,
	Ranked_2v2                               = 8,
	NewcomerMatch                            = 16,
	CustomMatch                              = 32,
	ETWMatchType_MAX                         = 33,
};

// Enum TimeWatch.ETWQualitySettings
// NumValues: 0x0006
enum class ETWQualitySettings : uint8
{
	None                                     = 0,
	LOW                                      = 1,
	MEDIUM                                   = 2,
	HIGH                                     = 4,
	EPIC                                     = 8,
	ETWQualitySettings_MAX                   = 9,
};

// Enum TimeWatch.EQuickChatCategory
// NumValues: 0x0005
enum class EQuickChatCategory : uint8
{
	Information                              = 0,
	Exclamations                             = 1,
	Compliments                              = 2,
	Categories                               = 3,
	EQuickChatCategory_MAX                   = 4,
};

// Enum TimeWatch.ELaserSoundEventType
// NumValues: 0x0005
enum class ELaserSoundEventType : uint8
{
	Charge                                   = 0,
	Start                                    = 1,
	End                                      = 2,
	Terminate                                = 3,
	ELaserSoundEventType_MAX                 = 4,
};

// Enum TimeWatch.ELoopState
// NumValues: 0x0004
enum class ELoopState : uint8
{
	Past                                     = 0,
	Current                                  = 1,
	Future                                   = 2,
	ELoopState_MAX                           = 3,
};

// Enum TimeWatch.EPostProcessType
// NumValues: 0x0002
enum class EPostProcessType : uint8
{
	Damage                                   = 0,
	EPostProcessType_MAX                     = 1,
};

// Enum TimeWatch.ETransitionState
// NumValues: 0x0004
enum class ETransitionState : uint8
{
	None                                     = 0,
	SwitchingClones                          = 1,
	LastLoopReview                           = 2,
	ETransitionState_MAX                     = 3,
};

// Enum TimeWatch.EFirstUserExperienceSteps
// NumValues: 0x001B
enum class EFirstUserExperienceSteps : uint8
{
	Undefined                                = 0,
	IntroVideo                               = 1,
	CongratulationsAcademy                   = 2,
	CasualUnlocked                           = 3,
	DailyBoost                               = 4,
	GetReadyCasual                           = 5,
	RankedUnlocked                           = 6,
	GetReadyRanked                           = 7,
	FirstOnlineMatch_Matchmaking             = 8,
	FirstOnlineMatch_Started                 = 9,
	FirstOnlineMatch_FirstClonEver           = 10,
	FirstOnlineMatch_SecondClonEver          = 11,
	FirstOnlineMatch_ThirdClonEver           = 12,
	FirstOnlineMatch_FirstRoundComplete      = 13,
	FirstOnlineMatch_SecondRoundComplete     = 14,
	FirstOnlineMatch_Completed               = 15,
	SecondOnlineMatch_Started                = 16,
	SecondOnlineMatch_Completed              = 17,
	UserReachedLevelTwo                      = 18,
	UserReachedLevelThree                    = 19,
	UserReachedLevelFour                     = 20,
	UserReachedLevelFive                     = 21,
	FirstRankedMatch_Matchmaking             = 22,
	FirstRankedMatch_Started                 = 23,
	FirstRankedMatch_Completed               = 24,
	TournamentCap_Reached                    = 25,
	EFirstUserExperienceSteps_MAX            = 26,
};

// Enum TimeWatch.EBannerSize
// NumValues: 0x0004
enum class EBannerSize : uint8
{
	Big                                      = 0,
	Medium                                   = 1,
	Small                                    = 2,
	EBannerSize_MAX                          = 3,
};

// Enum TimeWatch.EWidgetSize
// NumValues: 0x0003
enum class EWidgetSize : uint8
{
	Small                                    = 0,
	Big                                      = 1,
	EWidgetSize_MAX                          = 2,
};

// Enum TimeWatch.ESpectatorModes
// NumValues: 0x0004
enum class ESpectatorModes : uint8
{
	FREELOOK                                 = 0,
	FIRSTPERSON                              = 1,
	THIRDPERSON                              = 2,
	ESpectatorModes_MAX                      = 3,
};

// Enum TimeWatch.ECharSelectionState
// NumValues: 0x0003
enum class ECharSelectionState : uint8
{
	PLAYER_VIEW                              = 0,
	SPECTATOR_VIEW                           = 1,
	ECharSelectionState_MAX                  = 2,
};

// Enum TimeWatch.ECustomizationFlowState
// NumValues: 0x0003
enum class ECustomizationFlowState : uint8
{
	CHARACTER_SELECTION                      = 0,
	STYLE_SELECTION                          = 1,
	ECustomizationFlowState_MAX              = 2,
};

// Enum TimeWatch.ERewardConditionType
// NumValues: 0x0003
enum class ERewardConditionType : uint8
{
	Condition_Win                            = 0,
	Condition_Play                           = 1,
	Condition_MAX                            = 2,
};

// Enum TimeWatch.EMatchTallyFlowState
// NumValues: 0x0004
enum class EMatchTallyFlowState : uint8
{
	WaitingForResults                        = 0,
	ShowingResults                           = 1,
	TierUpPopup                              = 2,
	EMatchTallyFlowState_MAX                 = 3,
};

// Enum TimeWatch.ELeaderboardProperties
// NumValues: 0x0009
enum class ELeaderboardProperties : uint8
{
	LP_UserName                              = 0,
	LP_Rank                                  = 1,
	LP_WinRate                               = 2,
	LP_Win                                   = 3,
	LP_Lose                                  = 4,
	LP_Elo                                   = 5,
	LP_Score                                 = 6,
	LP_RankDifference                        = 7,
	LP_MAX                                   = 8,
};

// Enum TimeWatch.ELeaderboardPeriod
// NumValues: 0x0005
enum class ELeaderboardPeriod : uint8
{
	AllTime                                  = 0,
	Monthly                                  = 1,
	Weekly                                   = 2,
	Daily                                    = 3,
	ELeaderboardPeriod_MAX                   = 4,
};

// Enum TimeWatch.EPlaySelectionState
// NumValues: 0x0003
enum class EPlaySelectionState : uint8
{
	OneVOne                                  = 0,
	TwoVTwo                                  = 1,
	EPlaySelectionState_MAX                  = 2,
};

// Enum TimeWatch.EFeedbackType
// NumValues: 0x0004
enum class EFeedbackType : uint8
{
	HitFeedback                              = 0,
	ExplosionFeedback                        = 1,
	CriticalHitFeedback                      = 2,
	EFeedbackType_MAX                        = 3,
};

// Enum TimeWatch.ERewardTrackState
// NumValues: 0x0003
enum class ERewardTrackState : uint8
{
	REWARD_TRACK                             = 0,
	ITEM_PREVIEW                             = 1,
	ERewardTrackState_MAX                    = 2,
};

// Enum TimeWatch.EDailyStoreFlowState
// NumValues: 0x0005
enum class EDailyStoreFlowState : uint8
{
	DAILY_STORE                              = 0,
	ITEM_PREVIEW                             = 1,
	QUARKS_BUNDLES                           = 2,
	WAITING_DATA                             = 3,
	EDailyStoreFlowState_MAX                 = 4,
};

// Enum TimeWatch.ETipNotificationType
// NumValues: 0x0003
enum class ETipNotificationType : uint8
{
	InGame_Default                           = 0,
	MainMenu_Default                         = 1,
	ETipNotificationType_MAX                 = 2,
};

// Enum TimeWatch.EWeaponIconType
// NumValues: 0x0005
enum class EWeaponIconType : uint8
{
	FullImage_Selected                       = 0,
	FullImage_UnSelected                     = 1,
	SmallImage_Selected                      = 2,
	SmallImage_UnSelected                    = 3,
	EWeaponIconType_MAX                      = 4,
};

// ScriptStruct TimeWatch.TWAbilityCustomDataBase
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FTWAbilityCustomDataBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTWAbilityCustomDataBase) == 0x000008, "Wrong alignment on FTWAbilityCustomDataBase");
static_assert(sizeof(FTWAbilityCustomDataBase) == 0x000008, "Wrong size on FTWAbilityCustomDataBase");

// ScriptStruct TimeWatch.TWInteractableTimelineRecordData
// 0x0018 (0x0018 - 0x0000)
struct FTWInteractableTimelineRecordData final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingCooldown;                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasUsedOnce;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingInitialCooldown;                             // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Interactor;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWInteractableTimelineRecordData) == 0x000008, "Wrong alignment on FTWInteractableTimelineRecordData");
static_assert(sizeof(FTWInteractableTimelineRecordData) == 0x000018, "Wrong size on FTWInteractableTimelineRecordData");
static_assert(offsetof(FTWInteractableTimelineRecordData, Timestamp) == 0x000000, "Member 'FTWInteractableTimelineRecordData::Timestamp' has a wrong offset!");
static_assert(offsetof(FTWInteractableTimelineRecordData, RemainingCooldown) == 0x000004, "Member 'FTWInteractableTimelineRecordData::RemainingCooldown' has a wrong offset!");
static_assert(offsetof(FTWInteractableTimelineRecordData, bWasUsedOnce) == 0x000008, "Member 'FTWInteractableTimelineRecordData::bWasUsedOnce' has a wrong offset!");
static_assert(offsetof(FTWInteractableTimelineRecordData, bUsingInitialCooldown) == 0x000009, "Member 'FTWInteractableTimelineRecordData::bUsingInitialCooldown' has a wrong offset!");
static_assert(offsetof(FTWInteractableTimelineRecordData, Interactor) == 0x000010, "Member 'FTWInteractableTimelineRecordData::Interactor' has a wrong offset!");

// ScriptStruct TimeWatch.CharacterSelectionEntry
// 0x0028 (0x0028 - 0x0000)
struct FCharacterSelectionEntry final
{
public:
	class FString                                 CharacterSKU;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StyleSKU;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntroPosesIndex;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InternalChangeCount;                               // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSelectionEntry) == 0x000008, "Wrong alignment on FCharacterSelectionEntry");
static_assert(sizeof(FCharacterSelectionEntry) == 0x000028, "Wrong size on FCharacterSelectionEntry");
static_assert(offsetof(FCharacterSelectionEntry, CharacterSKU) == 0x000000, "Member 'FCharacterSelectionEntry::CharacterSKU' has a wrong offset!");
static_assert(offsetof(FCharacterSelectionEntry, StyleSKU) == 0x000010, "Member 'FCharacterSelectionEntry::StyleSKU' has a wrong offset!");
static_assert(offsetof(FCharacterSelectionEntry, IntroPosesIndex) == 0x000020, "Member 'FCharacterSelectionEntry::IntroPosesIndex' has a wrong offset!");
static_assert(offsetof(FCharacterSelectionEntry, InternalChangeCount) == 0x000024, "Member 'FCharacterSelectionEntry::InternalChangeCount' has a wrong offset!");

// ScriptStruct TimeWatch.WeaponSelectionEntry
// 0x0028 (0x0028 - 0x0000)
struct FWeaponSelectionEntry final
{
public:
	class FString                                 WeaponSKU;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StyleSKU;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InternalChangeCount;                               // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponSelectionEntry) == 0x000008, "Wrong alignment on FWeaponSelectionEntry");
static_assert(sizeof(FWeaponSelectionEntry) == 0x000028, "Wrong size on FWeaponSelectionEntry");
static_assert(offsetof(FWeaponSelectionEntry, WeaponSKU) == 0x000000, "Member 'FWeaponSelectionEntry::WeaponSKU' has a wrong offset!");
static_assert(offsetof(FWeaponSelectionEntry, StyleSKU) == 0x000010, "Member 'FWeaponSelectionEntry::StyleSKU' has a wrong offset!");
static_assert(offsetof(FWeaponSelectionEntry, InternalChangeCount) == 0x000020, "Member 'FWeaponSelectionEntry::InternalChangeCount' has a wrong offset!");

// ScriptStruct TimeWatch.WeaponLoadoutEntry
// 0x0020 (0x0020 - 0x0000)
struct FWeaponLoadoutEntry final
{
public:
	int32                                         LoadoutID;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponSelectionEntry>          Loadout;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         InternalChangeCount;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponLoadoutEntry) == 0x000008, "Wrong alignment on FWeaponLoadoutEntry");
static_assert(sizeof(FWeaponLoadoutEntry) == 0x000020, "Wrong size on FWeaponLoadoutEntry");
static_assert(offsetof(FWeaponLoadoutEntry, LoadoutID) == 0x000000, "Member 'FWeaponLoadoutEntry::LoadoutID' has a wrong offset!");
static_assert(offsetof(FWeaponLoadoutEntry, Loadout) == 0x000008, "Member 'FWeaponLoadoutEntry::Loadout' has a wrong offset!");
static_assert(offsetof(FWeaponLoadoutEntry, InternalChangeCount) == 0x000018, "Member 'FWeaponLoadoutEntry::InternalChangeCount' has a wrong offset!");

// ScriptStruct TimeWatch.PlayerTitleEntry
// 0x0018 (0x0018 - 0x0000)
struct FPlayerTitleEntry final
{
public:
	class FString                                 SKU;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InternalChangeCount;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerTitleEntry) == 0x000008, "Wrong alignment on FPlayerTitleEntry");
static_assert(sizeof(FPlayerTitleEntry) == 0x000018, "Wrong size on FPlayerTitleEntry");
static_assert(offsetof(FPlayerTitleEntry, SKU) == 0x000000, "Member 'FPlayerTitleEntry::SKU' has a wrong offset!");
static_assert(offsetof(FPlayerTitleEntry, InternalChangeCount) == 0x000010, "Member 'FPlayerTitleEntry::InternalChangeCount' has a wrong offset!");

// ScriptStruct TimeWatch.CustomizationEntry
// 0x0068 (0x0068 - 0x0000)
struct FCustomizationEntry final
{
public:
	struct FCharacterSelectionEntry               CharacterEntry;                                    // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FWeaponLoadoutEntry                    LoadoutEntry;                                      // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPlayerTitleEntry                      PlayerTitleEntry;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         InternalChangeCount;                               // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationEntry) == 0x000008, "Wrong alignment on FCustomizationEntry");
static_assert(sizeof(FCustomizationEntry) == 0x000068, "Wrong size on FCustomizationEntry");
static_assert(offsetof(FCustomizationEntry, CharacterEntry) == 0x000000, "Member 'FCustomizationEntry::CharacterEntry' has a wrong offset!");
static_assert(offsetof(FCustomizationEntry, LoadoutEntry) == 0x000028, "Member 'FCustomizationEntry::LoadoutEntry' has a wrong offset!");
static_assert(offsetof(FCustomizationEntry, PlayerTitleEntry) == 0x000048, "Member 'FCustomizationEntry::PlayerTitleEntry' has a wrong offset!");
static_assert(offsetof(FCustomizationEntry, InternalChangeCount) == 0x000060, "Member 'FCustomizationEntry::InternalChangeCount' has a wrong offset!");

// ScriptStruct TimeWatch.PingMarker
// 0x0040 (0x0040 - 0x0000)
struct FPingMarker final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFluxPlayerState*                       Reporter;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x002C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPingMarker) == 0x000008, "Wrong alignment on FPingMarker");
static_assert(sizeof(FPingMarker) == 0x000040, "Wrong size on FPingMarker");
static_assert(offsetof(FPingMarker, ID) == 0x000000, "Member 'FPingMarker::ID' has a wrong offset!");
static_assert(offsetof(FPingMarker, Reporter) == 0x000008, "Member 'FPingMarker::Reporter' has a wrong offset!");
static_assert(offsetof(FPingMarker, Time) == 0x000010, "Member 'FPingMarker::Time' has a wrong offset!");
static_assert(offsetof(FPingMarker, Location) == 0x000014, "Member 'FPingMarker::Location' has a wrong offset!");
static_assert(offsetof(FPingMarker, Normal) == 0x000020, "Member 'FPingMarker::Normal' has a wrong offset!");
static_assert(offsetof(FPingMarker, Color) == 0x00002C, "Member 'FPingMarker::Color' has a wrong offset!");

// ScriptStruct TimeWatch.TWGameplayTargetDataFilter
// 0x0028 (0x0028 - 0x0000)
struct FTWGameplayTargetDataFilter final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SelfActor;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETWTargetDataFilterTeam                       TeamFilter;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETWTargetDataFilterSelf                       SelfFilter;                                        // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceTypeQuery;                                    // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     RequiredActorClass;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseFilter;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTWGameplayTargetDataFilter) == 0x000008, "Wrong alignment on FTWGameplayTargetDataFilter");
static_assert(sizeof(FTWGameplayTargetDataFilter) == 0x000028, "Wrong size on FTWGameplayTargetDataFilter");
static_assert(offsetof(FTWGameplayTargetDataFilter, SelfActor) == 0x000008, "Member 'FTWGameplayTargetDataFilter::SelfActor' has a wrong offset!");
static_assert(offsetof(FTWGameplayTargetDataFilter, TeamFilter) == 0x000010, "Member 'FTWGameplayTargetDataFilter::TeamFilter' has a wrong offset!");
static_assert(offsetof(FTWGameplayTargetDataFilter, SelfFilter) == 0x000011, "Member 'FTWGameplayTargetDataFilter::SelfFilter' has a wrong offset!");
static_assert(offsetof(FTWGameplayTargetDataFilter, TraceTypeQuery) == 0x000012, "Member 'FTWGameplayTargetDataFilter::TraceTypeQuery' has a wrong offset!");
static_assert(offsetof(FTWGameplayTargetDataFilter, RequiredActorClass) == 0x000018, "Member 'FTWGameplayTargetDataFilter::RequiredActorClass' has a wrong offset!");
static_assert(offsetof(FTWGameplayTargetDataFilter, bReverseFilter) == 0x000020, "Member 'FTWGameplayTargetDataFilter::bReverseFilter' has a wrong offset!");

// ScriptStruct TimeWatch.GameplayAbilityCollection
// 0x0010 (0x0010 - 0x0000)
struct FGameplayAbilityCollection final
{
public:
	TArray<class UTWGameplayTask*>                GameplayTaskCollection;                            // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityCollection) == 0x000008, "Wrong alignment on FGameplayAbilityCollection");
static_assert(sizeof(FGameplayAbilityCollection) == 0x000010, "Wrong size on FGameplayAbilityCollection");
static_assert(offsetof(FGameplayAbilityCollection, GameplayTaskCollection) == 0x000000, "Member 'FGameplayAbilityCollection::GameplayTaskCollection' has a wrong offset!");

// ScriptStruct TimeWatch.TWAbilityCustomDataHandle
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FTWAbilityCustomDataHandle final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTWAbilityCustomDataHandle) == 0x000008, "Wrong alignment on FTWAbilityCustomDataHandle");
static_assert(sizeof(FTWAbilityCustomDataHandle) == 0x000020, "Wrong size on FTWAbilityCustomDataHandle");

// ScriptStruct TimeWatch.TWAbilityExecutionData
// 0x0028 (0x0028 - 0x0000)
struct FTWAbilityExecutionData final
{
public:
	class UTWAbilitiesComponent*                  Caster;                                            // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATimeWatchCharacter*                    avatar;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTWAbility>                 AbilityClass;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExecutionTime;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExecutionTime;                                // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCloneIndex;                                 // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstExecution;                                   // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTWAbilityExecutionData) == 0x000008, "Wrong alignment on FTWAbilityExecutionData");
static_assert(sizeof(FTWAbilityExecutionData) == 0x000028, "Wrong size on FTWAbilityExecutionData");
static_assert(offsetof(FTWAbilityExecutionData, Caster) == 0x000000, "Member 'FTWAbilityExecutionData::Caster' has a wrong offset!");
static_assert(offsetof(FTWAbilityExecutionData, avatar) == 0x000008, "Member 'FTWAbilityExecutionData::avatar' has a wrong offset!");
static_assert(offsetof(FTWAbilityExecutionData, AbilityClass) == 0x000010, "Member 'FTWAbilityExecutionData::AbilityClass' has a wrong offset!");
static_assert(offsetof(FTWAbilityExecutionData, ExecutionTime) == 0x000018, "Member 'FTWAbilityExecutionData::ExecutionTime' has a wrong offset!");
static_assert(offsetof(FTWAbilityExecutionData, LocalExecutionTime) == 0x00001C, "Member 'FTWAbilityExecutionData::LocalExecutionTime' has a wrong offset!");
static_assert(offsetof(FTWAbilityExecutionData, CurrentCloneIndex) == 0x000020, "Member 'FTWAbilityExecutionData::CurrentCloneIndex' has a wrong offset!");
static_assert(offsetof(FTWAbilityExecutionData, bFirstExecution) == 0x000024, "Member 'FTWAbilityExecutionData::bFirstExecution' has a wrong offset!");

// ScriptStruct TimeWatch.MatchEvent
// 0x0028 (0x0028 - 0x0000)
struct FMatchEvent final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATimeWatchCharacter*                    Killed;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATimeWatchCharacter*                    Killer;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             WeaponTexture;                                     // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConfirmed;                                        // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiscarded;                                        // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchEvent) == 0x000008, "Wrong alignment on FMatchEvent");
static_assert(sizeof(FMatchEvent) == 0x000028, "Wrong size on FMatchEvent");
static_assert(offsetof(FMatchEvent, Timestamp) == 0x000000, "Member 'FMatchEvent::Timestamp' has a wrong offset!");
static_assert(offsetof(FMatchEvent, Killed) == 0x000008, "Member 'FMatchEvent::Killed' has a wrong offset!");
static_assert(offsetof(FMatchEvent, Killer) == 0x000010, "Member 'FMatchEvent::Killer' has a wrong offset!");
static_assert(offsetof(FMatchEvent, WeaponTexture) == 0x000018, "Member 'FMatchEvent::WeaponTexture' has a wrong offset!");
static_assert(offsetof(FMatchEvent, bConfirmed) == 0x000020, "Member 'FMatchEvent::bConfirmed' has a wrong offset!");
static_assert(offsetof(FMatchEvent, bDiscarded) == 0x000021, "Member 'FMatchEvent::bDiscarded' has a wrong offset!");

// ScriptStruct TimeWatch.StateDebugInfo
// 0x0028 (0x0028 - 0x0000)
struct FStateDebugInfo final
{
public:
	class FString                                 DebugIdentifier;                                   // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewCurrentTime;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentState;                                      // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateDebugInfo) == 0x000008, "Wrong alignment on FStateDebugInfo");
static_assert(sizeof(FStateDebugInfo) == 0x000028, "Wrong size on FStateDebugInfo");
static_assert(offsetof(FStateDebugInfo, DebugIdentifier) == 0x000000, "Member 'FStateDebugInfo::DebugIdentifier' has a wrong offset!");
static_assert(offsetof(FStateDebugInfo, CurrentTime) == 0x000010, "Member 'FStateDebugInfo::CurrentTime' has a wrong offset!");
static_assert(offsetof(FStateDebugInfo, NewCurrentTime) == 0x000014, "Member 'FStateDebugInfo::NewCurrentTime' has a wrong offset!");
static_assert(offsetof(FStateDebugInfo, CurrentState) == 0x000018, "Member 'FStateDebugInfo::CurrentState' has a wrong offset!");

// ScriptStruct TimeWatch.PhysicEventRegistry
// 0x0018 (0x0018 - 0x0000)
struct FPhysicEventRegistry final
{
public:
	TArray<int32>                                 RecordsPendingConfirmation;                        // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFluxTimelineStaticActor*               OwnerTimeline;                                     // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPhysicEventRegistry) == 0x000008, "Wrong alignment on FPhysicEventRegistry");
static_assert(sizeof(FPhysicEventRegistry) == 0x000018, "Wrong size on FPhysicEventRegistry");
static_assert(offsetof(FPhysicEventRegistry, RecordsPendingConfirmation) == 0x000000, "Member 'FPhysicEventRegistry::RecordsPendingConfirmation' has a wrong offset!");
static_assert(offsetof(FPhysicEventRegistry, OwnerTimeline) == 0x000010, "Member 'FPhysicEventRegistry::OwnerTimeline' has a wrong offset!");

// ScriptStruct TimeWatch.RewardData
// 0x0028 (0x0028 - 0x0000)
struct FRewardData final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumValue;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringValue;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardData) == 0x000008, "Wrong alignment on FRewardData");
static_assert(sizeof(FRewardData) == 0x000028, "Wrong size on FRewardData");
static_assert(offsetof(FRewardData, Type) == 0x000000, "Member 'FRewardData::Type' has a wrong offset!");
static_assert(offsetof(FRewardData, NumValue) == 0x000010, "Member 'FRewardData::NumValue' has a wrong offset!");
static_assert(offsetof(FRewardData, StringValue) == 0x000018, "Member 'FRewardData::StringValue' has a wrong offset!");

// ScriptStruct TimeWatch.RewardTrackTier
// 0x0018 (0x0018 - 0x0000)
struct FRewardTrackTier final
{
public:
	int32                                         PointsRequired;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardData>                    Rewards;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardTrackTier) == 0x000008, "Wrong alignment on FRewardTrackTier");
static_assert(sizeof(FRewardTrackTier) == 0x000018, "Wrong size on FRewardTrackTier");
static_assert(offsetof(FRewardTrackTier, PointsRequired) == 0x000000, "Member 'FRewardTrackTier::PointsRequired' has a wrong offset!");
static_assert(offsetof(FRewardTrackTier, Rewards) == 0x000008, "Member 'FRewardTrackTier::Rewards' has a wrong offset!");

// ScriptStruct TimeWatch.MatchResultDataResponse
// 0x0058 (0x0058 - 0x0000)
struct FMatchResultDataResponse final
{
public:
	int32                                         Xp;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Coins;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoardScore;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoardLevel;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassPoints;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRewardTrackActive;                              // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AccessStatus;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardTrackCurrentTier;                            // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardTrackPreviousTier;                           // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousTierRequiredPoints;                        // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardTrackTier>               RewardTrackTiers;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         AwardedItemsSKUs;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FRewardData>                    DailyBoostClaimedRewards;                          // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchResultDataResponse) == 0x000008, "Wrong alignment on FMatchResultDataResponse");
static_assert(sizeof(FMatchResultDataResponse) == 0x000058, "Wrong size on FMatchResultDataResponse");
static_assert(offsetof(FMatchResultDataResponse, Xp) == 0x000000, "Member 'FMatchResultDataResponse::Xp' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, Coins) == 0x000004, "Member 'FMatchResultDataResponse::Coins' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, BoardScore) == 0x000008, "Member 'FMatchResultDataResponse::BoardScore' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, BoardLevel) == 0x00000C, "Member 'FMatchResultDataResponse::BoardLevel' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, BattlePassPoints) == 0x000010, "Member 'FMatchResultDataResponse::BattlePassPoints' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, bIsRewardTrackActive) == 0x000014, "Member 'FMatchResultDataResponse::bIsRewardTrackActive' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, AccessStatus) == 0x000018, "Member 'FMatchResultDataResponse::AccessStatus' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, RewardTrackCurrentTier) == 0x00001C, "Member 'FMatchResultDataResponse::RewardTrackCurrentTier' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, RewardTrackPreviousTier) == 0x000020, "Member 'FMatchResultDataResponse::RewardTrackPreviousTier' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, PreviousTierRequiredPoints) == 0x000024, "Member 'FMatchResultDataResponse::PreviousTierRequiredPoints' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, RewardTrackTiers) == 0x000028, "Member 'FMatchResultDataResponse::RewardTrackTiers' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, AwardedItemsSKUs) == 0x000038, "Member 'FMatchResultDataResponse::AwardedItemsSKUs' has a wrong offset!");
static_assert(offsetof(FMatchResultDataResponse, DailyBoostClaimedRewards) == 0x000048, "Member 'FMatchResultDataResponse::DailyBoostClaimedRewards' has a wrong offset!");

// ScriptStruct TimeWatch.TWAbilityInstanceData
// 0x0018 (0x0018 - 0x0000)
struct FTWAbilityInstanceData final
{
public:
	class UTWAbilitiesComponent*                  Caster;                                            // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATimeWatchCharacter*                    OwningCharacter;                                   // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingDuration;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalExecutionTime;                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWAbilityInstanceData) == 0x000008, "Wrong alignment on FTWAbilityInstanceData");
static_assert(sizeof(FTWAbilityInstanceData) == 0x000018, "Wrong size on FTWAbilityInstanceData");
static_assert(offsetof(FTWAbilityInstanceData, Caster) == 0x000000, "Member 'FTWAbilityInstanceData::Caster' has a wrong offset!");
static_assert(offsetof(FTWAbilityInstanceData, OwningCharacter) == 0x000008, "Member 'FTWAbilityInstanceData::OwningCharacter' has a wrong offset!");
static_assert(offsetof(FTWAbilityInstanceData, RemainingDuration) == 0x000010, "Member 'FTWAbilityInstanceData::RemainingDuration' has a wrong offset!");
static_assert(offsetof(FTWAbilityInstanceData, LocalExecutionTime) == 0x000014, "Member 'FTWAbilityInstanceData::LocalExecutionTime' has a wrong offset!");

// ScriptStruct TimeWatch.TeamColorConfig
// 0x0028 (0x0028 - 0x0000)
struct FTeamColorConfig final
{
public:
	TArray<struct FLinearColor>                   Colors;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseAlternativeColorsOnFixedColorsMode;            // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   FixedMode_AlternativeColors;                       // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamColorConfig) == 0x000008, "Wrong alignment on FTeamColorConfig");
static_assert(sizeof(FTeamColorConfig) == 0x000028, "Wrong size on FTeamColorConfig");
static_assert(offsetof(FTeamColorConfig, Colors) == 0x000000, "Member 'FTeamColorConfig::Colors' has a wrong offset!");
static_assert(offsetof(FTeamColorConfig, bUseAlternativeColorsOnFixedColorsMode) == 0x000010, "Member 'FTeamColorConfig::bUseAlternativeColorsOnFixedColorsMode' has a wrong offset!");
static_assert(offsetof(FTeamColorConfig, FixedMode_AlternativeColors) == 0x000018, "Member 'FTeamColorConfig::FixedMode_AlternativeColors' has a wrong offset!");

// ScriptStruct TimeWatch.ScoreBoardColors
// 0x0050 (0x0050 - 0x0000)
struct FScoreBoardColors final
{
public:
	struct FTeamColorConfig                       TeamsTopColors;                                    // 0x0000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       TeamsSecondaryColors;                              // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreBoardColors) == 0x000008, "Wrong alignment on FScoreBoardColors");
static_assert(sizeof(FScoreBoardColors) == 0x000050, "Wrong size on FScoreBoardColors");
static_assert(offsetof(FScoreBoardColors, TeamsTopColors) == 0x000000, "Member 'FScoreBoardColors::TeamsTopColors' has a wrong offset!");
static_assert(offsetof(FScoreBoardColors, TeamsSecondaryColors) == 0x000028, "Member 'FScoreBoardColors::TeamsSecondaryColors' has a wrong offset!");

// ScriptStruct TimeWatch.TWChallengeRule
// 0x0014 (0x0014 - 0x0000)
struct FTWChallengeRule final
{
public:
	class FName                                   RuleName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuleTarget;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERuleAcceptType                               AcceptRule;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCounter;                                        // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPercentage;                                     // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x5];                                        // 0x000F(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTWChallengeRule) == 0x000004, "Wrong alignment on FTWChallengeRule");
static_assert(sizeof(FTWChallengeRule) == 0x000014, "Wrong size on FTWChallengeRule");
static_assert(offsetof(FTWChallengeRule, RuleName) == 0x000000, "Member 'FTWChallengeRule::RuleName' has a wrong offset!");
static_assert(offsetof(FTWChallengeRule, RuleTarget) == 0x000008, "Member 'FTWChallengeRule::RuleTarget' has a wrong offset!");
static_assert(offsetof(FTWChallengeRule, AcceptRule) == 0x00000C, "Member 'FTWChallengeRule::AcceptRule' has a wrong offset!");
static_assert(offsetof(FTWChallengeRule, bIsCounter) == 0x00000D, "Member 'FTWChallengeRule::bIsCounter' has a wrong offset!");
static_assert(offsetof(FTWChallengeRule, bIsPercentage) == 0x00000E, "Member 'FTWChallengeRule::bIsPercentage' has a wrong offset!");

// ScriptStruct TimeWatch.DropdownScrollListElement
// 0x0028 (0x0028 - 0x0000)
struct FDropdownScrollListElement final
{
public:
	class FText                                   ElementDisplayText;                                // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 ElementIdentifier;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropdownScrollListElement) == 0x000008, "Wrong alignment on FDropdownScrollListElement");
static_assert(sizeof(FDropdownScrollListElement) == 0x000028, "Wrong size on FDropdownScrollListElement");
static_assert(offsetof(FDropdownScrollListElement, ElementDisplayText) == 0x000000, "Member 'FDropdownScrollListElement::ElementDisplayText' has a wrong offset!");
static_assert(offsetof(FDropdownScrollListElement, ElementIdentifier) == 0x000018, "Member 'FDropdownScrollListElement::ElementIdentifier' has a wrong offset!");

// ScriptStruct TimeWatch.ProjectileSpawnRecord
// 0x0018 (0x0018 - 0x0000)
struct FProjectileSpawnRecord final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileSpawnRecord) == 0x000004, "Wrong alignment on FProjectileSpawnRecord");
static_assert(sizeof(FProjectileSpawnRecord) == 0x000018, "Wrong size on FProjectileSpawnRecord");
static_assert(offsetof(FProjectileSpawnRecord, Location) == 0x000000, "Member 'FProjectileSpawnRecord::Location' has a wrong offset!");
static_assert(offsetof(FProjectileSpawnRecord, Rotation) == 0x00000C, "Member 'FProjectileSpawnRecord::Rotation' has a wrong offset!");

// ScriptStruct TimeWatch.SkeletalMeshStructure
// 0x0030 (0x0030 - 0x0000)
struct FSkeletalMeshStructure final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimBp;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshStructure) == 0x000008, "Wrong alignment on FSkeletalMeshStructure");
static_assert(sizeof(FSkeletalMeshStructure) == 0x000030, "Wrong size on FSkeletalMeshStructure");
static_assert(offsetof(FSkeletalMeshStructure, Mesh) == 0x000000, "Member 'FSkeletalMeshStructure::Mesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshStructure, AnimBp) == 0x000028, "Member 'FSkeletalMeshStructure::AnimBp' has a wrong offset!");

// ScriptStruct TimeWatch.PlayerMissionData
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FPlayerMissionData final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerMissionData) == 0x000008, "Wrong alignment on FPlayerMissionData");
static_assert(sizeof(FPlayerMissionData) == 0x000040, "Wrong size on FPlayerMissionData");

// ScriptStruct TimeWatch.CharacterAbilitiesData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterAbilitiesData final
{
public:
	TArray<class UTWAbilityDataAsset*>            AbilitiesDataAsset;                                // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAbilitiesData) == 0x000008, "Wrong alignment on FCharacterAbilitiesData");
static_assert(sizeof(FCharacterAbilitiesData) == 0x000010, "Wrong size on FCharacterAbilitiesData");
static_assert(offsetof(FCharacterAbilitiesData, AbilitiesDataAsset) == 0x000000, "Member 'FCharacterAbilitiesData::AbilitiesDataAsset' has a wrong offset!");

// ScriptStruct TimeWatch.GameStateLastDemotableTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FGameStateLastDemotableTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameStateLastDemotableTickFunction) == 0x000008, "Wrong alignment on FGameStateLastDemotableTickFunction");
static_assert(sizeof(FGameStateLastDemotableTickFunction) == 0x000030, "Wrong size on FGameStateLastDemotableTickFunction");

// ScriptStruct TimeWatch.TWMeleeConfig
// 0x0028 (0x0028 - 0x0000)
struct FTWMeleeConfig final
{
public:
	float                                         DurationUntilHit;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolDown;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepDistance;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColliderRadius;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLocationOffset;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Impulse;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValidHalfAngle;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATemporalParticle>          MeleeImpactParticleClass;                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWMeleeConfig) == 0x000008, "Wrong alignment on FTWMeleeConfig");
static_assert(sizeof(FTWMeleeConfig) == 0x000028, "Wrong size on FTWMeleeConfig");
static_assert(offsetof(FTWMeleeConfig, DurationUntilHit) == 0x000000, "Member 'FTWMeleeConfig::DurationUntilHit' has a wrong offset!");
static_assert(offsetof(FTWMeleeConfig, CoolDown) == 0x000004, "Member 'FTWMeleeConfig::CoolDown' has a wrong offset!");
static_assert(offsetof(FTWMeleeConfig, Damage) == 0x000008, "Member 'FTWMeleeConfig::Damage' has a wrong offset!");
static_assert(offsetof(FTWMeleeConfig, SweepDistance) == 0x00000C, "Member 'FTWMeleeConfig::SweepDistance' has a wrong offset!");
static_assert(offsetof(FTWMeleeConfig, ColliderRadius) == 0x000010, "Member 'FTWMeleeConfig::ColliderRadius' has a wrong offset!");
static_assert(offsetof(FTWMeleeConfig, StartLocationOffset) == 0x000014, "Member 'FTWMeleeConfig::StartLocationOffset' has a wrong offset!");
static_assert(offsetof(FTWMeleeConfig, Impulse) == 0x000018, "Member 'FTWMeleeConfig::Impulse' has a wrong offset!");
static_assert(offsetof(FTWMeleeConfig, MaxValidHalfAngle) == 0x00001C, "Member 'FTWMeleeConfig::MaxValidHalfAngle' has a wrong offset!");
static_assert(offsetof(FTWMeleeConfig, MeleeImpactParticleClass) == 0x000020, "Member 'FTWMeleeConfig::MeleeImpactParticleClass' has a wrong offset!");

// ScriptStruct TimeWatch.GameStateSyncData
// 0x0010 (0x0010 - 0x0000)
struct FGameStateSyncData final
{
public:
	int32                                         CurrentCloneIndex;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLoop;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFluxCapacitorStates                          CurrentState;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameStateSyncData) == 0x000004, "Wrong alignment on FGameStateSyncData");
static_assert(sizeof(FGameStateSyncData) == 0x000010, "Wrong size on FGameStateSyncData");
static_assert(offsetof(FGameStateSyncData, CurrentCloneIndex) == 0x000000, "Member 'FGameStateSyncData::CurrentCloneIndex' has a wrong offset!");
static_assert(offsetof(FGameStateSyncData, CurrentLoop) == 0x000004, "Member 'FGameStateSyncData::CurrentLoop' has a wrong offset!");
static_assert(offsetof(FGameStateSyncData, CurrentTime) == 0x000008, "Member 'FGameStateSyncData::CurrentTime' has a wrong offset!");
static_assert(offsetof(FGameStateSyncData, CurrentState) == 0x00000C, "Member 'FGameStateSyncData::CurrentState' has a wrong offset!");

// ScriptStruct TimeWatch.ChatChannelUIConfig
// 0x0040 (0x0040 - 0x0000)
struct FChatChannelUIConfig final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            Color;                                             // 0x0018(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatChannelUIConfig) == 0x000008, "Wrong alignment on FChatChannelUIConfig");
static_assert(sizeof(FChatChannelUIConfig) == 0x000040, "Wrong size on FChatChannelUIConfig");
static_assert(offsetof(FChatChannelUIConfig, DisplayName) == 0x000000, "Member 'FChatChannelUIConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(FChatChannelUIConfig, Color) == 0x000018, "Member 'FChatChannelUIConfig::Color' has a wrong offset!");

// ScriptStruct TimeWatch.MontageResumeData
// 0x0018 (0x0018 - 0x0000)
struct FMontageResumeData final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         rate;                                              // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMontageResumeData) == 0x000008, "Wrong alignment on FMontageResumeData");
static_assert(sizeof(FMontageResumeData) == 0x000018, "Wrong size on FMontageResumeData");
static_assert(offsetof(FMontageResumeData, Montage) == 0x000000, "Member 'FMontageResumeData::Montage' has a wrong offset!");
static_assert(offsetof(FMontageResumeData, SectionName) == 0x000008, "Member 'FMontageResumeData::SectionName' has a wrong offset!");
static_assert(offsetof(FMontageResumeData, Position) == 0x000010, "Member 'FMontageResumeData::Position' has a wrong offset!");
static_assert(offsetof(FMontageResumeData, rate) == 0x000014, "Member 'FMontageResumeData::rate' has a wrong offset!");

// ScriptStruct TimeWatch.JumpModifier
// 0x0010 (0x0010 - 0x0000)
struct FJumpModifier final
{
public:
	struct FVector                                FloorNormal;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJumpModifier) == 0x000004, "Wrong alignment on FJumpModifier");
static_assert(sizeof(FJumpModifier) == 0x000010, "Wrong size on FJumpModifier");
static_assert(offsetof(FJumpModifier, FloorNormal) == 0x000000, "Member 'FJumpModifier::FloorNormal' has a wrong offset!");
static_assert(offsetof(FJumpModifier, Scale) == 0x00000C, "Member 'FJumpModifier::Scale' has a wrong offset!");

// ScriptStruct TimeWatch.TextChatChannelPostPolicyConfig
// 0x0008 (0x0008 - 0x0000)
struct FTextChatChannelPostPolicyConfig final
{
public:
	int32                                         MessagesAllowedInTimeWindow;                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWindowSize;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextChatChannelPostPolicyConfig) == 0x000004, "Wrong alignment on FTextChatChannelPostPolicyConfig");
static_assert(sizeof(FTextChatChannelPostPolicyConfig) == 0x000008, "Wrong size on FTextChatChannelPostPolicyConfig");
static_assert(offsetof(FTextChatChannelPostPolicyConfig, MessagesAllowedInTimeWindow) == 0x000000, "Member 'FTextChatChannelPostPolicyConfig::MessagesAllowedInTimeWindow' has a wrong offset!");
static_assert(offsetof(FTextChatChannelPostPolicyConfig, TimeWindowSize) == 0x000004, "Member 'FTextChatChannelPostPolicyConfig::TimeWindowSize' has a wrong offset!");

// ScriptStruct TimeWatch.Team
// 0x0010 (0x0010 - 0x0000)
struct FTeam final
{
public:
	TArray<class FString>                         PlayersID;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeam) == 0x000008, "Wrong alignment on FTeam");
static_assert(sizeof(FTeam) == 0x000010, "Wrong size on FTeam");
static_assert(offsetof(FTeam, PlayersID) == 0x000000, "Member 'FTeam::PlayersID' has a wrong offset!");

// ScriptStruct TimeWatch.MatchSettings
// 0x0040 (0x0040 - 0x0000)
struct FMatchSettings final
{
public:
	TArray<struct FTeam>                          Teams;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTeam                                  SpectatorTeam;                                     // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	int32                                         PlayerCountPerTeam;                                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CloneCount;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelGoal;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopLength;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRematchEnabled;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSinglePlayer;                                   // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAICharacters;                                  // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHealthPackMode                               HealthPackMode;                                    // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHealthPackHealingMode                        HealthPackHealingMode;                             // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPrimaryWeaponChange;                         // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOvertimeMode                                 OvertimeMode;                                      // 0x0036(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseQuantumTime;                                   // 0x0037(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGodMode;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPassiveAbilitiesActive;                           // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchSettings) == 0x000008, "Wrong alignment on FMatchSettings");
static_assert(sizeof(FMatchSettings) == 0x000040, "Wrong size on FMatchSettings");
static_assert(offsetof(FMatchSettings, Teams) == 0x000000, "Member 'FMatchSettings::Teams' has a wrong offset!");
static_assert(offsetof(FMatchSettings, SpectatorTeam) == 0x000010, "Member 'FMatchSettings::SpectatorTeam' has a wrong offset!");
static_assert(offsetof(FMatchSettings, PlayerCountPerTeam) == 0x000020, "Member 'FMatchSettings::PlayerCountPerTeam' has a wrong offset!");
static_assert(offsetof(FMatchSettings, CloneCount) == 0x000024, "Member 'FMatchSettings::CloneCount' has a wrong offset!");
static_assert(offsetof(FMatchSettings, LevelGoal) == 0x000028, "Member 'FMatchSettings::LevelGoal' has a wrong offset!");
static_assert(offsetof(FMatchSettings, LoopLength) == 0x00002C, "Member 'FMatchSettings::LoopLength' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bIsRematchEnabled) == 0x000030, "Member 'FMatchSettings::bIsRematchEnabled' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bIsSinglePlayer) == 0x000031, "Member 'FMatchSettings::bIsSinglePlayer' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bUseAICharacters) == 0x000032, "Member 'FMatchSettings::bUseAICharacters' has a wrong offset!");
static_assert(offsetof(FMatchSettings, HealthPackMode) == 0x000033, "Member 'FMatchSettings::HealthPackMode' has a wrong offset!");
static_assert(offsetof(FMatchSettings, HealthPackHealingMode) == 0x000034, "Member 'FMatchSettings::HealthPackHealingMode' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowPrimaryWeaponChange) == 0x000035, "Member 'FMatchSettings::bAllowPrimaryWeaponChange' has a wrong offset!");
static_assert(offsetof(FMatchSettings, OvertimeMode) == 0x000036, "Member 'FMatchSettings::OvertimeMode' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bUseQuantumTime) == 0x000037, "Member 'FMatchSettings::bUseQuantumTime' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bEnableGodMode) == 0x000038, "Member 'FMatchSettings::bEnableGodMode' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bPassiveAbilitiesActive) == 0x000039, "Member 'FMatchSettings::bPassiveAbilitiesActive' has a wrong offset!");

// ScriptStruct TimeWatch.TournamentLeaderboardData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FTournamentLeaderboardData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTournamentLeaderboardData) == 0x000008, "Wrong alignment on FTournamentLeaderboardData");
static_assert(sizeof(FTournamentLeaderboardData) == 0x000010, "Wrong size on FTournamentLeaderboardData");

// ScriptStruct TimeWatch.BarrelParadoxData
// 0x0028 (0x0028 - 0x0000)
struct FBarrelParadoxData final
{
public:
	class ATimeWatchCharacter*                    Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATWExplosionGhost*                      Ghost;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATimeWatchCharacter*>            Victims;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bConfirmed;                                        // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBarrelParadoxData) == 0x000008, "Wrong alignment on FBarrelParadoxData");
static_assert(sizeof(FBarrelParadoxData) == 0x000028, "Wrong size on FBarrelParadoxData");
static_assert(offsetof(FBarrelParadoxData, Instigator) == 0x000000, "Member 'FBarrelParadoxData::Instigator' has a wrong offset!");
static_assert(offsetof(FBarrelParadoxData, Ghost) == 0x000008, "Member 'FBarrelParadoxData::Ghost' has a wrong offset!");
static_assert(offsetof(FBarrelParadoxData, Victims) == 0x000010, "Member 'FBarrelParadoxData::Victims' has a wrong offset!");
static_assert(offsetof(FBarrelParadoxData, bConfirmed) == 0x000020, "Member 'FBarrelParadoxData::bConfirmed' has a wrong offset!");

// ScriptStruct TimeWatch.FluxTimelineDominationRecordData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FFluxTimelineDominationRecordData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFluxTimelineDominationRecordData) == 0x000004, "Wrong alignment on FFluxTimelineDominationRecordData");
static_assert(sizeof(FFluxTimelineDominationRecordData) == 0x000008, "Wrong size on FFluxTimelineDominationRecordData");

// ScriptStruct TimeWatch.WeaponChangeData
// 0x0018 (0x0018 - 0x0000)
struct FWeaponChangeData final
{
public:
	int32                                         PreviousWeaponSlotIndex;                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewWeaponSlotIndex;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentlyVisibleWeaponSlotIndex;                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingCosmeticWeaponChange;                      // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponChangeProgress;                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangingWeapons;                                  // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponChangeData) == 0x000004, "Wrong alignment on FWeaponChangeData");
static_assert(sizeof(FWeaponChangeData) == 0x000018, "Wrong size on FWeaponChangeData");
static_assert(offsetof(FWeaponChangeData, PreviousWeaponSlotIndex) == 0x000000, "Member 'FWeaponChangeData::PreviousWeaponSlotIndex' has a wrong offset!");
static_assert(offsetof(FWeaponChangeData, NewWeaponSlotIndex) == 0x000004, "Member 'FWeaponChangeData::NewWeaponSlotIndex' has a wrong offset!");
static_assert(offsetof(FWeaponChangeData, CurrentlyVisibleWeaponSlotIndex) == 0x000008, "Member 'FWeaponChangeData::CurrentlyVisibleWeaponSlotIndex' has a wrong offset!");
static_assert(offsetof(FWeaponChangeData, bPendingCosmeticWeaponChange) == 0x00000C, "Member 'FWeaponChangeData::bPendingCosmeticWeaponChange' has a wrong offset!");
static_assert(offsetof(FWeaponChangeData, WeaponChangeProgress) == 0x000010, "Member 'FWeaponChangeData::WeaponChangeProgress' has a wrong offset!");
static_assert(offsetof(FWeaponChangeData, bChangingWeapons) == 0x000014, "Member 'FWeaponChangeData::bChangingWeapons' has a wrong offset!");

// ScriptStruct TimeWatch.TemporalWeaponSnapshot
// 0x0024 (0x0024 - 0x0000)
struct FTemporalWeaponSnapshot final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ammo;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTimer;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadTimer;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireTimer;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstTimer;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChamberTimer;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerinTimer;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        BulletIndex;                                       // 0x0020(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTemporalWeaponSnapshot) == 0x000004, "Wrong alignment on FTemporalWeaponSnapshot");
static_assert(sizeof(FTemporalWeaponSnapshot) == 0x000024, "Wrong size on FTemporalWeaponSnapshot");
static_assert(offsetof(FTemporalWeaponSnapshot, SlotIndex) == 0x000000, "Member 'FTemporalWeaponSnapshot::SlotIndex' has a wrong offset!");
static_assert(offsetof(FTemporalWeaponSnapshot, Ammo) == 0x000004, "Member 'FTemporalWeaponSnapshot::Ammo' has a wrong offset!");
static_assert(offsetof(FTemporalWeaponSnapshot, DrawTimer) == 0x000008, "Member 'FTemporalWeaponSnapshot::DrawTimer' has a wrong offset!");
static_assert(offsetof(FTemporalWeaponSnapshot, ReloadTimer) == 0x00000C, "Member 'FTemporalWeaponSnapshot::ReloadTimer' has a wrong offset!");
static_assert(offsetof(FTemporalWeaponSnapshot, FireTimer) == 0x000010, "Member 'FTemporalWeaponSnapshot::FireTimer' has a wrong offset!");
static_assert(offsetof(FTemporalWeaponSnapshot, BurstTimer) == 0x000014, "Member 'FTemporalWeaponSnapshot::BurstTimer' has a wrong offset!");
static_assert(offsetof(FTemporalWeaponSnapshot, ChamberTimer) == 0x000018, "Member 'FTemporalWeaponSnapshot::ChamberTimer' has a wrong offset!");
static_assert(offsetof(FTemporalWeaponSnapshot, TriggerinTimer) == 0x00001C, "Member 'FTemporalWeaponSnapshot::TriggerinTimer' has a wrong offset!");
static_assert(offsetof(FTemporalWeaponSnapshot, BulletIndex) == 0x000020, "Member 'FTemporalWeaponSnapshot::BulletIndex' has a wrong offset!");

// ScriptStruct TimeWatch.FluxTimelinePlayerRecordData
// 0x01F8 (0x01F8 - 0x0000)
struct FFluxTimelinePlayerRecordData final
{
public:
	uint8                                         Pad_0[0x120];                                      // 0x0000(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          FP_Pose;                                           // 0x0120(0x0038)(Transient, NativeAccessSpecifierPublic)
	struct FTemporalWeaponSnapshot                WeaponSnapshot;                                    // 0x0158(0x0024)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FTemporalWeaponSnapshot                SecondaryWeaponSnapshot;                           // 0x017C(0x0024)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	class ATemporalWeapon*                        Cosmetic_CurrentVisibleWeapon;                     // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x50];                                     // 0x01A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFluxTimelinePlayerRecordData) == 0x000008, "Wrong alignment on FFluxTimelinePlayerRecordData");
static_assert(sizeof(FFluxTimelinePlayerRecordData) == 0x0001F8, "Wrong size on FFluxTimelinePlayerRecordData");
static_assert(offsetof(FFluxTimelinePlayerRecordData, FP_Pose) == 0x000120, "Member 'FFluxTimelinePlayerRecordData::FP_Pose' has a wrong offset!");
static_assert(offsetof(FFluxTimelinePlayerRecordData, WeaponSnapshot) == 0x000158, "Member 'FFluxTimelinePlayerRecordData::WeaponSnapshot' has a wrong offset!");
static_assert(offsetof(FFluxTimelinePlayerRecordData, SecondaryWeaponSnapshot) == 0x00017C, "Member 'FFluxTimelinePlayerRecordData::SecondaryWeaponSnapshot' has a wrong offset!");
static_assert(offsetof(FFluxTimelinePlayerRecordData, Cosmetic_CurrentVisibleWeapon) == 0x0001A0, "Member 'FFluxTimelinePlayerRecordData::Cosmetic_CurrentVisibleWeapon' has a wrong offset!");

// ScriptStruct TimeWatch.VsCharacterInfor
// 0x0090 (0x0090 - 0x0000)
struct FVsCharacterInfor final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSkeletalMeshStructure                 SkeletalMeshData;                                  // 0x0008(0x0030)(Transient, NativeAccessSpecifierPublic)
	TMap<int32, class UMaterialInstanceDynamic*>  DynamicMaterialMap;                                // 0x0038(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        Animation;                                         // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVsCharacterInfor) == 0x000008, "Wrong alignment on FVsCharacterInfor");
static_assert(sizeof(FVsCharacterInfor) == 0x000090, "Wrong size on FVsCharacterInfor");
static_assert(offsetof(FVsCharacterInfor, SkeletalMeshComponent) == 0x000000, "Member 'FVsCharacterInfor::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(FVsCharacterInfor, SkeletalMeshData) == 0x000008, "Member 'FVsCharacterInfor::SkeletalMeshData' has a wrong offset!");
static_assert(offsetof(FVsCharacterInfor, DynamicMaterialMap) == 0x000038, "Member 'FVsCharacterInfor::DynamicMaterialMap' has a wrong offset!");
static_assert(offsetof(FVsCharacterInfor, Animation) == 0x000088, "Member 'FVsCharacterInfor::Animation' has a wrong offset!");

// ScriptStruct TimeWatch.MeshRecordData
// 0x0060 (0x0060 - 0x0000)
struct FMeshRecordData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseSnapshot                          Pose;                                              // 0x0018(0x0038)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FSocketData>                    BoneSocketData;                                    // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshRecordData) == 0x000008, "Wrong alignment on FMeshRecordData");
static_assert(sizeof(FMeshRecordData) == 0x000060, "Wrong size on FMeshRecordData");
static_assert(offsetof(FMeshRecordData, Location) == 0x000000, "Member 'FMeshRecordData::Location' has a wrong offset!");
static_assert(offsetof(FMeshRecordData, Rotation) == 0x00000C, "Member 'FMeshRecordData::Rotation' has a wrong offset!");
static_assert(offsetof(FMeshRecordData, Pose) == 0x000018, "Member 'FMeshRecordData::Pose' has a wrong offset!");
static_assert(offsetof(FMeshRecordData, BoneSocketData) == 0x000050, "Member 'FMeshRecordData::BoneSocketData' has a wrong offset!");

// ScriptStruct TimeWatch.BoxedUTexture
// 0x0008 (0x0008 - 0x0000)
struct FBoxedUTexture final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoxedUTexture) == 0x000008, "Wrong alignment on FBoxedUTexture");
static_assert(sizeof(FBoxedUTexture) == 0x000008, "Wrong size on FBoxedUTexture");
static_assert(offsetof(FBoxedUTexture, Texture) == 0x000000, "Member 'FBoxedUTexture::Texture' has a wrong offset!");

// ScriptStruct TimeWatch.ParadoxData
// 0x0010 (0x0010 - 0x0000)
struct FParadoxData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ATWCharacterGhost*                      Ghost;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParadoxData) == 0x000008, "Wrong alignment on FParadoxData");
static_assert(sizeof(FParadoxData) == 0x000010, "Wrong size on FParadoxData");
static_assert(offsetof(FParadoxData, Ghost) == 0x000008, "Member 'FParadoxData::Ghost' has a wrong offset!");

// ScriptStruct TimeWatch.ProjectileState
// 0x001C (0x001C - 0x0000)
struct FProjectileState final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileState) == 0x000004, "Wrong alignment on FProjectileState");
static_assert(sizeof(FProjectileState) == 0x00001C, "Wrong size on FProjectileState");
static_assert(offsetof(FProjectileState, Location) == 0x000000, "Member 'FProjectileState::Location' has a wrong offset!");
static_assert(offsetof(FProjectileState, Velocity) == 0x00000C, "Member 'FProjectileState::Velocity' has a wrong offset!");
static_assert(offsetof(FProjectileState, Timestamp) == 0x000018, "Member 'FProjectileState::Timestamp' has a wrong offset!");

// ScriptStruct TimeWatch.ProjectileParadoxData
// 0x0050 (0x0050 - 0x0000)
struct FProjectileParadoxData final
{
public:
	TArray<struct FProjectileState>               Data;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ATimeWatchCharacter*>            Victims;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ATimeWatchCharacter*                    Instigator;                                        // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATWProjectileGhost*                     GhostParadox;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConfirmed;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletIndex;                                       // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PelletIndex;                                       // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATWPhysicalExplodingProjectile*         DefaultProjectile;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionTimestamp;                                // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDuration;                                 // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileParadoxData) == 0x000008, "Wrong alignment on FProjectileParadoxData");
static_assert(sizeof(FProjectileParadoxData) == 0x000050, "Wrong size on FProjectileParadoxData");
static_assert(offsetof(FProjectileParadoxData, Data) == 0x000000, "Member 'FProjectileParadoxData::Data' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, Victims) == 0x000010, "Member 'FProjectileParadoxData::Victims' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, Instigator) == 0x000020, "Member 'FProjectileParadoxData::Instigator' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, GhostParadox) == 0x000028, "Member 'FProjectileParadoxData::GhostParadox' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, bConfirmed) == 0x000030, "Member 'FProjectileParadoxData::bConfirmed' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, BulletIndex) == 0x000034, "Member 'FProjectileParadoxData::BulletIndex' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, PelletIndex) == 0x000038, "Member 'FProjectileParadoxData::PelletIndex' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, DefaultProjectile) == 0x000040, "Member 'FProjectileParadoxData::DefaultProjectile' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, ExplosionTimestamp) == 0x000048, "Member 'FProjectileParadoxData::ExplosionTimestamp' has a wrong offset!");
static_assert(offsetof(FProjectileParadoxData, ExplosionDuration) == 0x00004C, "Member 'FProjectileParadoxData::ExplosionDuration' has a wrong offset!");

// ScriptStruct TimeWatch.WeaponParadoxData
// 0x0010 (0x0010 - 0x0000)
struct FWeaponParadoxData final
{
public:
	TArray<struct FProjectileParadoxData>         ProjectilesParadoxData;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponParadoxData) == 0x000008, "Wrong alignment on FWeaponParadoxData");
static_assert(sizeof(FWeaponParadoxData) == 0x000010, "Wrong size on FWeaponParadoxData");
static_assert(offsetof(FWeaponParadoxData, ProjectilesParadoxData) == 0x000000, "Member 'FWeaponParadoxData::ProjectilesParadoxData' has a wrong offset!");

// ScriptStruct TimeWatch.FluxTimelineFirstLoopRecordedRecordData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FFluxTimelineFirstLoopRecordedRecordData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFluxTimelineFirstLoopRecordedRecordData) == 0x000004, "Wrong alignment on FFluxTimelineFirstLoopRecordedRecordData");
static_assert(sizeof(FFluxTimelineFirstLoopRecordedRecordData) == 0x00001C, "Wrong size on FFluxTimelineFirstLoopRecordedRecordData");

// ScriptStruct TimeWatch.PhysicsObjectData
// 0x0034 (0x0034 - 0x0000)
struct FPhysicsObjectData final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorLocation;                                     // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ActorRotation;                                     // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ActorVelocity;                                     // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicsObjectData) == 0x000004, "Wrong alignment on FPhysicsObjectData");
static_assert(sizeof(FPhysicsObjectData) == 0x000034, "Wrong size on FPhysicsObjectData");
static_assert(offsetof(FPhysicsObjectData, Timestamp) == 0x000000, "Member 'FPhysicsObjectData::Timestamp' has a wrong offset!");
static_assert(offsetof(FPhysicsObjectData, ActorLocation) == 0x000004, "Member 'FPhysicsObjectData::ActorLocation' has a wrong offset!");
static_assert(offsetof(FPhysicsObjectData, ActorRotation) == 0x000010, "Member 'FPhysicsObjectData::ActorRotation' has a wrong offset!");
static_assert(offsetof(FPhysicsObjectData, ActorVelocity) == 0x00001C, "Member 'FPhysicsObjectData::ActorVelocity' has a wrong offset!");
static_assert(offsetof(FPhysicsObjectData, AngularVelocity) == 0x000028, "Member 'FPhysicsObjectData::AngularVelocity' has a wrong offset!");

// ScriptStruct TimeWatch.HitData
// 0x0030 (0x0030 - 0x0000)
struct FHitData final
{
public:
	TSubclassOf<class AActor>                     InstigatorClass;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitData) == 0x000008, "Wrong alignment on FHitData");
static_assert(sizeof(FHitData) == 0x000030, "Wrong size on FHitData");
static_assert(offsetof(FHitData, InstigatorClass) == 0x000000, "Member 'FHitData::InstigatorClass' has a wrong offset!");

// ScriptStruct TimeWatch.RecordData
// 0x0058 (0x0058 - 0x0000)
struct FRecordData final
{
public:
	struct FPhysicsObjectData                     PhysicsObjectData;                                 // 0x0000(0x0034)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitData>                       HitsData;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSocketData>                    BoneSocketData;                                    // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecordData) == 0x000008, "Wrong alignment on FRecordData");
static_assert(sizeof(FRecordData) == 0x000058, "Wrong size on FRecordData");
static_assert(offsetof(FRecordData, PhysicsObjectData) == 0x000000, "Member 'FRecordData::PhysicsObjectData' has a wrong offset!");
static_assert(offsetof(FRecordData, HitsData) == 0x000038, "Member 'FRecordData::HitsData' has a wrong offset!");
static_assert(offsetof(FRecordData, BoneSocketData) == 0x000048, "Member 'FRecordData::BoneSocketData' has a wrong offset!");

// ScriptStruct TimeWatch.TWGameplayTargetDataFilterHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FTWGameplayTargetDataFilterHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTWGameplayTargetDataFilterHandle) == 0x000008, "Wrong alignment on FTWGameplayTargetDataFilterHandle");
static_assert(sizeof(FTWGameplayTargetDataFilterHandle) == 0x000010, "Wrong size on FTWGameplayTargetDataFilterHandle");

// ScriptStruct TimeWatch.TWAbilityCustomData_Vectors
// 0x0010 (0x0018 - 0x0008)
struct FTWAbilityCustomData_Vectors final : public FTWAbilityCustomDataBase
{
public:
	TArray<struct FVector>                        Vectors;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWAbilityCustomData_Vectors) == 0x000008, "Wrong alignment on FTWAbilityCustomData_Vectors");
static_assert(sizeof(FTWAbilityCustomData_Vectors) == 0x000018, "Wrong size on FTWAbilityCustomData_Vectors");
static_assert(offsetof(FTWAbilityCustomData_Vectors, Vectors) == 0x000008, "Member 'FTWAbilityCustomData_Vectors::Vectors' has a wrong offset!");

// ScriptStruct TimeWatch.PoseBoneInfo
// 0x0040 (0x0040 - 0x0000)
struct FPoseBoneInfo final
{
public:
	class FName                                   ParentBoneName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FollowBoneName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseBoneInfo) == 0x000010, "Wrong alignment on FPoseBoneInfo");
static_assert(sizeof(FPoseBoneInfo) == 0x000040, "Wrong size on FPoseBoneInfo");
static_assert(offsetof(FPoseBoneInfo, ParentBoneName) == 0x000000, "Member 'FPoseBoneInfo::ParentBoneName' has a wrong offset!");
static_assert(offsetof(FPoseBoneInfo, FollowBoneName) == 0x000008, "Member 'FPoseBoneInfo::FollowBoneName' has a wrong offset!");
static_assert(offsetof(FPoseBoneInfo, Offset) == 0x000010, "Member 'FPoseBoneInfo::Offset' has a wrong offset!");

// ScriptStruct TimeWatch.TextChatPlayerMessageHistory
// 0x0010 (0x0010 - 0x0000)
struct FTextChatPlayerMessageHistory final
{
public:
	TArray<float>                                 Messages;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextChatPlayerMessageHistory) == 0x000008, "Wrong alignment on FTextChatPlayerMessageHistory");
static_assert(sizeof(FTextChatPlayerMessageHistory) == 0x000010, "Wrong size on FTextChatPlayerMessageHistory");
static_assert(offsetof(FTextChatPlayerMessageHistory, Messages) == 0x000000, "Member 'FTextChatPlayerMessageHistory::Messages' has a wrong offset!");

// ScriptStruct TimeWatch.FriendData
// 0x0038 (0x0038 - 0x0000)
struct FFriendData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserName;                                          // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlaying;                                        // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x17];                                      // 0x0021(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFriendData) == 0x000008, "Wrong alignment on FFriendData");
static_assert(sizeof(FFriendData) == 0x000038, "Wrong size on FFriendData");
static_assert(offsetof(FFriendData, UserName) == 0x000010, "Member 'FFriendData::UserName' has a wrong offset!");
static_assert(offsetof(FFriendData, bIsPlaying) == 0x000020, "Member 'FFriendData::bIsPlaying' has a wrong offset!");

// ScriptStruct TimeWatch.VersusScreenDebug
// 0x0008 (0x0008 - 0x0000)
struct FVersusScreenDebug final
{
public:
	class UTWStylesDataAsset*                     DebugStyle;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVersusScreenDebug) == 0x000008, "Wrong alignment on FVersusScreenDebug");
static_assert(sizeof(FVersusScreenDebug) == 0x000008, "Wrong size on FVersusScreenDebug");
static_assert(offsetof(FVersusScreenDebug, DebugStyle) == 0x000000, "Member 'FVersusScreenDebug::DebugStyle' has a wrong offset!");

// ScriptStruct TimeWatch.MuzzleFlashPool
// 0x0020 (0x0020 - 0x0000)
struct FMuzzleFlashPool final
{
public:
	TSubclassOf<class ATemporalParticle>          MuzzleFlashParticleClass;                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATemporalParticle*>              ParticlesPool;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastUsedMuzzleFlashIndex;                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMuzzleFlashPool) == 0x000008, "Wrong alignment on FMuzzleFlashPool");
static_assert(sizeof(FMuzzleFlashPool) == 0x000020, "Wrong size on FMuzzleFlashPool");
static_assert(offsetof(FMuzzleFlashPool, MuzzleFlashParticleClass) == 0x000000, "Member 'FMuzzleFlashPool::MuzzleFlashParticleClass' has a wrong offset!");
static_assert(offsetof(FMuzzleFlashPool, ParticlesPool) == 0x000008, "Member 'FMuzzleFlashPool::ParticlesPool' has a wrong offset!");
static_assert(offsetof(FMuzzleFlashPool, LastUsedMuzzleFlashIndex) == 0x000018, "Member 'FMuzzleFlashPool::LastUsedMuzzleFlashIndex' has a wrong offset!");

// ScriptStruct TimeWatch.TWCharacterSounds
// 0x00B0 (0x00B0 - 0x0000)
struct FTWCharacterSounds final
{
public:
	struct FNGDSoundConfig                        SoundConfig_OnDamaged;                             // 0x0000(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        SoundConfig_OnDeath;                               // 0x0058(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWCharacterSounds) == 0x000008, "Wrong alignment on FTWCharacterSounds");
static_assert(sizeof(FTWCharacterSounds) == 0x0000B0, "Wrong size on FTWCharacterSounds");
static_assert(offsetof(FTWCharacterSounds, SoundConfig_OnDamaged) == 0x000000, "Member 'FTWCharacterSounds::SoundConfig_OnDamaged' has a wrong offset!");
static_assert(offsetof(FTWCharacterSounds, SoundConfig_OnDeath) == 0x000058, "Member 'FTWCharacterSounds::SoundConfig_OnDeath' has a wrong offset!");

// ScriptStruct TimeWatch.TWParticleCollection
// 0x0010 (0x0010 - 0x0000)
struct FTWParticleCollection final
{
public:
	TArray<class ATemporalParticle*>              Particles;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWParticleCollection) == 0x000008, "Wrong alignment on FTWParticleCollection");
static_assert(sizeof(FTWParticleCollection) == 0x000010, "Wrong size on FTWParticleCollection");
static_assert(offsetof(FTWParticleCollection, Particles) == 0x000000, "Member 'FTWParticleCollection::Particles' has a wrong offset!");

// ScriptStruct TimeWatch.TextChatMessage
// 0x0020 (0x0020 - 0x0000)
struct FTextChatMessage final
{
public:
	class APlayerState*                           Sender;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextMessage;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTextChatMessage) == 0x000008, "Wrong alignment on FTextChatMessage");
static_assert(sizeof(FTextChatMessage) == 0x000020, "Wrong size on FTextChatMessage");
static_assert(offsetof(FTextChatMessage, Sender) == 0x000000, "Member 'FTextChatMessage::Sender' has a wrong offset!");
static_assert(offsetof(FTextChatMessage, TextMessage) == 0x000008, "Member 'FTextChatMessage::TextMessage' has a wrong offset!");
static_assert(offsetof(FTextChatMessage, Timestamp) == 0x000018, "Member 'FTextChatMessage::Timestamp' has a wrong offset!");

// ScriptStruct TimeWatch.OverTimeDamageData
// 0x0010 (0x0010 - 0x0000)
struct FOverTimeDamageData final
{
public:
	class AActor*                                 DamageCauser;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverTimeDamageData) == 0x000008, "Wrong alignment on FOverTimeDamageData");
static_assert(sizeof(FOverTimeDamageData) == 0x000010, "Wrong size on FOverTimeDamageData");
static_assert(offsetof(FOverTimeDamageData, DamageCauser) == 0x000000, "Member 'FOverTimeDamageData::DamageCauser' has a wrong offset!");

// ScriptStruct TimeWatch.ProjectileHitRecord
// 0x0010 (0x0010 - 0x0000)
struct FProjectileHitRecord final
{
public:
	TWeakObjectPtr<class ATimeWatchCharacter>     Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBone;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileHitRecord) == 0x000004, "Wrong alignment on FProjectileHitRecord");
static_assert(sizeof(FProjectileHitRecord) == 0x000010, "Wrong size on FProjectileHitRecord");
static_assert(offsetof(FProjectileHitRecord, Target) == 0x000000, "Member 'FProjectileHitRecord::Target' has a wrong offset!");
static_assert(offsetof(FProjectileHitRecord, HitBone) == 0x000008, "Member 'FProjectileHitRecord::HitBone' has a wrong offset!");

// ScriptStruct TimeWatch.RoundEndEvaluation
// 0x000C (0x000C - 0x0000)
struct FRoundEndEvaluation final
{
public:
	int32                                         ScoringTeam;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreIncrement;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMatchEnd;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoundEndEvaluation) == 0x000004, "Wrong alignment on FRoundEndEvaluation");
static_assert(sizeof(FRoundEndEvaluation) == 0x00000C, "Wrong size on FRoundEndEvaluation");
static_assert(offsetof(FRoundEndEvaluation, ScoringTeam) == 0x000000, "Member 'FRoundEndEvaluation::ScoringTeam' has a wrong offset!");
static_assert(offsetof(FRoundEndEvaluation, ScoreIncrement) == 0x000004, "Member 'FRoundEndEvaluation::ScoreIncrement' has a wrong offset!");
static_assert(offsetof(FRoundEndEvaluation, bIsMatchEnd) == 0x000008, "Member 'FRoundEndEvaluation::bIsMatchEnd' has a wrong offset!");

// ScriptStruct TimeWatch.PlaybookData
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FPlaybookData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaybookData) == 0x000008, "Wrong alignment on FPlaybookData");
static_assert(sizeof(FPlaybookData) == 0x000030, "Wrong size on FPlaybookData");

// ScriptStruct TimeWatch.Score
// 0x0018 (0x0018 - 0x0000)
struct FScore final
{
public:
	TArray<int32>                                 TeamsScore;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastScoringTeamID;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScore) == 0x000008, "Wrong alignment on FScore");
static_assert(sizeof(FScore) == 0x000018, "Wrong size on FScore");
static_assert(offsetof(FScore, TeamsScore) == 0x000000, "Member 'FScore::TeamsScore' has a wrong offset!");
static_assert(offsetof(FScore, LastScoringTeamID) == 0x000010, "Member 'FScore::LastScoringTeamID' has a wrong offset!");

// ScriptStruct TimeWatch.ReversableSoundEvent
// 0x00A0 (0x00A0 - 0x0000)
struct FReversableSoundEvent final
{
public:
	struct FPostSoundParams                       PostSoundParams;                                   // 0x0000(0x0098)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReversableSoundEvent) == 0x000008, "Wrong alignment on FReversableSoundEvent");
static_assert(sizeof(FReversableSoundEvent) == 0x0000A0, "Wrong size on FReversableSoundEvent");
static_assert(offsetof(FReversableSoundEvent, PostSoundParams) == 0x000000, "Member 'FReversableSoundEvent::PostSoundParams' has a wrong offset!");

// ScriptStruct TimeWatch.RematchData
// 0x0003 (0x0003 - 0x0000)
struct FRematchData final
{
public:
	bool                                          bRematchVoided;                                    // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerWantsRematch;                               // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOtherWantsRematch;                                // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRematchData) == 0x000001, "Wrong alignment on FRematchData");
static_assert(sizeof(FRematchData) == 0x000003, "Wrong size on FRematchData");
static_assert(offsetof(FRematchData, bRematchVoided) == 0x000000, "Member 'FRematchData::bRematchVoided' has a wrong offset!");
static_assert(offsetof(FRematchData, bPlayerWantsRematch) == 0x000001, "Member 'FRematchData::bPlayerWantsRematch' has a wrong offset!");
static_assert(offsetof(FRematchData, bOtherWantsRematch) == 0x000002, "Member 'FRematchData::bOtherWantsRematch' has a wrong offset!");

// ScriptStruct TimeWatch.TWAbilityCustomData_TargetActors
// 0x0010 (0x0018 - 0x0008)
struct FTWAbilityCustomData_TargetActors final : public FTWAbilityCustomDataBase
{
public:
	TArray<class AActor*>                         Targets;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWAbilityCustomData_TargetActors) == 0x000008, "Wrong alignment on FTWAbilityCustomData_TargetActors");
static_assert(sizeof(FTWAbilityCustomData_TargetActors) == 0x000018, "Wrong size on FTWAbilityCustomData_TargetActors");
static_assert(offsetof(FTWAbilityCustomData_TargetActors, Targets) == 0x000008, "Member 'FTWAbilityCustomData_TargetActors::Targets' has a wrong offset!");

// ScriptStruct TimeWatch.TWAbilityCustomData_CastData
// 0x0028 (0x0030 - 0x0008)
struct FTWAbilityCustomData_CastData final : public FTWAbilityCustomDataBase
{
public:
	struct FTWAbilityExecutionData                ExecutionData;                                     // 0x0008(0x0028)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWAbilityCustomData_CastData) == 0x000008, "Wrong alignment on FTWAbilityCustomData_CastData");
static_assert(sizeof(FTWAbilityCustomData_CastData) == 0x000030, "Wrong size on FTWAbilityCustomData_CastData");
static_assert(offsetof(FTWAbilityCustomData_CastData, ExecutionData) == 0x000008, "Member 'FTWAbilityCustomData_CastData::ExecutionData' has a wrong offset!");

// ScriptStruct TimeWatch.TWAbilityData
// 0x0014 (0x0014 - 0x0000)
struct FTWAbilityData final
{
public:
	float                                         EnergyCost;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolDown;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRealTime;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateDataHandleOnServer;                         // 0x000D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestoreOnNonResetOvertime;                        // 0x000E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETWAbilityCastPolicy                          CastingPolicy;                                     // 0x000F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETWAbilityReExecutionPolicy                   ReExecutionPolicy;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETWAbilityInstancingPolicy                    InstancingPolicy;                                  // 0x0011(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETWAbilityNetExecutionPolicy                  NetworkExecutionPolicy;                            // 0x0012(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETWAbilityForwardEndPolicy                    ForwardEndPolicy;                                  // 0x0013(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWAbilityData) == 0x000004, "Wrong alignment on FTWAbilityData");
static_assert(sizeof(FTWAbilityData) == 0x000014, "Wrong size on FTWAbilityData");
static_assert(offsetof(FTWAbilityData, EnergyCost) == 0x000000, "Member 'FTWAbilityData::EnergyCost' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, Duration) == 0x000004, "Member 'FTWAbilityData::Duration' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, CoolDown) == 0x000008, "Member 'FTWAbilityData::CoolDown' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, bUseRealTime) == 0x00000C, "Member 'FTWAbilityData::bUseRealTime' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, bCreateDataHandleOnServer) == 0x00000D, "Member 'FTWAbilityData::bCreateDataHandleOnServer' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, bRestoreOnNonResetOvertime) == 0x00000E, "Member 'FTWAbilityData::bRestoreOnNonResetOvertime' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, CastingPolicy) == 0x00000F, "Member 'FTWAbilityData::CastingPolicy' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, ReExecutionPolicy) == 0x000010, "Member 'FTWAbilityData::ReExecutionPolicy' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, InstancingPolicy) == 0x000011, "Member 'FTWAbilityData::InstancingPolicy' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, NetworkExecutionPolicy) == 0x000012, "Member 'FTWAbilityData::NetworkExecutionPolicy' has a wrong offset!");
static_assert(offsetof(FTWAbilityData, ForwardEndPolicy) == 0x000013, "Member 'FTWAbilityData::ForwardEndPolicy' has a wrong offset!");

// ScriptStruct TimeWatch.TWChallengeEntryTypes
// 0x0028 (0x0028 - 0x0000)
struct FTWChallengeEntryTypes final
{
public:
	class FName                                   ChallengeName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeID;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ChallengeDescription;                              // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWChallengeEntryTypes) == 0x000008, "Wrong alignment on FTWChallengeEntryTypes");
static_assert(sizeof(FTWChallengeEntryTypes) == 0x000028, "Wrong size on FTWChallengeEntryTypes");
static_assert(offsetof(FTWChallengeEntryTypes, ChallengeName) == 0x000000, "Member 'FTWChallengeEntryTypes::ChallengeName' has a wrong offset!");
static_assert(offsetof(FTWChallengeEntryTypes, ChallengeID) == 0x000008, "Member 'FTWChallengeEntryTypes::ChallengeID' has a wrong offset!");
static_assert(offsetof(FTWChallengeEntryTypes, ChallengeDescription) == 0x000010, "Member 'FTWChallengeEntryTypes::ChallengeDescription' has a wrong offset!");

// ScriptStruct TimeWatch.TWChallengeEventInfo
// 0x0038 (0x0038 - 0x0000)
struct FTWChallengeEventInfo final
{
public:
	TArray<class UTWChallengeRuleData*>           Rules;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTWChallengeEntryTypes                 ChallengeInfo;                                     // 0x0010(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWChallengeEventInfo) == 0x000008, "Wrong alignment on FTWChallengeEventInfo");
static_assert(sizeof(FTWChallengeEventInfo) == 0x000038, "Wrong size on FTWChallengeEventInfo");
static_assert(offsetof(FTWChallengeEventInfo, Rules) == 0x000000, "Member 'FTWChallengeEventInfo::Rules' has a wrong offset!");
static_assert(offsetof(FTWChallengeEventInfo, ChallengeInfo) == 0x000010, "Member 'FTWChallengeEventInfo::ChallengeInfo' has a wrong offset!");

// ScriptStruct TimeWatch.PlayerIntroData
// 0x0028 (0x0028 - 0x0000)
struct FPlayerIntroData final
{
public:
	TSoftClassPtr<class UClass>                   PlayerIntroClass;                                  // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerIntroData) == 0x000008, "Wrong alignment on FPlayerIntroData");
static_assert(sizeof(FPlayerIntroData) == 0x000028, "Wrong size on FPlayerIntroData");
static_assert(offsetof(FPlayerIntroData, PlayerIntroClass) == 0x000000, "Member 'FPlayerIntroData::PlayerIntroClass' has a wrong offset!");

// ScriptStruct TimeWatch.TWCharacterEntry
// 0x0098 (0x0098 - 0x0000)
struct FTWCharacterEntry final
{
public:
	class FString                                 CharacterIdentifier;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CharacterName;                                     // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CharacterDescription;                              // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CharacterTag;                                      // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             UI_CustomizationScreenImage;                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UI_CustomizationScreenBGImage;                     // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             UI_CharacterSelectionImage;                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             UI_CharacterAvatar;                                // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWCharacterEntry) == 0x000008, "Wrong alignment on FTWCharacterEntry");
static_assert(sizeof(FTWCharacterEntry) == 0x000098, "Wrong size on FTWCharacterEntry");
static_assert(offsetof(FTWCharacterEntry, CharacterIdentifier) == 0x000000, "Member 'FTWCharacterEntry::CharacterIdentifier' has a wrong offset!");
static_assert(offsetof(FTWCharacterEntry, CharacterName) == 0x000010, "Member 'FTWCharacterEntry::CharacterName' has a wrong offset!");
static_assert(offsetof(FTWCharacterEntry, CharacterDescription) == 0x000028, "Member 'FTWCharacterEntry::CharacterDescription' has a wrong offset!");
static_assert(offsetof(FTWCharacterEntry, CharacterTag) == 0x000040, "Member 'FTWCharacterEntry::CharacterTag' has a wrong offset!");
static_assert(offsetof(FTWCharacterEntry, UI_CustomizationScreenImage) == 0x000058, "Member 'FTWCharacterEntry::UI_CustomizationScreenImage' has a wrong offset!");
static_assert(offsetof(FTWCharacterEntry, UI_CustomizationScreenBGImage) == 0x000060, "Member 'FTWCharacterEntry::UI_CustomizationScreenBGImage' has a wrong offset!");
static_assert(offsetof(FTWCharacterEntry, UI_CharacterSelectionImage) == 0x000088, "Member 'FTWCharacterEntry::UI_CharacterSelectionImage' has a wrong offset!");
static_assert(offsetof(FTWCharacterEntry, UI_CharacterAvatar) == 0x000090, "Member 'FTWCharacterEntry::UI_CharacterAvatar' has a wrong offset!");

// ScriptStruct TimeWatch.CloneTimelineData
// 0x0028 (0x0028 - 0x0000)
struct FCloneTimelineData final
{
public:
	float                                         TimelineValue;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathTimelineValue;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackgroundTimelineValue;                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DeathIconValue;                                    // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloneTimelineData) == 0x000008, "Wrong alignment on FCloneTimelineData");
static_assert(sizeof(FCloneTimelineData) == 0x000028, "Wrong size on FCloneTimelineData");
static_assert(offsetof(FCloneTimelineData, TimelineValue) == 0x000000, "Member 'FCloneTimelineData::TimelineValue' has a wrong offset!");
static_assert(offsetof(FCloneTimelineData, DeathTimelineValue) == 0x000004, "Member 'FCloneTimelineData::DeathTimelineValue' has a wrong offset!");
static_assert(offsetof(FCloneTimelineData, BackgroundTimelineValue) == 0x000008, "Member 'FCloneTimelineData::BackgroundTimelineValue' has a wrong offset!");
static_assert(offsetof(FCloneTimelineData, DeathIconValue) == 0x000010, "Member 'FCloneTimelineData::DeathIconValue' has a wrong offset!");

// ScriptStruct TimeWatch.HitFeedback
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FHitFeedback final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitFeedback) == 0x000004, "Wrong alignment on FHitFeedback");
static_assert(sizeof(FHitFeedback) == 0x00001C, "Wrong size on FHitFeedback");

// ScriptStruct TimeWatch.RadialFeedback
// 0x0050 (0x0050 - 0x0000)
struct FRadialFeedback final
{
public:
	EFeedbackType                                 Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxFeedbacks;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeedbackDuration;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceLimit;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AlphaCurve;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ScaleCurve;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidget>                    WidgetClass;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        Widgets;                                           // 0x0030(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHitFeedback>                   FeedbackQueue;                                     // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadialFeedback) == 0x000008, "Wrong alignment on FRadialFeedback");
static_assert(sizeof(FRadialFeedback) == 0x000050, "Wrong size on FRadialFeedback");
static_assert(offsetof(FRadialFeedback, Type) == 0x000000, "Member 'FRadialFeedback::Type' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, MaxFeedbacks) == 0x000004, "Member 'FRadialFeedback::MaxFeedbacks' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, FeedbackDuration) == 0x000008, "Member 'FRadialFeedback::FeedbackDuration' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, DistanceLimit) == 0x00000C, "Member 'FRadialFeedback::DistanceLimit' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, ScaleMultiplier) == 0x000010, "Member 'FRadialFeedback::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, AlphaCurve) == 0x000018, "Member 'FRadialFeedback::AlphaCurve' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, ScaleCurve) == 0x000020, "Member 'FRadialFeedback::ScaleCurve' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, WidgetClass) == 0x000028, "Member 'FRadialFeedback::WidgetClass' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, Widgets) == 0x000030, "Member 'FRadialFeedback::Widgets' has a wrong offset!");
static_assert(offsetof(FRadialFeedback, FeedbackQueue) == 0x000040, "Member 'FRadialFeedback::FeedbackQueue' has a wrong offset!");

// ScriptStruct TimeWatch.WidgetColorStructure
// 0x00C0 (0x00C0 - 0x0000)
struct FWidgetColorStructure final
{
public:
	struct FLinearColor                           TopColor;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SecondaryTopColor;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ActiveBackgroundColor;                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CloneBackgroundColor;                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HitFeedbackColor;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ActiveTextColor;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CloneTextColor;                                    // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PlayerNameTextColor;                               // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LowLevelProgressColor;                             // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           StandardProgressColor;                             // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverheadBackgroundColor;                           // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetColorStructure) == 0x000004, "Wrong alignment on FWidgetColorStructure");
static_assert(sizeof(FWidgetColorStructure) == 0x0000C0, "Wrong size on FWidgetColorStructure");
static_assert(offsetof(FWidgetColorStructure, TopColor) == 0x000000, "Member 'FWidgetColorStructure::TopColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, SecondaryTopColor) == 0x000010, "Member 'FWidgetColorStructure::SecondaryTopColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, BackgroundColor) == 0x000020, "Member 'FWidgetColorStructure::BackgroundColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, ActiveBackgroundColor) == 0x000030, "Member 'FWidgetColorStructure::ActiveBackgroundColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, CloneBackgroundColor) == 0x000040, "Member 'FWidgetColorStructure::CloneBackgroundColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, HitFeedbackColor) == 0x000050, "Member 'FWidgetColorStructure::HitFeedbackColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, ActiveTextColor) == 0x000060, "Member 'FWidgetColorStructure::ActiveTextColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, CloneTextColor) == 0x000070, "Member 'FWidgetColorStructure::CloneTextColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, PlayerNameTextColor) == 0x000080, "Member 'FWidgetColorStructure::PlayerNameTextColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, LowLevelProgressColor) == 0x000090, "Member 'FWidgetColorStructure::LowLevelProgressColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, StandardProgressColor) == 0x0000A0, "Member 'FWidgetColorStructure::StandardProgressColor' has a wrong offset!");
static_assert(offsetof(FWidgetColorStructure, OverheadBackgroundColor) == 0x0000B0, "Member 'FWidgetColorStructure::OverheadBackgroundColor' has a wrong offset!");

// ScriptStruct TimeWatch.CloneInfoColors
// 0x0010 (0x0010 - 0x0000)
struct FCloneInfoColors final
{
public:
	TArray<struct FWidgetColorStructure>          TeamsColors_HUD;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloneInfoColors) == 0x000008, "Wrong alignment on FCloneInfoColors");
static_assert(sizeof(FCloneInfoColors) == 0x000010, "Wrong size on FCloneInfoColors");
static_assert(offsetof(FCloneInfoColors, TeamsColors_HUD) == 0x000000, "Member 'FCloneInfoColors::TeamsColors_HUD' has a wrong offset!");

// ScriptStruct TimeWatch.SpectatorColors
// 0x0038 (0x0038 - 0x0000)
struct FSpectatorColors final
{
public:
	struct FTeamColorConfig                       TeamsBannersColors;                                // 0x0000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           NeutralBannerColor;                                // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpectatorColors) == 0x000008, "Wrong alignment on FSpectatorColors");
static_assert(sizeof(FSpectatorColors) == 0x000038, "Wrong size on FSpectatorColors");
static_assert(offsetof(FSpectatorColors, TeamsBannersColors) == 0x000000, "Member 'FSpectatorColors::TeamsBannersColors' has a wrong offset!");
static_assert(offsetof(FSpectatorColors, NeutralBannerColor) == 0x000028, "Member 'FSpectatorColors::NeutralBannerColor' has a wrong offset!");

// ScriptStruct TimeWatch.LoopIndicatorColors
// 0x0048 (0x0048 - 0x0000)
struct FLoopIndicatorColors final
{
public:
	struct FLinearColor                           Undisputed;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Contested;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       TeamsColors;                                       // 0x0020(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoopIndicatorColors) == 0x000008, "Wrong alignment on FLoopIndicatorColors");
static_assert(sizeof(FLoopIndicatorColors) == 0x000048, "Wrong size on FLoopIndicatorColors");
static_assert(offsetof(FLoopIndicatorColors, Undisputed) == 0x000000, "Member 'FLoopIndicatorColors::Undisputed' has a wrong offset!");
static_assert(offsetof(FLoopIndicatorColors, Contested) == 0x000010, "Member 'FLoopIndicatorColors::Contested' has a wrong offset!");
static_assert(offsetof(FLoopIndicatorColors, TeamsColors) == 0x000020, "Member 'FLoopIndicatorColors::TeamsColors' has a wrong offset!");

// ScriptStruct TimeWatch.TimelineColors
// 0x0050 (0x0050 - 0x0000)
struct FTimelineColors final
{
public:
	struct FTeamColorConfig                       TeamAdvantageTopColor;                             // 0x0000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       TeamAdvantageSecondaryColor;                       // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimelineColors) == 0x000008, "Wrong alignment on FTimelineColors");
static_assert(sizeof(FTimelineColors) == 0x000050, "Wrong size on FTimelineColors");
static_assert(offsetof(FTimelineColors, TeamAdvantageTopColor) == 0x000000, "Member 'FTimelineColors::TeamAdvantageTopColor' has a wrong offset!");
static_assert(offsetof(FTimelineColors, TeamAdvantageSecondaryColor) == 0x000028, "Member 'FTimelineColors::TeamAdvantageSecondaryColor' has a wrong offset!");

// ScriptStruct TimeWatch.HUDColors
// 0x00E8 (0x00E8 - 0x0000)
struct FHUDColors final
{
public:
	struct FLoopIndicatorColors                   CaptureCompass;                                    // 0x0000(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScoreBoardColors                      ScoreBoard;                                        // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTimelineColors                        TimelineColors;                                    // 0x0098(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHUDColors) == 0x000008, "Wrong alignment on FHUDColors");
static_assert(sizeof(FHUDColors) == 0x0000E8, "Wrong size on FHUDColors");
static_assert(offsetof(FHUDColors, CaptureCompass) == 0x000000, "Member 'FHUDColors::CaptureCompass' has a wrong offset!");
static_assert(offsetof(FHUDColors, ScoreBoard) == 0x000048, "Member 'FHUDColors::ScoreBoard' has a wrong offset!");
static_assert(offsetof(FHUDColors, TimelineColors) == 0x000098, "Member 'FHUDColors::TimelineColors' has a wrong offset!");

// ScriptStruct TimeWatch.GameplayActorsColors
// 0x0258 (0x0258 - 0x0000)
struct FGameplayActorsColors final
{
public:
	struct FTeamColorConfig                       Trails_TeamsColors;                                // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       Projectile_TeamsColors;                            // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       Particles_TeamsColors;                             // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       Impacts_TeamsColors;                               // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       Outlines_TeamsColors;                              // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       TimeGhost_TeamColors;                              // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       TrailActive_TeamsColors;                           // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       TrailOld_TeamsColors;                              // 0x0118(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       PlaybookDeaths_TeamsColors;                        // 0x0140(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       PlaybookRevive_TeamsColors;                        // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       PlaybookContinuePositions_TeamsColors;             // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       ParadoxGhost_TeamsColors;                          // 0x01B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       ParadoxExplosionTopColor_TeamsColors;              // 0x01E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       ParadoxExplosionBottomColor_TeamsColors;           // 0x0208(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamColorConfig                       Ping_TeamsColors;                                  // 0x0230(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayActorsColors) == 0x000008, "Wrong alignment on FGameplayActorsColors");
static_assert(sizeof(FGameplayActorsColors) == 0x000258, "Wrong size on FGameplayActorsColors");
static_assert(offsetof(FGameplayActorsColors, Trails_TeamsColors) == 0x000000, "Member 'FGameplayActorsColors::Trails_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, Projectile_TeamsColors) == 0x000028, "Member 'FGameplayActorsColors::Projectile_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, Particles_TeamsColors) == 0x000050, "Member 'FGameplayActorsColors::Particles_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, Impacts_TeamsColors) == 0x000078, "Member 'FGameplayActorsColors::Impacts_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, Outlines_TeamsColors) == 0x0000A0, "Member 'FGameplayActorsColors::Outlines_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, TimeGhost_TeamColors) == 0x0000C8, "Member 'FGameplayActorsColors::TimeGhost_TeamColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, TrailActive_TeamsColors) == 0x0000F0, "Member 'FGameplayActorsColors::TrailActive_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, TrailOld_TeamsColors) == 0x000118, "Member 'FGameplayActorsColors::TrailOld_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, PlaybookDeaths_TeamsColors) == 0x000140, "Member 'FGameplayActorsColors::PlaybookDeaths_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, PlaybookRevive_TeamsColors) == 0x000168, "Member 'FGameplayActorsColors::PlaybookRevive_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, PlaybookContinuePositions_TeamsColors) == 0x000190, "Member 'FGameplayActorsColors::PlaybookContinuePositions_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, ParadoxGhost_TeamsColors) == 0x0001B8, "Member 'FGameplayActorsColors::ParadoxGhost_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, ParadoxExplosionTopColor_TeamsColors) == 0x0001E0, "Member 'FGameplayActorsColors::ParadoxExplosionTopColor_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, ParadoxExplosionBottomColor_TeamsColors) == 0x000208, "Member 'FGameplayActorsColors::ParadoxExplosionBottomColor_TeamsColors' has a wrong offset!");
static_assert(offsetof(FGameplayActorsColors, Ping_TeamsColors) == 0x000230, "Member 'FGameplayActorsColors::Ping_TeamsColors' has a wrong offset!");

// ScriptStruct TimeWatch.MPC_FloatParameter
// 0x000C (0x000C - 0x0000)
struct FMPC_FloatParameter final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMPC_FloatParameter) == 0x000004, "Wrong alignment on FMPC_FloatParameter");
static_assert(sizeof(FMPC_FloatParameter) == 0x00000C, "Wrong size on FMPC_FloatParameter");
static_assert(offsetof(FMPC_FloatParameter, Name) == 0x000000, "Member 'FMPC_FloatParameter::Name' has a wrong offset!");
static_assert(offsetof(FMPC_FloatParameter, Value) == 0x000008, "Member 'FMPC_FloatParameter::Value' has a wrong offset!");

// ScriptStruct TimeWatch.MPC_VectorParameter
// 0x0018 (0x0018 - 0x0000)
struct FMPC_VectorParameter final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMPC_VectorParameter) == 0x000004, "Wrong alignment on FMPC_VectorParameter");
static_assert(sizeof(FMPC_VectorParameter) == 0x000018, "Wrong size on FMPC_VectorParameter");
static_assert(offsetof(FMPC_VectorParameter, Name) == 0x000000, "Member 'FMPC_VectorParameter::Name' has a wrong offset!");
static_assert(offsetof(FMPC_VectorParameter, Value) == 0x000008, "Member 'FMPC_VectorParameter::Value' has a wrong offset!");

// ScriptStruct TimeWatch.MPC_Colors
// 0x0028 (0x0028 - 0x0000)
struct FMPC_Colors final
{
public:
	class UMaterialParameterCollection*           MPC;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMPC_FloatParameter>            FloatParameters;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMPC_VectorParameter>           VectorParameters;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMPC_Colors) == 0x000008, "Wrong alignment on FMPC_Colors");
static_assert(sizeof(FMPC_Colors) == 0x000028, "Wrong size on FMPC_Colors");
static_assert(offsetof(FMPC_Colors, MPC) == 0x000000, "Member 'FMPC_Colors::MPC' has a wrong offset!");
static_assert(offsetof(FMPC_Colors, FloatParameters) == 0x000008, "Member 'FMPC_Colors::FloatParameters' has a wrong offset!");
static_assert(offsetof(FMPC_Colors, VectorParameters) == 0x000018, "Member 'FMPC_Colors::VectorParameters' has a wrong offset!");

// ScriptStruct TimeWatch.CrosshairHitColors
// 0x0040 (0x0040 - 0x0000)
struct FCrosshairHitColors final
{
public:
	struct FLinearColor                           NormalHit;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CriticalHit;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AllyHit;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DeadHit;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrosshairHitColors) == 0x000004, "Wrong alignment on FCrosshairHitColors");
static_assert(sizeof(FCrosshairHitColors) == 0x000040, "Wrong size on FCrosshairHitColors");
static_assert(offsetof(FCrosshairHitColors, NormalHit) == 0x000000, "Member 'FCrosshairHitColors::NormalHit' has a wrong offset!");
static_assert(offsetof(FCrosshairHitColors, CriticalHit) == 0x000010, "Member 'FCrosshairHitColors::CriticalHit' has a wrong offset!");
static_assert(offsetof(FCrosshairHitColors, AllyHit) == 0x000020, "Member 'FCrosshairHitColors::AllyHit' has a wrong offset!");
static_assert(offsetof(FCrosshairHitColors, DeadHit) == 0x000030, "Member 'FCrosshairHitColors::DeadHit' has a wrong offset!");

// ScriptStruct TimeWatch.GameplayColorScheme
// 0x0428 (0x0428 - 0x0000)
struct FGameplayColorScheme final
{
public:
	struct FCloneInfoColors                       CloneInfo;                                         // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSpectatorColors                       Spectator;                                         // 0x0010(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHUDColors                             HUD;                                               // 0x0048(0x00E8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayActorsColors                  GameplayActors;                                    // 0x0130(0x0258)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMPC_Colors>                    MPC_Defaults;                                      // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCrosshairHitColors                    CrosshairHitColors;                                // 0x0398(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FLinearColor>              CrosshairColorsMap;                                // 0x03D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayColorScheme) == 0x000008, "Wrong alignment on FGameplayColorScheme");
static_assert(sizeof(FGameplayColorScheme) == 0x000428, "Wrong size on FGameplayColorScheme");
static_assert(offsetof(FGameplayColorScheme, CloneInfo) == 0x000000, "Member 'FGameplayColorScheme::CloneInfo' has a wrong offset!");
static_assert(offsetof(FGameplayColorScheme, Spectator) == 0x000010, "Member 'FGameplayColorScheme::Spectator' has a wrong offset!");
static_assert(offsetof(FGameplayColorScheme, HUD) == 0x000048, "Member 'FGameplayColorScheme::HUD' has a wrong offset!");
static_assert(offsetof(FGameplayColorScheme, GameplayActors) == 0x000130, "Member 'FGameplayColorScheme::GameplayActors' has a wrong offset!");
static_assert(offsetof(FGameplayColorScheme, MPC_Defaults) == 0x000388, "Member 'FGameplayColorScheme::MPC_Defaults' has a wrong offset!");
static_assert(offsetof(FGameplayColorScheme, CrosshairHitColors) == 0x000398, "Member 'FGameplayColorScheme::CrosshairHitColors' has a wrong offset!");
static_assert(offsetof(FGameplayColorScheme, CrosshairColorsMap) == 0x0003D8, "Member 'FGameplayColorScheme::CrosshairColorsMap' has a wrong offset!");

// ScriptStruct TimeWatch.MeshAssetData
// 0x0018 (0x0018 - 0x0000)
struct FMeshAssetData final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0008(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeshAssetData) == 0x000008, "Wrong alignment on FMeshAssetData");
static_assert(sizeof(FMeshAssetData) == 0x000018, "Wrong size on FMeshAssetData");
static_assert(offsetof(FMeshAssetData, Mesh) == 0x000000, "Member 'FMeshAssetData::Mesh' has a wrong offset!");
static_assert(offsetof(FMeshAssetData, RelativeScale) == 0x000008, "Member 'FMeshAssetData::RelativeScale' has a wrong offset!");

// ScriptStruct TimeWatch.CloneStatusColors
// 0x0028 (0x0028 - 0x0000)
struct FCloneStatusColors final
{
public:
	struct FTeamColorConfig                       TeamsColors;                                       // 0x0000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloneStatusColors) == 0x000008, "Wrong alignment on FCloneStatusColors");
static_assert(sizeof(FCloneStatusColors) == 0x000028, "Wrong size on FCloneStatusColors");
static_assert(offsetof(FCloneStatusColors, TeamsColors) == 0x000000, "Member 'FCloneStatusColors::TeamsColors' has a wrong offset!");

// ScriptStruct TimeWatch.AnnouncerEvent
// 0x0078 (0x0078 - 0x0000)
struct FAnnouncerEvent final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimeWatchEvent*                        Event;                                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnnouncerEvent) == 0x000008, "Wrong alignment on FAnnouncerEvent");
static_assert(sizeof(FAnnouncerEvent) == 0x000078, "Wrong size on FAnnouncerEvent");
static_assert(offsetof(FAnnouncerEvent, Event) == 0x000068, "Member 'FAnnouncerEvent::Event' has a wrong offset!");

// ScriptStruct TimeWatch.TWRewardConfig
// 0x0098 (0x0098 - 0x0000)
struct FTWRewardConfig final
{
public:
	TSoftObjectPtr<class UTexture2D>              RewardIcon;                                        // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     RewardMaterial;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RewardDisplayName;                                 // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, ENGDBackendItemRarity>            RewardRarities;                                    // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWRewardConfig) == 0x000008, "Wrong alignment on FTWRewardConfig");
static_assert(sizeof(FTWRewardConfig) == 0x000098, "Wrong size on FTWRewardConfig");
static_assert(offsetof(FTWRewardConfig, RewardIcon) == 0x000000, "Member 'FTWRewardConfig::RewardIcon' has a wrong offset!");
static_assert(offsetof(FTWRewardConfig, RewardMaterial) == 0x000028, "Member 'FTWRewardConfig::RewardMaterial' has a wrong offset!");
static_assert(offsetof(FTWRewardConfig, RewardDisplayName) == 0x000030, "Member 'FTWRewardConfig::RewardDisplayName' has a wrong offset!");
static_assert(offsetof(FTWRewardConfig, RewardRarities) == 0x000048, "Member 'FTWRewardConfig::RewardRarities' has a wrong offset!");

// ScriptStruct TimeWatch.BaseEventSettings
// 0x0060 (0x0060 - 0x0000)
struct FBaseEventSettings final
{
public:
	uint8                                         Priority;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolDown;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAnnouncerEventTypes, class UAkAudioEvent*> SoundsEvents;                                   // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseEventSettings) == 0x000008, "Wrong alignment on FBaseEventSettings");
static_assert(sizeof(FBaseEventSettings) == 0x000060, "Wrong size on FBaseEventSettings");
static_assert(offsetof(FBaseEventSettings, Priority) == 0x000000, "Member 'FBaseEventSettings::Priority' has a wrong offset!");
static_assert(offsetof(FBaseEventSettings, CoolDown) == 0x000004, "Member 'FBaseEventSettings::CoolDown' has a wrong offset!");
static_assert(offsetof(FBaseEventSettings, LifeSpan) == 0x000008, "Member 'FBaseEventSettings::LifeSpan' has a wrong offset!");
static_assert(offsetof(FBaseEventSettings, SoundsEvents) == 0x000010, "Member 'FBaseEventSettings::SoundsEvents' has a wrong offset!");

// ScriptStruct TimeWatch.TWRewardRarityConfig
// 0x0078 (0x0078 - 0x0000)
struct FTWRewardRarityConfig final
{
public:
	class FText                                   RarityDisplayName;                                 // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 RarityRichTextTag;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RarityTextColor;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundTopColor;                                // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundBottomColor;                             // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StoreHoveredBackgroundBig;                         // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StoreHoveredBackgroundSmall;                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StoreUnhoveredBackgroundBig;                       // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StoreUnhoveredBackgroundSmall;                     // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWRewardRarityConfig) == 0x000008, "Wrong alignment on FTWRewardRarityConfig");
static_assert(sizeof(FTWRewardRarityConfig) == 0x000078, "Wrong size on FTWRewardRarityConfig");
static_assert(offsetof(FTWRewardRarityConfig, RarityDisplayName) == 0x000000, "Member 'FTWRewardRarityConfig::RarityDisplayName' has a wrong offset!");
static_assert(offsetof(FTWRewardRarityConfig, RarityRichTextTag) == 0x000018, "Member 'FTWRewardRarityConfig::RarityRichTextTag' has a wrong offset!");
static_assert(offsetof(FTWRewardRarityConfig, RarityTextColor) == 0x000028, "Member 'FTWRewardRarityConfig::RarityTextColor' has a wrong offset!");
static_assert(offsetof(FTWRewardRarityConfig, BackgroundTopColor) == 0x000038, "Member 'FTWRewardRarityConfig::BackgroundTopColor' has a wrong offset!");
static_assert(offsetof(FTWRewardRarityConfig, BackgroundBottomColor) == 0x000048, "Member 'FTWRewardRarityConfig::BackgroundBottomColor' has a wrong offset!");
static_assert(offsetof(FTWRewardRarityConfig, StoreHoveredBackgroundBig) == 0x000058, "Member 'FTWRewardRarityConfig::StoreHoveredBackgroundBig' has a wrong offset!");
static_assert(offsetof(FTWRewardRarityConfig, StoreHoveredBackgroundSmall) == 0x000060, "Member 'FTWRewardRarityConfig::StoreHoveredBackgroundSmall' has a wrong offset!");
static_assert(offsetof(FTWRewardRarityConfig, StoreUnhoveredBackgroundBig) == 0x000068, "Member 'FTWRewardRarityConfig::StoreUnhoveredBackgroundBig' has a wrong offset!");
static_assert(offsetof(FTWRewardRarityConfig, StoreUnhoveredBackgroundSmall) == 0x000070, "Member 'FTWRewardRarityConfig::StoreUnhoveredBackgroundSmall' has a wrong offset!");

// ScriptStruct TimeWatch.TWEventGameData
// 0x0008 (0x0008 - 0x0000)
struct FTWEventGameData final
{
public:
	int32                                         Points;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyGained;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWEventGameData) == 0x000004, "Wrong alignment on FTWEventGameData");
static_assert(sizeof(FTWEventGameData) == 0x000008, "Wrong size on FTWEventGameData");
static_assert(offsetof(FTWEventGameData, Points) == 0x000000, "Member 'FTWEventGameData::Points' has a wrong offset!");
static_assert(offsetof(FTWEventGameData, EnergyGained) == 0x000004, "Member 'FTWEventGameData::EnergyGained' has a wrong offset!");

// ScriptStruct TimeWatch.EventReplicationData
// 0x0010 (0x0010 - 0x0000)
struct FEventReplicationData final
{
public:
	class UObject*                                Outer;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimeWatchEvent*                        TWEvent;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventReplicationData) == 0x000008, "Wrong alignment on FEventReplicationData");
static_assert(sizeof(FEventReplicationData) == 0x000010, "Wrong size on FEventReplicationData");
static_assert(offsetof(FEventReplicationData, Outer) == 0x000000, "Member 'FEventReplicationData::Outer' has a wrong offset!");
static_assert(offsetof(FEventReplicationData, TWEvent) == 0x000008, "Member 'FEventReplicationData::TWEvent' has a wrong offset!");

// ScriptStruct TimeWatch.AbilityCastTimestamp
// 0x0050 (0x0050 - 0x0000)
struct FAbilityCastTimestamp final
{
public:
	TMap<TSubclassOf<class UTWAbility>, float>    AbilityTimestamp;                                  // 0x0000(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityCastTimestamp) == 0x000008, "Wrong alignment on FAbilityCastTimestamp");
static_assert(sizeof(FAbilityCastTimestamp) == 0x000050, "Wrong size on FAbilityCastTimestamp");
static_assert(offsetof(FAbilityCastTimestamp, AbilityTimestamp) == 0x000000, "Member 'FAbilityCastTimestamp::AbilityTimestamp' has a wrong offset!");

// ScriptStruct TimeWatch.TWGameplayActorReplicationData
// 0x0018 (0x0018 - 0x0000)
struct FTWGameplayActorReplicationData final
{
public:
	float                                         CreationTime;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestructionTime;                                   // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_RoundIndex;                               // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ChildActor;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWGameplayActorReplicationData) == 0x000008, "Wrong alignment on FTWGameplayActorReplicationData");
static_assert(sizeof(FTWGameplayActorReplicationData) == 0x000018, "Wrong size on FTWGameplayActorReplicationData");
static_assert(offsetof(FTWGameplayActorReplicationData, CreationTime) == 0x000000, "Member 'FTWGameplayActorReplicationData::CreationTime' has a wrong offset!");
static_assert(offsetof(FTWGameplayActorReplicationData, DestructionTime) == 0x000004, "Member 'FTWGameplayActorReplicationData::DestructionTime' has a wrong offset!");
static_assert(offsetof(FTWGameplayActorReplicationData, Creation_RoundIndex) == 0x000008, "Member 'FTWGameplayActorReplicationData::Creation_RoundIndex' has a wrong offset!");
static_assert(offsetof(FTWGameplayActorReplicationData, ChildActor) == 0x000010, "Member 'FTWGameplayActorReplicationData::ChildActor' has a wrong offset!");

// ScriptStruct TimeWatch.ReverseSoundConfig
// 0x0004 (0x0004 - 0x0000)
struct FReverseSoundConfig final
{
public:
	float                                         RewindLength;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReverseSoundConfig) == 0x000004, "Wrong alignment on FReverseSoundConfig");
static_assert(sizeof(FReverseSoundConfig) == 0x000004, "Wrong size on FReverseSoundConfig");
static_assert(offsetof(FReverseSoundConfig, RewindLength) == 0x000000, "Member 'FReverseSoundConfig::RewindLength' has a wrong offset!");

// ScriptStruct TimeWatch.WaypointData
// 0x0010 (0x0010 - 0x0000)
struct FWaypointData final
{
public:
	class AActor*                                 Waypoint_Actor;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Waypoint_WaitTime;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaypointData) == 0x000008, "Wrong alignment on FWaypointData");
static_assert(sizeof(FWaypointData) == 0x000010, "Wrong size on FWaypointData");
static_assert(offsetof(FWaypointData, Waypoint_Actor) == 0x000000, "Member 'FWaypointData::Waypoint_Actor' has a wrong offset!");
static_assert(offsetof(FWaypointData, Waypoint_WaitTime) == 0x000008, "Member 'FWaypointData::Waypoint_WaitTime' has a wrong offset!");

// ScriptStruct TimeWatch.WaypointPathData
// 0x0018 (0x0018 - 0x0000)
struct FWaypointPathData final
{
public:
	TArray<struct FWaypointData>                  Waypoints;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLoopPath;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaypointPathData) == 0x000008, "Wrong alignment on FWaypointPathData");
static_assert(sizeof(FWaypointPathData) == 0x000018, "Wrong size on FWaypointPathData");
static_assert(offsetof(FWaypointPathData, Waypoints) == 0x000000, "Member 'FWaypointPathData::Waypoints' has a wrong offset!");
static_assert(offsetof(FWaypointPathData, bLoopPath) == 0x000010, "Member 'FWaypointPathData::bLoopPath' has a wrong offset!");

// ScriptStruct TimeWatch.CloneWaypointPathData
// 0x0050 (0x0050 - 0x0000)
struct FCloneWaypointPathData final
{
public:
	TMap<int32, struct FWaypointPathData>         CloneWaypointData;                                 // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloneWaypointPathData) == 0x000008, "Wrong alignment on FCloneWaypointPathData");
static_assert(sizeof(FCloneWaypointPathData) == 0x000050, "Wrong size on FCloneWaypointPathData");
static_assert(offsetof(FCloneWaypointPathData, CloneWaypointData) == 0x000000, "Member 'FCloneWaypointPathData::CloneWaypointData' has a wrong offset!");

// ScriptStruct TimeWatch.GameModeData
// 0x0020 (0x0020 - 0x0000)
struct FGameModeData final
{
public:
	class FText                                   ObjectiveDescription;                              // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UNGDHUDState>               ReplayHUDState;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameModeData) == 0x000008, "Wrong alignment on FGameModeData");
static_assert(sizeof(FGameModeData) == 0x000020, "Wrong size on FGameModeData");
static_assert(offsetof(FGameModeData, ObjectiveDescription) == 0x000000, "Member 'FGameModeData::ObjectiveDescription' has a wrong offset!");
static_assert(offsetof(FGameModeData, ReplayHUDState) == 0x000018, "Member 'FGameModeData::ReplayHUDState' has a wrong offset!");

// ScriptStruct TimeWatch.ReplayMatchResultData
// 0x0001 (0x0001 - 0x0000)
struct FReplayMatchResultData final
{
public:
	bool                                          RecordingPlayerWon;                                // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplayMatchResultData) == 0x000001, "Wrong alignment on FReplayMatchResultData");
static_assert(sizeof(FReplayMatchResultData) == 0x000001, "Wrong size on FReplayMatchResultData");
static_assert(offsetof(FReplayMatchResultData, RecordingPlayerWon) == 0x000000, "Member 'FReplayMatchResultData::RecordingPlayerWon' has a wrong offset!");

// ScriptStruct TimeWatch.PointData
// 0x0020 (0x0020 - 0x0000)
struct FPointData final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlive;                                          // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPointData) == 0x000004, "Wrong alignment on FPointData");
static_assert(sizeof(FPointData) == 0x000020, "Wrong size on FPointData");
static_assert(offsetof(FPointData, Timestamp) == 0x000000, "Member 'FPointData::Timestamp' has a wrong offset!");
static_assert(offsetof(FPointData, Location) == 0x000004, "Member 'FPointData::Location' has a wrong offset!");
static_assert(offsetof(FPointData, Velocity) == 0x000010, "Member 'FPointData::Velocity' has a wrong offset!");
static_assert(offsetof(FPointData, bIsAlive) == 0x00001C, "Member 'FPointData::bIsAlive' has a wrong offset!");

// ScriptStruct TimeWatch.ReplayMatchData
// 0x0038 (0x0038 - 0x0000)
struct FReplayMatchData final
{
public:
	struct FDateTime                              Date;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GamemodeFriendlyName;                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapFriendlyName;                                   // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PlayerNames;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplayMatchData) == 0x000008, "Wrong alignment on FReplayMatchData");
static_assert(sizeof(FReplayMatchData) == 0x000038, "Wrong size on FReplayMatchData");
static_assert(offsetof(FReplayMatchData, Date) == 0x000000, "Member 'FReplayMatchData::Date' has a wrong offset!");
static_assert(offsetof(FReplayMatchData, GamemodeFriendlyName) == 0x000008, "Member 'FReplayMatchData::GamemodeFriendlyName' has a wrong offset!");
static_assert(offsetof(FReplayMatchData, MapFriendlyName) == 0x000018, "Member 'FReplayMatchData::MapFriendlyName' has a wrong offset!");
static_assert(offsetof(FReplayMatchData, PlayerNames) == 0x000028, "Member 'FReplayMatchData::PlayerNames' has a wrong offset!");

// ScriptStruct TimeWatch.ReplayCustomizationPlayerData
// 0x0028 (0x0028 - 0x0000)
struct FReplayCustomizationPlayerData final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterSKU;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterStyleSKU;                                 // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplayCustomizationPlayerData) == 0x000008, "Wrong alignment on FReplayCustomizationPlayerData");
static_assert(sizeof(FReplayCustomizationPlayerData) == 0x000028, "Wrong size on FReplayCustomizationPlayerData");
static_assert(offsetof(FReplayCustomizationPlayerData, PlayerId) == 0x000000, "Member 'FReplayCustomizationPlayerData::PlayerId' has a wrong offset!");
static_assert(offsetof(FReplayCustomizationPlayerData, CharacterSKU) == 0x000008, "Member 'FReplayCustomizationPlayerData::CharacterSKU' has a wrong offset!");
static_assert(offsetof(FReplayCustomizationPlayerData, CharacterStyleSKU) == 0x000018, "Member 'FReplayCustomizationPlayerData::CharacterStyleSKU' has a wrong offset!");

// ScriptStruct TimeWatch.ReplayCharSelectionData
// 0x0020 (0x0020 - 0x0000)
struct FReplayCharSelectionData final
{
public:
	TArray<struct FReplayCustomizationPlayerData> PlayerCustomizationData;                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CharacterSelectionTime;                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterSelectionCatchupTime;                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplayCharSelectionData) == 0x000008, "Wrong alignment on FReplayCharSelectionData");
static_assert(sizeof(FReplayCharSelectionData) == 0x000020, "Wrong size on FReplayCharSelectionData");
static_assert(offsetof(FReplayCharSelectionData, PlayerCustomizationData) == 0x000000, "Member 'FReplayCharSelectionData::PlayerCustomizationData' has a wrong offset!");
static_assert(offsetof(FReplayCharSelectionData, CharacterSelectionTime) == 0x000010, "Member 'FReplayCharSelectionData::CharacterSelectionTime' has a wrong offset!");
static_assert(offsetof(FReplayCharSelectionData, CharacterSelectionCatchupTime) == 0x000014, "Member 'FReplayCharSelectionData::CharacterSelectionCatchupTime' has a wrong offset!");
static_assert(offsetof(FReplayCharSelectionData, bIsValid) == 0x000018, "Member 'FReplayCharSelectionData::bIsValid' has a wrong offset!");

// ScriptStruct TimeWatch.ChallengeCompletionData
// 0x0001 (0x0001 - 0x0000)
struct FChallengeCompletionData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeCompletionData) == 0x000001, "Wrong alignment on FChallengeCompletionData");
static_assert(sizeof(FChallengeCompletionData) == 0x000001, "Wrong size on FChallengeCompletionData");

// ScriptStruct TimeWatch.ChallengeLocalRewards
// 0x0018 (0x0018 - 0x0000)
struct FChallengeLocalRewards final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Delta;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Abs;                                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeLocalRewards) == 0x000008, "Wrong alignment on FChallengeLocalRewards");
static_assert(sizeof(FChallengeLocalRewards) == 0x000018, "Wrong size on FChallengeLocalRewards");
static_assert(offsetof(FChallengeLocalRewards, Name) == 0x000000, "Member 'FChallengeLocalRewards::Name' has a wrong offset!");
static_assert(offsetof(FChallengeLocalRewards, Delta) == 0x000010, "Member 'FChallengeLocalRewards::Delta' has a wrong offset!");
static_assert(offsetof(FChallengeLocalRewards, Abs) == 0x000014, "Member 'FChallengeLocalRewards::Abs' has a wrong offset!");

// ScriptStruct TimeWatch.ChallengeBackendRequirements
// 0x0058 (0x0058 - 0x0000)
struct FChallengeBackendRequirements final
{
public:
	uint8                                         Requirements;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETWChallengeBackendRequirementType, int32> MinRequirements;                                 // 0x0008(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeBackendRequirements) == 0x000008, "Wrong alignment on FChallengeBackendRequirements");
static_assert(sizeof(FChallengeBackendRequirements) == 0x000058, "Wrong size on FChallengeBackendRequirements");
static_assert(offsetof(FChallengeBackendRequirements, Requirements) == 0x000000, "Member 'FChallengeBackendRequirements::Requirements' has a wrong offset!");
static_assert(offsetof(FChallengeBackendRequirements, MinRequirements) == 0x000008, "Member 'FChallengeBackendRequirements::MinRequirements' has a wrong offset!");

// ScriptStruct TimeWatch.ChallengeLocalRequirements
// 0x0020 (0x0020 - 0x0000)
struct FChallengeLocalRequirements final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Equal;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeLocalRequirements) == 0x000008, "Wrong alignment on FChallengeLocalRequirements");
static_assert(sizeof(FChallengeLocalRequirements) == 0x000020, "Wrong size on FChallengeLocalRequirements");
static_assert(offsetof(FChallengeLocalRequirements, Name) == 0x000000, "Member 'FChallengeLocalRequirements::Name' has a wrong offset!");
static_assert(offsetof(FChallengeLocalRequirements, Min) == 0x000010, "Member 'FChallengeLocalRequirements::Min' has a wrong offset!");
static_assert(offsetof(FChallengeLocalRequirements, Max) == 0x000014, "Member 'FChallengeLocalRequirements::Max' has a wrong offset!");
static_assert(offsetof(FChallengeLocalRequirements, Equal) == 0x000018, "Member 'FChallengeLocalRequirements::Equal' has a wrong offset!");

// ScriptStruct TimeWatch.ChallengeData
// 0x01B8 (0x01B8 - 0x0000)
struct FChallengeData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   RequirementsDescription;                           // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EChallengeDifficulty                          ChallengeDifficulty;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description_Length;                                // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         RequiredCompletedChallengesID;                     // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FChallengeBackendRequirements          BackendRequirements;                               // 0x0078(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FChallengeLocalRequirements>    RequiredLocalData;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FChallengeLocalRewards>         LocalRewards;                                      // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 NextChallengeID;                                   // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTWLevelEntry>              LevelEntryClass;                                   // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETWLocalizedLanguage, TSoftObjectPtr<class UFileMediaSource>> IntroVideos;                  // 0x0108(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bIsVideoMandatory;                                 // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeededToUnlockFullGameAccess;                     // 0x0159(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ChallengeIcon;                                     // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ChallengeImage;                                    // 0x0188(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInDevelopment;                                  // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInTraining;                                   // 0x01B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipBackendNotify;                                // 0x01B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B3[0x5];                                      // 0x01B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeData) == 0x000008, "Wrong alignment on FChallengeData");
static_assert(sizeof(FChallengeData) == 0x0001B8, "Wrong size on FChallengeData");
static_assert(offsetof(FChallengeData, Title) == 0x000000, "Member 'FChallengeData::Title' has a wrong offset!");
static_assert(offsetof(FChallengeData, Description) == 0x000018, "Member 'FChallengeData::Description' has a wrong offset!");
static_assert(offsetof(FChallengeData, RequirementsDescription) == 0x000030, "Member 'FChallengeData::RequirementsDescription' has a wrong offset!");
static_assert(offsetof(FChallengeData, ChallengeDifficulty) == 0x000048, "Member 'FChallengeData::ChallengeDifficulty' has a wrong offset!");
static_assert(offsetof(FChallengeData, Description_Length) == 0x000050, "Member 'FChallengeData::Description_Length' has a wrong offset!");
static_assert(offsetof(FChallengeData, RequiredCompletedChallengesID) == 0x000068, "Member 'FChallengeData::RequiredCompletedChallengesID' has a wrong offset!");
static_assert(offsetof(FChallengeData, BackendRequirements) == 0x000078, "Member 'FChallengeData::BackendRequirements' has a wrong offset!");
static_assert(offsetof(FChallengeData, RequiredLocalData) == 0x0000D0, "Member 'FChallengeData::RequiredLocalData' has a wrong offset!");
static_assert(offsetof(FChallengeData, LocalRewards) == 0x0000E0, "Member 'FChallengeData::LocalRewards' has a wrong offset!");
static_assert(offsetof(FChallengeData, NextChallengeID) == 0x0000F0, "Member 'FChallengeData::NextChallengeID' has a wrong offset!");
static_assert(offsetof(FChallengeData, LevelEntryClass) == 0x000100, "Member 'FChallengeData::LevelEntryClass' has a wrong offset!");
static_assert(offsetof(FChallengeData, IntroVideos) == 0x000108, "Member 'FChallengeData::IntroVideos' has a wrong offset!");
static_assert(offsetof(FChallengeData, bIsVideoMandatory) == 0x000158, "Member 'FChallengeData::bIsVideoMandatory' has a wrong offset!");
static_assert(offsetof(FChallengeData, bNeededToUnlockFullGameAccess) == 0x000159, "Member 'FChallengeData::bNeededToUnlockFullGameAccess' has a wrong offset!");
static_assert(offsetof(FChallengeData, ChallengeIcon) == 0x000160, "Member 'FChallengeData::ChallengeIcon' has a wrong offset!");
static_assert(offsetof(FChallengeData, ChallengeImage) == 0x000188, "Member 'FChallengeData::ChallengeImage' has a wrong offset!");
static_assert(offsetof(FChallengeData, bIsInDevelopment) == 0x0001B0, "Member 'FChallengeData::bIsInDevelopment' has a wrong offset!");
static_assert(offsetof(FChallengeData, bShowInTraining) == 0x0001B1, "Member 'FChallengeData::bShowInTraining' has a wrong offset!");
static_assert(offsetof(FChallengeData, bSkipBackendNotify) == 0x0001B2, "Member 'FChallengeData::bSkipBackendNotify' has a wrong offset!");

// ScriptStruct TimeWatch.PlayerLocalData
// 0x0008 (0x0008 - 0x0000)
struct FPlayerLocalData final
{
public:
	int32                                         LeagueBoardLevel;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeagueRank;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLocalData) == 0x000004, "Wrong alignment on FPlayerLocalData");
static_assert(sizeof(FPlayerLocalData) == 0x000008, "Wrong size on FPlayerLocalData");
static_assert(offsetof(FPlayerLocalData, LeagueBoardLevel) == 0x000000, "Member 'FPlayerLocalData::LeagueBoardLevel' has a wrong offset!");
static_assert(offsetof(FPlayerLocalData, LeagueRank) == 0x000004, "Member 'FPlayerLocalData::LeagueRank' has a wrong offset!");

// ScriptStruct TimeWatch.PlayerInfo
// 0x000C (0x000C - 0x0000)
struct FPlayerInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamPlayerID;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInfo) == 0x000004, "Wrong alignment on FPlayerInfo");
static_assert(sizeof(FPlayerInfo) == 0x00000C, "Wrong size on FPlayerInfo");
static_assert(offsetof(FPlayerInfo, ID) == 0x000000, "Member 'FPlayerInfo::ID' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, TeamId) == 0x000004, "Member 'FPlayerInfo::TeamId' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, TeamPlayerID) == 0x000008, "Member 'FPlayerInfo::TeamPlayerID' has a wrong offset!");

// ScriptStruct TimeWatch.MatchDescriptor
// 0x0050 (0x0050 - 0x0000)
struct FMatchDescriptor final
{
public:
	class UTWLevelEntry*                          MatchLevelEntry;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchSettings                         MatchSettings;                                     // 0x0008(0x0040)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	ETWMatchType                                  MatchType;                                         // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchDescriptor) == 0x000008, "Wrong alignment on FMatchDescriptor");
static_assert(sizeof(FMatchDescriptor) == 0x000050, "Wrong size on FMatchDescriptor");
static_assert(offsetof(FMatchDescriptor, MatchLevelEntry) == 0x000000, "Member 'FMatchDescriptor::MatchLevelEntry' has a wrong offset!");
static_assert(offsetof(FMatchDescriptor, MatchSettings) == 0x000008, "Member 'FMatchDescriptor::MatchSettings' has a wrong offset!");
static_assert(offsetof(FMatchDescriptor, MatchType) == 0x000048, "Member 'FMatchDescriptor::MatchType' has a wrong offset!");

// ScriptStruct TimeWatch.TWQuickChatEntries
// 0x0030 (0x0030 - 0x0000)
struct FTWQuickChatEntries final
{
public:
	class FText                                   CategoryTittle;                                    // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EChatChannel                                  ChannelType;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           TextEntries;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWQuickChatEntries) == 0x000008, "Wrong alignment on FTWQuickChatEntries");
static_assert(sizeof(FTWQuickChatEntries) == 0x000030, "Wrong size on FTWQuickChatEntries");
static_assert(offsetof(FTWQuickChatEntries, CategoryTittle) == 0x000000, "Member 'FTWQuickChatEntries::CategoryTittle' has a wrong offset!");
static_assert(offsetof(FTWQuickChatEntries, ChannelType) == 0x000018, "Member 'FTWQuickChatEntries::ChannelType' has a wrong offset!");
static_assert(offsetof(FTWQuickChatEntries, TextEntries) == 0x000020, "Member 'FTWQuickChatEntries::TextEntries' has a wrong offset!");

// ScriptStruct TimeWatch.MatchOptionData
// 0x0038 (0x0038 - 0x0000)
struct FMatchOptionData final
{
public:
	class FText                                   MatchOptionName;                                   // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   MatchOptionTab;                                    // 0x0018(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             MatchOptionImage;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchOptionData) == 0x000008, "Wrong alignment on FMatchOptionData");
static_assert(sizeof(FMatchOptionData) == 0x000038, "Wrong size on FMatchOptionData");
static_assert(offsetof(FMatchOptionData, MatchOptionName) == 0x000000, "Member 'FMatchOptionData::MatchOptionName' has a wrong offset!");
static_assert(offsetof(FMatchOptionData, MatchOptionTab) == 0x000018, "Member 'FMatchOptionData::MatchOptionTab' has a wrong offset!");
static_assert(offsetof(FMatchOptionData, MatchOptionImage) == 0x000030, "Member 'FMatchOptionData::MatchOptionImage' has a wrong offset!");

// ScriptStruct TimeWatch.TWImagePopupData
// 0x0038 (0x0038 - 0x0000)
struct FTWImagePopupData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             ImageTexture;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWImagePopupData) == 0x000008, "Wrong alignment on FTWImagePopupData");
static_assert(sizeof(FTWImagePopupData) == 0x000038, "Wrong size on FTWImagePopupData");
static_assert(offsetof(FTWImagePopupData, Title) == 0x000000, "Member 'FTWImagePopupData::Title' has a wrong offset!");
static_assert(offsetof(FTWImagePopupData, Description) == 0x000018, "Member 'FTWImagePopupData::Description' has a wrong offset!");
static_assert(offsetof(FTWImagePopupData, ImageTexture) == 0x000030, "Member 'FTWImagePopupData::ImageTexture' has a wrong offset!");

// ScriptStruct TimeWatch.LaserState_Sound
// 0x0002 (0x0002 - 0x0000)
struct FLaserState_Sound final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLaserState_Sound) == 0x000001, "Wrong alignment on FLaserState_Sound");
static_assert(sizeof(FLaserState_Sound) == 0x000002, "Wrong size on FLaserState_Sound");

// ScriptStruct TimeWatch.TWLeagueInfo
// 0x0070 (0x0070 - 0x0000)
struct FTWLeagueInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      IconMaterial;                                      // 0x0018(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconTexture;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PromotionPercent;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DemotionPercent;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LeftGradientColor;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RightGradientColor;                                // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWLeagueInfo) == 0x000008, "Wrong alignment on FTWLeagueInfo");
static_assert(sizeof(FTWLeagueInfo) == 0x000070, "Wrong size on FTWLeagueInfo");
static_assert(offsetof(FTWLeagueInfo, Name) == 0x000000, "Member 'FTWLeagueInfo::Name' has a wrong offset!");
static_assert(offsetof(FTWLeagueInfo, IconMaterial) == 0x000018, "Member 'FTWLeagueInfo::IconMaterial' has a wrong offset!");
static_assert(offsetof(FTWLeagueInfo, IconTexture) == 0x000040, "Member 'FTWLeagueInfo::IconTexture' has a wrong offset!");
static_assert(offsetof(FTWLeagueInfo, PromotionPercent) == 0x000048, "Member 'FTWLeagueInfo::PromotionPercent' has a wrong offset!");
static_assert(offsetof(FTWLeagueInfo, DemotionPercent) == 0x00004C, "Member 'FTWLeagueInfo::DemotionPercent' has a wrong offset!");
static_assert(offsetof(FTWLeagueInfo, LeftGradientColor) == 0x000050, "Member 'FTWLeagueInfo::LeftGradientColor' has a wrong offset!");
static_assert(offsetof(FTWLeagueInfo, RightGradientColor) == 0x000060, "Member 'FTWLeagueInfo::RightGradientColor' has a wrong offset!");

// ScriptStruct TimeWatch.TWCrowdReactionConfig
// 0x0060 (0x0060 - 0x0000)
struct FTWCrowdReactionConfig final
{
public:
	bool                                          bShouldTriggerCrowdReaction;                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EventScoringCriteria;                              // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDSoundConfig                        SoundEvent;                                        // 0x0008(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWCrowdReactionConfig) == 0x000008, "Wrong alignment on FTWCrowdReactionConfig");
static_assert(sizeof(FTWCrowdReactionConfig) == 0x000060, "Wrong size on FTWCrowdReactionConfig");
static_assert(offsetof(FTWCrowdReactionConfig, bShouldTriggerCrowdReaction) == 0x000000, "Member 'FTWCrowdReactionConfig::bShouldTriggerCrowdReaction' has a wrong offset!");
static_assert(offsetof(FTWCrowdReactionConfig, EventScoringCriteria) == 0x000001, "Member 'FTWCrowdReactionConfig::EventScoringCriteria' has a wrong offset!");
static_assert(offsetof(FTWCrowdReactionConfig, SoundEvent) == 0x000008, "Member 'FTWCrowdReactionConfig::SoundEvent' has a wrong offset!");

// ScriptStruct TimeWatch.DeathData
// 0x0028 (0x0028 - 0x0000)
struct FDeathData final
{
public:
	class ATimeWatchCharacter*                    Instigator;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DeathLocation;                                     // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InstigatorLocation;                                // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeathData) == 0x000008, "Wrong alignment on FDeathData");
static_assert(sizeof(FDeathData) == 0x000028, "Wrong size on FDeathData");
static_assert(offsetof(FDeathData, Instigator) == 0x000000, "Member 'FDeathData::Instigator' has a wrong offset!");
static_assert(offsetof(FDeathData, Timestamp) == 0x000008, "Member 'FDeathData::Timestamp' has a wrong offset!");
static_assert(offsetof(FDeathData, DeathLocation) == 0x00000C, "Member 'FDeathData::DeathLocation' has a wrong offset!");
static_assert(offsetof(FDeathData, InstigatorLocation) == 0x000018, "Member 'FDeathData::InstigatorLocation' has a wrong offset!");

// ScriptStruct TimeWatch.Trail
// 0x0078 (0x0078 - 0x0000)
struct FTrail final
{
public:
	TArray<class USplineMeshComponent*>           Movement_Splines;                                  // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       Movement_DynMaterials;                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           Kills_Splines;                                     // 0x0020(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       Kills_DynMaterials;                                // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPointData>                     PointData;                                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDeathData>                     DeathsData;                                        // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ArrowHead;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           MortalityMarkers;                                  // 0x0068(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrail) == 0x000008, "Wrong alignment on FTrail");
static_assert(sizeof(FTrail) == 0x000078, "Wrong size on FTrail");
static_assert(offsetof(FTrail, Movement_Splines) == 0x000000, "Member 'FTrail::Movement_Splines' has a wrong offset!");
static_assert(offsetof(FTrail, Movement_DynMaterials) == 0x000010, "Member 'FTrail::Movement_DynMaterials' has a wrong offset!");
static_assert(offsetof(FTrail, Kills_Splines) == 0x000020, "Member 'FTrail::Kills_Splines' has a wrong offset!");
static_assert(offsetof(FTrail, Kills_DynMaterials) == 0x000030, "Member 'FTrail::Kills_DynMaterials' has a wrong offset!");
static_assert(offsetof(FTrail, PointData) == 0x000040, "Member 'FTrail::PointData' has a wrong offset!");
static_assert(offsetof(FTrail, DeathsData) == 0x000050, "Member 'FTrail::DeathsData' has a wrong offset!");
static_assert(offsetof(FTrail, ArrowHead) == 0x000060, "Member 'FTrail::ArrowHead' has a wrong offset!");
static_assert(offsetof(FTrail, MortalityMarkers) == 0x000068, "Member 'FTrail::MortalityMarkers' has a wrong offset!");

// ScriptStruct TimeWatch.ProjectileCollection
// 0x0010 (0x0010 - 0x0000)
struct FProjectileCollection final
{
public:
	TArray<class ATimeWatchProjectile*>           Instances;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileCollection) == 0x000008, "Wrong alignment on FProjectileCollection");
static_assert(sizeof(FProjectileCollection) == 0x000010, "Wrong size on FProjectileCollection");
static_assert(offsetof(FProjectileCollection, Instances) == 0x000000, "Member 'FProjectileCollection::Instances' has a wrong offset!");

// ScriptStruct TimeWatch.ProjectilePredictionData
// 0x0060 (0x0060 - 0x0000)
struct FProjectilePredictionData final
{
public:
	TSubclassOf<class ATWPhysicalProjectile>      ProjectileClass;                                   // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartDirection;                                    // 0x0014(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntialSegmentsToSkip;                              // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRadius;                                  // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTravelTime;                                     // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimFrequency;                                      // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     BouncingCollisionChannels;                         // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinVelocity;                                       // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectilePredictionData) == 0x000008, "Wrong alignment on FProjectilePredictionData");
static_assert(sizeof(FProjectilePredictionData) == 0x000060, "Wrong size on FProjectilePredictionData");
static_assert(offsetof(FProjectilePredictionData, ProjectileClass) == 0x000000, "Member 'FProjectilePredictionData::ProjectileClass' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, StartLocation) == 0x000008, "Member 'FProjectilePredictionData::StartLocation' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, StartDirection) == 0x000014, "Member 'FProjectilePredictionData::StartDirection' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, ActorsToIgnore) == 0x000020, "Member 'FProjectilePredictionData::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, InitialSpeed) == 0x000030, "Member 'FProjectilePredictionData::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, IntialSegmentsToSkip) == 0x000034, "Member 'FProjectilePredictionData::IntialSegmentsToSkip' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, ProjectileRadius) == 0x000038, "Member 'FProjectilePredictionData::ProjectileRadius' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, MaxTravelTime) == 0x00003C, "Member 'FProjectilePredictionData::MaxTravelTime' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, SimFrequency) == 0x000040, "Member 'FProjectilePredictionData::SimFrequency' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, BouncingCollisionChannels) == 0x000048, "Member 'FProjectilePredictionData::BouncingCollisionChannels' has a wrong offset!");
static_assert(offsetof(FProjectilePredictionData, MinVelocity) == 0x000058, "Member 'FProjectilePredictionData::MinVelocity' has a wrong offset!");

// ScriptStruct TimeWatch.ReplicationProjectileState
// 0x002C (0x002C - 0x0000)
struct FReplicationProjectileState final
{
public:
	int32                                         SimulationTick;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTravelTime;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicationProjectileState) == 0x000004, "Wrong alignment on FReplicationProjectileState");
static_assert(sizeof(FReplicationProjectileState) == 0x00002C, "Wrong size on FReplicationProjectileState");
static_assert(offsetof(FReplicationProjectileState, SimulationTick) == 0x000000, "Member 'FReplicationProjectileState::SimulationTick' has a wrong offset!");
static_assert(offsetof(FReplicationProjectileState, MaxTravelTime) == 0x000004, "Member 'FReplicationProjectileState::MaxTravelTime' has a wrong offset!");
static_assert(offsetof(FReplicationProjectileState, Velocity) == 0x000008, "Member 'FReplicationProjectileState::Velocity' has a wrong offset!");
static_assert(offsetof(FReplicationProjectileState, Position) == 0x000014, "Member 'FReplicationProjectileState::Position' has a wrong offset!");
static_assert(offsetof(FReplicationProjectileState, Rotation) == 0x000020, "Member 'FReplicationProjectileState::Rotation' has a wrong offset!");

// ScriptStruct TimeWatch.ReplicationProjectileActivationData
// 0x0034 (0x0034 - 0x0000)
struct FReplicationProjectileActivationData final
{
public:
	struct FReplicationProjectileState            State;                                             // 0x0000(0x002C)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ProjectileID;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLoop;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicationProjectileActivationData) == 0x000004, "Wrong alignment on FReplicationProjectileActivationData");
static_assert(sizeof(FReplicationProjectileActivationData) == 0x000034, "Wrong size on FReplicationProjectileActivationData");
static_assert(offsetof(FReplicationProjectileActivationData, State) == 0x000000, "Member 'FReplicationProjectileActivationData::State' has a wrong offset!");
static_assert(offsetof(FReplicationProjectileActivationData, ProjectileID) == 0x00002C, "Member 'FReplicationProjectileActivationData::ProjectileID' has a wrong offset!");
static_assert(offsetof(FReplicationProjectileActivationData, CurrentLoop) == 0x000030, "Member 'FReplicationProjectileActivationData::CurrentLoop' has a wrong offset!");

// ScriptStruct TimeWatch.ProjectionParameters
// 0x0018 (0x0018 - 0x0000)
struct FProjectionParameters final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOV;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewOffset;                                        // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewInvariantScale;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectionParameters) == 0x000004, "Wrong alignment on FProjectionParameters");
static_assert(sizeof(FProjectionParameters) == 0x000018, "Wrong size on FProjectionParameters");
static_assert(offsetof(FProjectionParameters, bEnabled) == 0x000000, "Member 'FProjectionParameters::bEnabled' has a wrong offset!");
static_assert(offsetof(FProjectionParameters, FOV) == 0x000004, "Member 'FProjectionParameters::FOV' has a wrong offset!");
static_assert(offsetof(FProjectionParameters, ViewOffset) == 0x000008, "Member 'FProjectionParameters::ViewOffset' has a wrong offset!");
static_assert(offsetof(FProjectionParameters, ViewInvariantScale) == 0x000014, "Member 'FProjectionParameters::ViewInvariantScale' has a wrong offset!");

// ScriptStruct TimeWatch.ScreenshotWeaponStyleDataAsset
// 0x0010 (0x0010 - 0x0000)
struct FScreenshotWeaponStyleDataAsset final
{
public:
	TArray<class UTWWeaponStyleDataAsset*>        Styles;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotWeaponStyleDataAsset) == 0x000008, "Wrong alignment on FScreenshotWeaponStyleDataAsset");
static_assert(sizeof(FScreenshotWeaponStyleDataAsset) == 0x000010, "Wrong size on FScreenshotWeaponStyleDataAsset");
static_assert(offsetof(FScreenshotWeaponStyleDataAsset, Styles) == 0x000000, "Member 'FScreenshotWeaponStyleDataAsset::Styles' has a wrong offset!");

// ScriptStruct TimeWatch.ScreenshotStyleDataAsset
// 0x0010 (0x0010 - 0x0000)
struct FScreenshotStyleDataAsset final
{
public:
	TArray<class UTWStylesDataAsset*>             Styles;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotStyleDataAsset) == 0x000008, "Wrong alignment on FScreenshotStyleDataAsset");
static_assert(sizeof(FScreenshotStyleDataAsset) == 0x000010, "Wrong size on FScreenshotStyleDataAsset");
static_assert(offsetof(FScreenshotStyleDataAsset, Styles) == 0x000000, "Member 'FScreenshotStyleDataAsset::Styles' has a wrong offset!");

// ScriptStruct TimeWatch.StyleEntry
// 0x0040 (0x0040 - 0x0000)
struct FStyleEntry final
{
public:
	TArray<TSoftObjectPtr<class UMaterialInterface>> MaterialsPerSlot;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSkeletalMeshStructure                 SkeletalMeshStruct;                                // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStyleEntry) == 0x000008, "Wrong alignment on FStyleEntry");
static_assert(sizeof(FStyleEntry) == 0x000040, "Wrong size on FStyleEntry");
static_assert(offsetof(FStyleEntry, MaterialsPerSlot) == 0x000000, "Member 'FStyleEntry::MaterialsPerSlot' has a wrong offset!");
static_assert(offsetof(FStyleEntry, SkeletalMeshStruct) == 0x000010, "Member 'FStyleEntry::SkeletalMeshStruct' has a wrong offset!");

// ScriptStruct TimeWatch.SwitchInteractionData
// 0x0018 (0x0018 - 0x0000)
struct FSwitchInteractionData final
{
public:
	class ATWActivableActor*                      ActivableActor;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATWInteractiveSwitch*>           LinkedSwitchs;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSwitchInteractionData) == 0x000008, "Wrong alignment on FSwitchInteractionData");
static_assert(sizeof(FSwitchInteractionData) == 0x000018, "Wrong size on FSwitchInteractionData");
static_assert(offsetof(FSwitchInteractionData, ActivableActor) == 0x000000, "Member 'FSwitchInteractionData::ActivableActor' has a wrong offset!");
static_assert(offsetof(FSwitchInteractionData, LinkedSwitchs) == 0x000008, "Member 'FSwitchInteractionData::LinkedSwitchs' has a wrong offset!");

// ScriptStruct TimeWatch.TrailPoint
// 0x0020 (0x0020 - 0x0000)
struct FTrailPoint final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineMeshComponent*                   Spline;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrailPoint) == 0x000008, "Wrong alignment on FTrailPoint");
static_assert(sizeof(FTrailPoint) == 0x000020, "Wrong size on FTrailPoint");
static_assert(offsetof(FTrailPoint, Spline) == 0x000008, "Member 'FTrailPoint::Spline' has a wrong offset!");

// ScriptStruct TimeWatch.TWWeaponEntry
// 0x0058 (0x0058 - 0x0000)
struct FTWWeaponEntry final
{
public:
	class FText                                   WeaponName;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   WeaponDescription;                                 // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             ItemIcon;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ItemSize;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATemporalWeapon>            WeaponClass;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ATemporalWeapon>>    WeaponTestClasses;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWWeaponEntry) == 0x000008, "Wrong alignment on FTWWeaponEntry");
static_assert(sizeof(FTWWeaponEntry) == 0x000058, "Wrong size on FTWWeaponEntry");
static_assert(offsetof(FTWWeaponEntry, WeaponName) == 0x000000, "Member 'FTWWeaponEntry::WeaponName' has a wrong offset!");
static_assert(offsetof(FTWWeaponEntry, WeaponDescription) == 0x000018, "Member 'FTWWeaponEntry::WeaponDescription' has a wrong offset!");
static_assert(offsetof(FTWWeaponEntry, ItemIcon) == 0x000030, "Member 'FTWWeaponEntry::ItemIcon' has a wrong offset!");
static_assert(offsetof(FTWWeaponEntry, ItemSize) == 0x000038, "Member 'FTWWeaponEntry::ItemSize' has a wrong offset!");
static_assert(offsetof(FTWWeaponEntry, WeaponClass) == 0x000040, "Member 'FTWWeaponEntry::WeaponClass' has a wrong offset!");
static_assert(offsetof(FTWWeaponEntry, WeaponTestClasses) == 0x000048, "Member 'FTWWeaponEntry::WeaponTestClasses' has a wrong offset!");

// ScriptStruct TimeWatch.TWWeaponStyleEntry
// 0x0050 (0x0050 - 0x0000)
struct FTWWeaponStyleEntry final
{
public:
	class FText                                   UI_StyleNameDisplay;                               // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           ModelSK;                                           // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMaterialInterface>> WeaponMaterials;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTWWeaponStyleEntry) == 0x000008, "Wrong alignment on FTWWeaponStyleEntry");
static_assert(sizeof(FTWWeaponStyleEntry) == 0x000050, "Wrong size on FTWWeaponStyleEntry");
static_assert(offsetof(FTWWeaponStyleEntry, UI_StyleNameDisplay) == 0x000000, "Member 'FTWWeaponStyleEntry::UI_StyleNameDisplay' has a wrong offset!");
static_assert(offsetof(FTWWeaponStyleEntry, ModelSK) == 0x000018, "Member 'FTWWeaponStyleEntry::ModelSK' has a wrong offset!");
static_assert(offsetof(FTWWeaponStyleEntry, WeaponMaterials) == 0x000040, "Member 'FTWWeaponStyleEntry::WeaponMaterials' has a wrong offset!");

// ScriptStruct TimeWatch.WidgetInstancesData
// 0x0010 (0x0010 - 0x0000)
struct FWidgetInstancesData final
{
public:
	TArray<class UTW2DCompass*>                   Instances;                                         // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetInstancesData) == 0x000008, "Wrong alignment on FWidgetInstancesData");
static_assert(sizeof(FWidgetInstancesData) == 0x000010, "Wrong size on FWidgetInstancesData");
static_assert(offsetof(FWidgetInstancesData, Instances) == 0x000000, "Member 'FWidgetInstancesData::Instances' has a wrong offset!");

// ScriptStruct TimeWatch.ExplosionFeedbackConfig
// 0x0010 (0x0010 - 0x0000)
struct FExplosionFeedbackConfig final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplosionFeedbackConfig) == 0x000004, "Wrong alignment on FExplosionFeedbackConfig");
static_assert(sizeof(FExplosionFeedbackConfig) == 0x000010, "Wrong size on FExplosionFeedbackConfig");
static_assert(offsetof(FExplosionFeedbackConfig, Duration) == 0x000000, "Member 'FExplosionFeedbackConfig::Duration' has a wrong offset!");
static_assert(offsetof(FExplosionFeedbackConfig, Offset) == 0x000004, "Member 'FExplosionFeedbackConfig::Offset' has a wrong offset!");

// ScriptStruct TimeWatch.RarityInfo
// 0x0028 (0x0028 - 0x0000)
struct FRarityInfo final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRarityInfo) == 0x000008, "Wrong alignment on FRarityInfo");
static_assert(sizeof(FRarityInfo) == 0x000028, "Wrong size on FRarityInfo");
static_assert(offsetof(FRarityInfo, Color) == 0x000000, "Member 'FRarityInfo::Color' has a wrong offset!");
static_assert(offsetof(FRarityInfo, DisplayName) == 0x000010, "Member 'FRarityInfo::DisplayName' has a wrong offset!");

// ScriptStruct TimeWatch.MatchScoreData
// 0x0078 (0x0078 - 0x0000)
struct FMatchScoreData final
{
public:
	struct FLinearColor                           LocalScore1;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LocalScore2;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LocalScore3;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RemoteScore1;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RemoteScore2;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RemoteScore3;                                      // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RoundAndLoop;                                      // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchScoreData) == 0x000008, "Wrong alignment on FMatchScoreData");
static_assert(sizeof(FMatchScoreData) == 0x000078, "Wrong size on FMatchScoreData");
static_assert(offsetof(FMatchScoreData, LocalScore1) == 0x000000, "Member 'FMatchScoreData::LocalScore1' has a wrong offset!");
static_assert(offsetof(FMatchScoreData, LocalScore2) == 0x000010, "Member 'FMatchScoreData::LocalScore2' has a wrong offset!");
static_assert(offsetof(FMatchScoreData, LocalScore3) == 0x000020, "Member 'FMatchScoreData::LocalScore3' has a wrong offset!");
static_assert(offsetof(FMatchScoreData, RemoteScore1) == 0x000030, "Member 'FMatchScoreData::RemoteScore1' has a wrong offset!");
static_assert(offsetof(FMatchScoreData, RemoteScore2) == 0x000040, "Member 'FMatchScoreData::RemoteScore2' has a wrong offset!");
static_assert(offsetof(FMatchScoreData, RemoteScore3) == 0x000050, "Member 'FMatchScoreData::RemoteScore3' has a wrong offset!");
static_assert(offsetof(FMatchScoreData, RoundAndLoop) == 0x000060, "Member 'FMatchScoreData::RoundAndLoop' has a wrong offset!");

// ScriptStruct TimeWatch.RowFieldProperties
// 0x0088 (0x0088 - 0x0000)
struct FRowFieldProperties final
{
public:
	ELeaderboardProperties                        LeaderboardPropertyID;                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldWidth;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         FieldFont;                                         // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            FieldFontColor;                                    // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             TitleIcon;                                         // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRowFieldProperties) == 0x000008, "Wrong alignment on FRowFieldProperties");
static_assert(sizeof(FRowFieldProperties) == 0x000088, "Wrong size on FRowFieldProperties");
static_assert(offsetof(FRowFieldProperties, LeaderboardPropertyID) == 0x000000, "Member 'FRowFieldProperties::LeaderboardPropertyID' has a wrong offset!");
static_assert(offsetof(FRowFieldProperties, FieldWidth) == 0x000004, "Member 'FRowFieldProperties::FieldWidth' has a wrong offset!");
static_assert(offsetof(FRowFieldProperties, FieldFont) == 0x000008, "Member 'FRowFieldProperties::FieldFont' has a wrong offset!");
static_assert(offsetof(FRowFieldProperties, FieldFontColor) == 0x000058, "Member 'FRowFieldProperties::FieldFontColor' has a wrong offset!");
static_assert(offsetof(FRowFieldProperties, TitleIcon) == 0x000080, "Member 'FRowFieldProperties::TitleIcon' has a wrong offset!");

// ScriptStruct TimeWatch.TipNotificationConfig
// 0x0010 (0x0010 - 0x0000)
struct FTipNotificationConfig final
{
public:
	class UTexture2D*                             IconImage;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BackgroundImage;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTipNotificationConfig) == 0x000008, "Wrong alignment on FTipNotificationConfig");
static_assert(sizeof(FTipNotificationConfig) == 0x000010, "Wrong size on FTipNotificationConfig");
static_assert(offsetof(FTipNotificationConfig, IconImage) == 0x000000, "Member 'FTipNotificationConfig::IconImage' has a wrong offset!");
static_assert(offsetof(FTipNotificationConfig, BackgroundImage) == 0x000008, "Member 'FTipNotificationConfig::BackgroundImage' has a wrong offset!");

}

