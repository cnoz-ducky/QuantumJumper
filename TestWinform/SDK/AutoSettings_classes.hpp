#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AutoSettings

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_classes.hpp"
#include "InputCore_structs.hpp"
#include "AutoSettings_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class AutoSettings.InputLabel
// 0x0030 (0x0260 - 0x0230)
class UInputLabel : public UUserWidget
{
public:
	int32                                         MappingGroup;                                      // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           KeyGroup;                                          // 0x0234(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlayerKeyGroup;                                // 0x023C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IconTags;                                          // 0x0240(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void MappingsChanged(class APlayerController* Player);
	void UpdateLabel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputLabel">();
	}
	static class UInputLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputLabel>();
	}
};
static_assert(alignof(UInputLabel) == 0x000008, "Wrong alignment on UInputLabel");
static_assert(sizeof(UInputLabel) == 0x000260, "Wrong size on UInputLabel");
static_assert(offsetof(UInputLabel, MappingGroup) == 0x000230, "Member 'UInputLabel::MappingGroup' has a wrong offset!");
static_assert(offsetof(UInputLabel, KeyGroup) == 0x000234, "Member 'UInputLabel::KeyGroup' has a wrong offset!");
static_assert(offsetof(UInputLabel, bUsePlayerKeyGroup) == 0x00023C, "Member 'UInputLabel::bUsePlayerKeyGroup' has a wrong offset!");
static_assert(offsetof(UInputLabel, IconTags) == 0x000240, "Member 'UInputLabel::IconTags' has a wrong offset!");

// Class AutoSettings.ActionLabel
// 0x0068 (0x02C8 - 0x0260)
class UActionLabel : public UInputLabel
{
public:
	class FName                                   ActionName;                                        // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UKeyLabel>                  KeyLabelWidgetClass;                               // 0x0268(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidget>                    KeySeparatorWidgetClass;                           // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           KeyContainer;                                      // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKeyLabel*                              PrimaryKeyLabel;                                   // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKeyLabel*                              ShiftLabel;                                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKeyLabel*                              CtrlLabel;                                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKeyLabel*                              AltLabel;                                          // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKeyLabel*                              CmdLabel;                                          // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                ShiftSeparator;                                    // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                CtrlSeparator;                                     // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                AltSeparator;                                      // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                CmdSeparator;                                      // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionLabel">();
	}
	static class UActionLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionLabel>();
	}
};
static_assert(alignof(UActionLabel) == 0x000008, "Wrong alignment on UActionLabel");
static_assert(sizeof(UActionLabel) == 0x0002C8, "Wrong size on UActionLabel");
static_assert(offsetof(UActionLabel, ActionName) == 0x000260, "Member 'UActionLabel::ActionName' has a wrong offset!");
static_assert(offsetof(UActionLabel, KeyLabelWidgetClass) == 0x000268, "Member 'UActionLabel::KeyLabelWidgetClass' has a wrong offset!");
static_assert(offsetof(UActionLabel, KeySeparatorWidgetClass) == 0x000270, "Member 'UActionLabel::KeySeparatorWidgetClass' has a wrong offset!");
static_assert(offsetof(UActionLabel, KeyContainer) == 0x000278, "Member 'UActionLabel::KeyContainer' has a wrong offset!");
static_assert(offsetof(UActionLabel, PrimaryKeyLabel) == 0x000280, "Member 'UActionLabel::PrimaryKeyLabel' has a wrong offset!");
static_assert(offsetof(UActionLabel, ShiftLabel) == 0x000288, "Member 'UActionLabel::ShiftLabel' has a wrong offset!");
static_assert(offsetof(UActionLabel, CtrlLabel) == 0x000290, "Member 'UActionLabel::CtrlLabel' has a wrong offset!");
static_assert(offsetof(UActionLabel, AltLabel) == 0x000298, "Member 'UActionLabel::AltLabel' has a wrong offset!");
static_assert(offsetof(UActionLabel, CmdLabel) == 0x0002A0, "Member 'UActionLabel::CmdLabel' has a wrong offset!");
static_assert(offsetof(UActionLabel, ShiftSeparator) == 0x0002A8, "Member 'UActionLabel::ShiftSeparator' has a wrong offset!");
static_assert(offsetof(UActionLabel, CtrlSeparator) == 0x0002B0, "Member 'UActionLabel::CtrlSeparator' has a wrong offset!");
static_assert(offsetof(UActionLabel, AltSeparator) == 0x0002B8, "Member 'UActionLabel::AltSeparator' has a wrong offset!");
static_assert(offsetof(UActionLabel, CmdSeparator) == 0x0002C0, "Member 'UActionLabel::CmdSeparator' has a wrong offset!");

// Class AutoSettings.AutoSettingsValidationSubsystem
// 0x0000 (0x0030 - 0x0030)
class UAutoSettingsValidationSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoSettingsValidationSubsystem">();
	}
	static class UAutoSettingsValidationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoSettingsValidationSubsystem>();
	}
};
static_assert(alignof(UAutoSettingsValidationSubsystem) == 0x000008, "Wrong alignment on UAutoSettingsValidationSubsystem");
static_assert(sizeof(UAutoSettingsValidationSubsystem) == 0x000030, "Wrong size on UAutoSettingsValidationSubsystem");

// Class AutoSettings.InputMapping
// 0x0038 (0x0268 - 0x0230)
class UInputMapping : public UUserWidget
{
public:
	int32                                         MappingGroup;                                      // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           KeyGroup;                                          // 0x0234(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IconTags;                                          // 0x0240(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UBindCaptureButton*                     BindCaptureButton;                                 // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindChord(const struct FInputChord& InChord);
	void ChordCaptured(const struct FInputChord& InChord);
	void UpdateLabel();
	void UpdateMapping();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputMapping">();
	}
	static class UInputMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputMapping>();
	}
};
static_assert(alignof(UInputMapping) == 0x000008, "Wrong alignment on UInputMapping");
static_assert(sizeof(UInputMapping) == 0x000268, "Wrong size on UInputMapping");
static_assert(offsetof(UInputMapping, MappingGroup) == 0x000230, "Member 'UInputMapping::MappingGroup' has a wrong offset!");
static_assert(offsetof(UInputMapping, KeyGroup) == 0x000234, "Member 'UInputMapping::KeyGroup' has a wrong offset!");
static_assert(offsetof(UInputMapping, IconTags) == 0x000240, "Member 'UInputMapping::IconTags' has a wrong offset!");
static_assert(offsetof(UInputMapping, BindCaptureButton) == 0x000260, "Member 'UInputMapping::BindCaptureButton' has a wrong offset!");

// Class AutoSettings.AutoSettingWidget
// 0x0050 (0x0280 - 0x0230)
class UAutoSettingWidget : public UUserWidget
{
public:
	class FName                                   CVarName;                                          // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USettingValueMask>          ValueMask;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSave;                                         // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoApply;                                        // 0x0241(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_242[0x6];                                      // 0x0242(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SettingTags;                                       // 0x0248(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 CurrentValue;                                      // 0x0268(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasUnappliedChange;                               // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasUnsavedChange;                                 // 0x0279(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdatingSettingSelection;                         // 0x027A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27B[0x5];                                      // 0x027B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Apply();
	void ApplySettingValue(const class FString& Value, bool bSaveIfPossible);
	void Cancel();
	void Save();
	void UpdateSelection(const class FString& Value);

	bool HasUnappliedChange() const;
	bool HasUnsavedChange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoSettingWidget">();
	}
	static class UAutoSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoSettingWidget>();
	}
};
static_assert(alignof(UAutoSettingWidget) == 0x000008, "Wrong alignment on UAutoSettingWidget");
static_assert(sizeof(UAutoSettingWidget) == 0x000280, "Wrong size on UAutoSettingWidget");
static_assert(offsetof(UAutoSettingWidget, CVarName) == 0x000230, "Member 'UAutoSettingWidget::CVarName' has a wrong offset!");
static_assert(offsetof(UAutoSettingWidget, ValueMask) == 0x000238, "Member 'UAutoSettingWidget::ValueMask' has a wrong offset!");
static_assert(offsetof(UAutoSettingWidget, bAutoSave) == 0x000240, "Member 'UAutoSettingWidget::bAutoSave' has a wrong offset!");
static_assert(offsetof(UAutoSettingWidget, bAutoApply) == 0x000241, "Member 'UAutoSettingWidget::bAutoApply' has a wrong offset!");
static_assert(offsetof(UAutoSettingWidget, SettingTags) == 0x000248, "Member 'UAutoSettingWidget::SettingTags' has a wrong offset!");
static_assert(offsetof(UAutoSettingWidget, CurrentValue) == 0x000268, "Member 'UAutoSettingWidget::CurrentValue' has a wrong offset!");
static_assert(offsetof(UAutoSettingWidget, bHasUnappliedChange) == 0x000278, "Member 'UAutoSettingWidget::bHasUnappliedChange' has a wrong offset!");
static_assert(offsetof(UAutoSettingWidget, bHasUnsavedChange) == 0x000279, "Member 'UAutoSettingWidget::bHasUnsavedChange' has a wrong offset!");
static_assert(offsetof(UAutoSettingWidget, bUpdatingSettingSelection) == 0x00027A, "Member 'UAutoSettingWidget::bUpdatingSettingSelection' has a wrong offset!");

// Class AutoSettings.ActionMapping
// 0x0010 (0x0278 - 0x0268)
class UActionMapping : public UInputMapping
{
public:
	class FName                                   ActionName;                                        // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActionLabel*                           ActionLabel;                                       // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionMapping">();
	}
	static class UActionMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionMapping>();
	}
};
static_assert(alignof(UActionMapping) == 0x000008, "Wrong alignment on UActionMapping");
static_assert(sizeof(UActionMapping) == 0x000278, "Wrong size on UActionMapping");
static_assert(offsetof(UActionMapping, ActionName) == 0x000268, "Member 'UActionMapping::ActionName' has a wrong offset!");
static_assert(offsetof(UActionMapping, ActionLabel) == 0x000270, "Member 'UActionMapping::ActionLabel' has a wrong offset!");

// Class AutoSettings.AutoSettingsConfig
// 0x0128 (0x0150 - 0x0028)
class UAutoSettingsConfig final : public UObject
{
public:
	bool                                          bAutoInitializePlayerInputOverrides;               // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowModifierKeys;                                 // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ShiftModifierOverrideText;                         // 0x0030(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	class FText                                   CtrlModifierOverrideText;                          // 0x0048(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	class FText                                   AltModifierOverrideText;                           // 0x0060(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	class FText                                   CmdModifierOverrideText;                           // 0x0078(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FInputMappingPreset>            InputPresets;                                      // 0x0090(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          AllowMultipleBindingsPerKey;                       // 0x00A0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMappingGroupLink>              MappingGroupLinks;                                 // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           BlacklistedActions;                                // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           BlacklistedAxes;                                   // 0x00C8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FKeyIconSet>                    KeyIconSets;                                       // 0x00D8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FKeyFriendlyName>               KeyFriendlyNames;                                  // 0x00E8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FKeyGroup>                      KeyGroups;                                         // 0x00F8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           AllowedKeys;                                       // 0x0108(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           DisallowedKeys;                                    // 0x0118(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           BindingEscapeKeys;                                 // 0x0128(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         MouseMoveCaptureDistance;                          // 0x0138(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAxisAssociation>               AxisAssociations;                                  // 0x0140(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class FText GetKeyFriendlyNameStatic(const struct FKey& Key);
	static struct FGameplayTag GetKeyGroupStatic(const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoSettingsConfig">();
	}
	static class UAutoSettingsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoSettingsConfig>();
	}
};
static_assert(alignof(UAutoSettingsConfig) == 0x000008, "Wrong alignment on UAutoSettingsConfig");
static_assert(sizeof(UAutoSettingsConfig) == 0x000150, "Wrong size on UAutoSettingsConfig");
static_assert(offsetof(UAutoSettingsConfig, bAutoInitializePlayerInputOverrides) == 0x000028, "Member 'UAutoSettingsConfig::bAutoInitializePlayerInputOverrides' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, AllowModifierKeys) == 0x000029, "Member 'UAutoSettingsConfig::AllowModifierKeys' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, ShiftModifierOverrideText) == 0x000030, "Member 'UAutoSettingsConfig::ShiftModifierOverrideText' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, CtrlModifierOverrideText) == 0x000048, "Member 'UAutoSettingsConfig::CtrlModifierOverrideText' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, AltModifierOverrideText) == 0x000060, "Member 'UAutoSettingsConfig::AltModifierOverrideText' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, CmdModifierOverrideText) == 0x000078, "Member 'UAutoSettingsConfig::CmdModifierOverrideText' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, InputPresets) == 0x000090, "Member 'UAutoSettingsConfig::InputPresets' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, AllowMultipleBindingsPerKey) == 0x0000A0, "Member 'UAutoSettingsConfig::AllowMultipleBindingsPerKey' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, MappingGroupLinks) == 0x0000A8, "Member 'UAutoSettingsConfig::MappingGroupLinks' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, BlacklistedActions) == 0x0000B8, "Member 'UAutoSettingsConfig::BlacklistedActions' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, BlacklistedAxes) == 0x0000C8, "Member 'UAutoSettingsConfig::BlacklistedAxes' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, KeyIconSets) == 0x0000D8, "Member 'UAutoSettingsConfig::KeyIconSets' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, KeyFriendlyNames) == 0x0000E8, "Member 'UAutoSettingsConfig::KeyFriendlyNames' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, KeyGroups) == 0x0000F8, "Member 'UAutoSettingsConfig::KeyGroups' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, AllowedKeys) == 0x000108, "Member 'UAutoSettingsConfig::AllowedKeys' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, DisallowedKeys) == 0x000118, "Member 'UAutoSettingsConfig::DisallowedKeys' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, BindingEscapeKeys) == 0x000128, "Member 'UAutoSettingsConfig::BindingEscapeKeys' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, MouseMoveCaptureDistance) == 0x000138, "Member 'UAutoSettingsConfig::MouseMoveCaptureDistance' has a wrong offset!");
static_assert(offsetof(UAutoSettingsConfig, AxisAssociations) == 0x000140, "Member 'UAutoSettingsConfig::AxisAssociations' has a wrong offset!");

// Class AutoSettings.AutoSettingsPlayer
// 0x0000 (0x0000 - 0x0000)
class IAutoSettingsPlayer final
{
public:
	void SaveInputMappings(const struct FPlayerInputMappings& InputMappings);

	struct FInputMappingPreset GetDefaultInputMappingPreset() const;
	bool GetInputMappings(struct FPlayerInputMappings* InputMappings) const;
	class FString GetUniquePlayerIdentifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoSettingsPlayer">();
	}
	static class IAutoSettingsPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAutoSettingsPlayer>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAutoSettingsPlayer) == 0x000001, "Wrong alignment on IAutoSettingsPlayer");
static_assert(sizeof(IAutoSettingsPlayer) == 0x000001, "Wrong size on IAutoSettingsPlayer");

// Class AutoSettings.AxisLabel
// 0x0018 (0x0278 - 0x0260)
class UAxisLabel : public UInputLabel
{
public:
	class FName                                   AxisName;                                          // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UKeyLabel*                              KeyLabel;                                          // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxisLabel">();
	}
	static class UAxisLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxisLabel>();
	}
};
static_assert(alignof(UAxisLabel) == 0x000008, "Wrong alignment on UAxisLabel");
static_assert(sizeof(UAxisLabel) == 0x000278, "Wrong size on UAxisLabel");
static_assert(offsetof(UAxisLabel, AxisName) == 0x000260, "Member 'UAxisLabel::AxisName' has a wrong offset!");
static_assert(offsetof(UAxisLabel, Scale) == 0x000268, "Member 'UAxisLabel::Scale' has a wrong offset!");
static_assert(offsetof(UAxisLabel, KeyLabel) == 0x000270, "Member 'UAxisLabel::KeyLabel' has a wrong offset!");

// Class AutoSettings.AxisMapping
// 0x0018 (0x0280 - 0x0268)
class UAxisMapping : public UInputMapping
{
public:
	class FName                                   AxisName;                                          // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAxisLabel*                             AxisLabel;                                         // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxisMapping">();
	}
	static class UAxisMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxisMapping>();
	}
};
static_assert(alignof(UAxisMapping) == 0x000008, "Wrong alignment on UAxisMapping");
static_assert(sizeof(UAxisMapping) == 0x000280, "Wrong size on UAxisMapping");
static_assert(offsetof(UAxisMapping, AxisName) == 0x000268, "Member 'UAxisMapping::AxisName' has a wrong offset!");
static_assert(offsetof(UAxisMapping, Scale) == 0x000270, "Member 'UAxisMapping::Scale' has a wrong offset!");
static_assert(offsetof(UAxisMapping, AxisLabel) == 0x000278, "Member 'UAxisMapping::AxisLabel' has a wrong offset!");

// Class AutoSettings.BindCaptureButton
// 0x0030 (0x0260 - 0x0230)
class UBindCaptureButton : public UUserWidget
{
public:
	struct FGameplayTag                           KeyGroup;                                          // 0x0230(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBindCapturePrompt>         BindCapturePromptClass;                            // 0x0238(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CapturePromptZOrder;                               // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x14];                                     // 0x0244(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UBindCapturePrompt*                     Prompt;                                            // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChordCaptured(const struct FInputChord& Chord);
	void InitializePrompt(class UBindCapturePrompt* PromptWidget);
	class UBindCapturePrompt* StartCapture();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BindCaptureButton">();
	}
	static class UBindCaptureButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBindCaptureButton>();
	}
};
static_assert(alignof(UBindCaptureButton) == 0x000008, "Wrong alignment on UBindCaptureButton");
static_assert(sizeof(UBindCaptureButton) == 0x000260, "Wrong size on UBindCaptureButton");
static_assert(offsetof(UBindCaptureButton, KeyGroup) == 0x000230, "Member 'UBindCaptureButton::KeyGroup' has a wrong offset!");
static_assert(offsetof(UBindCaptureButton, BindCapturePromptClass) == 0x000238, "Member 'UBindCaptureButton::BindCapturePromptClass' has a wrong offset!");
static_assert(offsetof(UBindCaptureButton, CapturePromptZOrder) == 0x000240, "Member 'UBindCaptureButton::CapturePromptZOrder' has a wrong offset!");
static_assert(offsetof(UBindCaptureButton, Prompt) == 0x000258, "Member 'UBindCaptureButton::Prompt' has a wrong offset!");

// Class AutoSettings.BindCapturePrompt
// 0x0060 (0x0290 - 0x0230)
class UBindCapturePrompt : public UUserWidget
{
public:
	bool                                          bIgnoreGameViewportInputWhileCapturing;            // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictKeyGroup;                                 // 0x0231(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBindingCaptureMode                           CaptureMode;                                       // 0x0232(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233[0x1];                                      // 0x0233(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           KeyGroup;                                          // 0x0234(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FInputChord& CapturedChord)> OnChordCaptured;         // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FInputChord& CapturedChord)> OnChordRejected;         // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bWasCancelled)> OnCapturePromptClosed;                        // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           KeysDown;                                          // 0x0270(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          PreviousIgnoreInput;                               // 0x0280(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AccumulatedMouseDelta;                             // 0x0284(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	bool IsKeyAllowed(const struct FKey& PrimaryKey);

	struct FGameplayTag GetKeyGroup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BindCapturePrompt">();
	}
	static class UBindCapturePrompt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBindCapturePrompt>();
	}
};
static_assert(alignof(UBindCapturePrompt) == 0x000008, "Wrong alignment on UBindCapturePrompt");
static_assert(sizeof(UBindCapturePrompt) == 0x000290, "Wrong size on UBindCapturePrompt");
static_assert(offsetof(UBindCapturePrompt, bIgnoreGameViewportInputWhileCapturing) == 0x000230, "Member 'UBindCapturePrompt::bIgnoreGameViewportInputWhileCapturing' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, bRestrictKeyGroup) == 0x000231, "Member 'UBindCapturePrompt::bRestrictKeyGroup' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, CaptureMode) == 0x000232, "Member 'UBindCapturePrompt::CaptureMode' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, KeyGroup) == 0x000234, "Member 'UBindCapturePrompt::KeyGroup' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, OnChordCaptured) == 0x000240, "Member 'UBindCapturePrompt::OnChordCaptured' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, OnChordRejected) == 0x000250, "Member 'UBindCapturePrompt::OnChordRejected' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, OnCapturePromptClosed) == 0x000260, "Member 'UBindCapturePrompt::OnCapturePromptClosed' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, KeysDown) == 0x000270, "Member 'UBindCapturePrompt::KeysDown' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, PreviousIgnoreInput) == 0x000280, "Member 'UBindCapturePrompt::PreviousIgnoreInput' has a wrong offset!");
static_assert(offsetof(UBindCapturePrompt, AccumulatedMouseDelta) == 0x000284, "Member 'UBindCapturePrompt::AccumulatedMouseDelta' has a wrong offset!");

// Class AutoSettings.ToggleSetting
// 0x0000 (0x0280 - 0x0280)
class UToggleSetting : public UAutoSettingWidget
{
public:
	void ToggleStateUpdated(bool State);
	void UpdateToggleState(bool State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleSetting">();
	}
	static class UToggleSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToggleSetting>();
	}
};
static_assert(alignof(UToggleSetting) == 0x000008, "Wrong alignment on UToggleSetting");
static_assert(sizeof(UToggleSetting) == 0x000280, "Wrong size on UToggleSetting");

// Class AutoSettings.CheckBoxSetting
// 0x0008 (0x0288 - 0x0280)
class UCheckBoxSetting : public UToggleSetting
{
public:
	class UCheckBox*                              CheckBox;                                          // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckBoxStateChanged(bool IsChecked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckBoxSetting">();
	}
	static class UCheckBoxSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckBoxSetting>();
	}
};
static_assert(alignof(UCheckBoxSetting) == 0x000008, "Wrong alignment on UCheckBoxSetting");
static_assert(sizeof(UCheckBoxSetting) == 0x000288, "Wrong size on UCheckBoxSetting");
static_assert(offsetof(UCheckBoxSetting, CheckBox) == 0x000280, "Member 'UCheckBoxSetting::CheckBox' has a wrong offset!");

// Class AutoSettings.SelectSetting
// 0x0020 (0x02A0 - 0x0280)
class USelectSetting : public UAutoSettingWidget
{
public:
	TArray<struct FSettingOption>                 Options;                                           // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class USettingOptionFactory>      OptionFactory;                                     // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdatingSettingOptions;                           // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateOptions(const TArray<struct FSettingOption>& InOptions);

	struct FSettingOption GetOptionByLabel(const class FText& Label) const;
	struct FSettingOption GetOptionByValue(const class FString& Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectSetting">();
	}
	static class USelectSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectSetting>();
	}
};
static_assert(alignof(USelectSetting) == 0x000008, "Wrong alignment on USelectSetting");
static_assert(sizeof(USelectSetting) == 0x0002A0, "Wrong size on USelectSetting");
static_assert(offsetof(USelectSetting, Options) == 0x000280, "Member 'USelectSetting::Options' has a wrong offset!");
static_assert(offsetof(USelectSetting, OptionFactory) == 0x000290, "Member 'USelectSetting::OptionFactory' has a wrong offset!");
static_assert(offsetof(USelectSetting, bUpdatingSettingOptions) == 0x000298, "Member 'USelectSetting::bUpdatingSettingOptions' has a wrong offset!");

// Class AutoSettings.ComboBoxSetting
// 0x0010 (0x02B0 - 0x02A0)
class UComboBoxSetting : public USelectSetting
{
public:
	bool                                          bRefreshOnCultureChange;                           // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UComboBoxString*                        ComboBox;                                          // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ComboBoxSelectionChanged(const class FString& SelectedItem, ESelectInfo SelectionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboBoxSetting">();
	}
	static class UComboBoxSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboBoxSetting>();
	}
};
static_assert(alignof(UComboBoxSetting) == 0x000008, "Wrong alignment on UComboBoxSetting");
static_assert(sizeof(UComboBoxSetting) == 0x0002B0, "Wrong size on UComboBoxSetting");
static_assert(offsetof(UComboBoxSetting, bRefreshOnCultureChange) == 0x0002A0, "Member 'UComboBoxSetting::bRefreshOnCultureChange' has a wrong offset!");
static_assert(offsetof(UComboBoxSetting, ComboBox) == 0x0002A8, "Member 'UComboBoxSetting::ComboBox' has a wrong offset!");

// Class AutoSettings.ConsoleUtils
// 0x0000 (0x0028 - 0x0028)
class UConsoleUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool GetBoolCVar(class FName Name_0);
	static float GetFloatCVar(class FName Name_0);
	static int32 GetIntCVar(class FName Name_0);
	static class FString GetStringCVar(class FName Name_0);
	static bool IsCVarRegistered(class FName Name_0);
	static void SetBoolCVar(class FName Name_0, bool Value);
	static void SetFloatCVar(class FName Name_0, float Value);
	static void SetIntCVar(class FName Name_0, int32 Value);
	static void SetStringCVar(class FName Name_0, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleUtils">();
	}
	static class UConsoleUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleUtils>();
	}
};
static_assert(alignof(UConsoleUtils) == 0x000008, "Wrong alignment on UConsoleUtils");
static_assert(sizeof(UConsoleUtils) == 0x000028, "Wrong size on UConsoleUtils");

// Class AutoSettings.CVarChangeListener
// 0x0058 (0x0080 - 0x0028)
class UCVarChangeListener final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CVarChangeListener">();
	}
	static class UCVarChangeListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCVarChangeListener>();
	}
};
static_assert(alignof(UCVarChangeListener) == 0x000008, "Wrong alignment on UCVarChangeListener");
static_assert(sizeof(UCVarChangeListener) == 0x000080, "Wrong size on UCVarChangeListener");

// Class AutoSettings.CVarChangeListenerManager
// 0x0050 (0x0078 - 0x0028)
class UCVarChangeListenerManager final : public UObject
{
public:
	TMap<class FName, class UCVarChangeListener*> Listeners;                                         // 0x0028(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static void AddBoolCVarCallbackStatic(class FName Name_0, TDelegate<void(bool NewValue)> ChangedCallback, bool CallbackImmediately);
	static void AddFloatCVarCallbackStatic(class FName Name_0, TDelegate<void(float NewValue)> ChangedCallback, bool CallbackImmediately);
	static void AddIntCVarCallbackStatic(class FName Name_0, TDelegate<void(int32 NewValue)> ChangedCallback, bool CallbackImmediately);
	static void AddStringCVarCallbackStatic(class FName Name_0, TDelegate<void(const class FString& NewValue)> ChangedCallback, bool CallbackImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CVarChangeListenerManager">();
	}
	static class UCVarChangeListenerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCVarChangeListenerManager>();
	}
};
static_assert(alignof(UCVarChangeListenerManager) == 0x000008, "Wrong alignment on UCVarChangeListenerManager");
static_assert(sizeof(UCVarChangeListenerManager) == 0x000078, "Wrong size on UCVarChangeListenerManager");
static_assert(offsetof(UCVarChangeListenerManager, Listeners) == 0x000028, "Member 'UCVarChangeListenerManager::Listeners' has a wrong offset!");

// Class AutoSettings.GlobalKeyIconTagManager
// 0x0030 (0x0058 - 0x0028)
class UGlobalKeyIconTagManager final : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnGlobalKeyIconTagsModified;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GlobalKeyIconTags;                                 // 0x0038(0x0020)(NativeAccessSpecifierPrivate)

public:
	static class UTexture* GetIconForKey(const struct FKey& InKey, const struct FGameplayTagContainer& IconTags);
	static void SetGlobalKeyIconTags(const struct FGameplayTagContainer& InGlobalIconTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalKeyIconTagManager">();
	}
	static class UGlobalKeyIconTagManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalKeyIconTagManager>();
	}
};
static_assert(alignof(UGlobalKeyIconTagManager) == 0x000008, "Wrong alignment on UGlobalKeyIconTagManager");
static_assert(sizeof(UGlobalKeyIconTagManager) == 0x000058, "Wrong size on UGlobalKeyIconTagManager");
static_assert(offsetof(UGlobalKeyIconTagManager, OnGlobalKeyIconTagsModified) == 0x000028, "Member 'UGlobalKeyIconTagManager::OnGlobalKeyIconTagsModified' has a wrong offset!");
static_assert(offsetof(UGlobalKeyIconTagManager, GlobalKeyIconTags) == 0x000038, "Member 'UGlobalKeyIconTagManager::GlobalKeyIconTags' has a wrong offset!");

// Class AutoSettings.InputMappingManager
// 0x0038 (0x0060 - 0x0028)
class UInputMappingManager final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerInputMappings>           PlayerInputOverrides;                              // 0x0040(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<class APlayerController*>              RegisteredPlayerControllers;                       // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static void AddPlayerActionOverrideStatic(class APlayerController* Player, const struct FInputActionKeyMapping& NewMapping, int32 MappingGroup, bool bAnyKeyGroup);
	static void AddPlayerAxisOverrideStatic(class APlayerController* Player, const struct FInputAxisKeyMapping& NewMapping, int32 MappingGroup, bool bAnyKeyGroup);
	static TArray<struct FInputMappingPreset> GetDefaultInputPresets();
	static struct FInputActionKeyMapping GetPlayerActionMappingStatic(class APlayerController* Player, class FName ActionName, int32 MappingGroup);
	static struct FInputAxisKeyMapping GetPlayerAxisMappingStatic(class APlayerController* Player, class FName AxisName, float Scale, int32 MappingGroup);
	static struct FPlayerInputMappings GetPlayerInputMappingsStatic(class APlayerController* Player);
	static struct FGameplayTag GetPlayerKeyGroupStatic(class APlayerController* Player);
	static bool InitializePlayerInputOverridesStatic(class APlayerController* Player);
	static void SetPlayerInputPresetByTag(class APlayerController* Player, const struct FGameplayTag& PresetTag);
	static void SetPlayerInputPresetStatic(class APlayerController* Player, const struct FInputMappingPreset& Preset, bool bIsCustomized);
	static void SetPlayerKeyGroupStatic(class APlayerController* Player, const struct FGameplayTag& KeyGroup);

	void AddPlayerActionOverride(class APlayerController* Player, const struct FInputActionKeyMapping& NewMapping, int32 MappingGroup, bool bAnyKeyGroup);
	void AddPlayerAxisOverride(class APlayerController* Player, const struct FInputAxisKeyMapping& NewMapping, int32 MappingGroup, bool bAnyKeyGroup);
	void OnRegisteredPlayerControllerDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputMappingManager">();
	}
	static class UInputMappingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputMappingManager>();
	}
};
static_assert(alignof(UInputMappingManager) == 0x000008, "Wrong alignment on UInputMappingManager");
static_assert(sizeof(UInputMappingManager) == 0x000060, "Wrong size on UInputMappingManager");
static_assert(offsetof(UInputMappingManager, PlayerInputOverrides) == 0x000040, "Member 'UInputMappingManager::PlayerInputOverrides' has a wrong offset!");
static_assert(offsetof(UInputMappingManager, RegisteredPlayerControllers) == 0x000050, "Member 'UInputMappingManager::RegisteredPlayerControllers' has a wrong offset!");

// Class AutoSettings.KeyLabel
// 0x0068 (0x0298 - 0x0230)
class UKeyLabel : public UUserWidget
{
public:
	class FText                                   KeyInvalidText;                                    // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LabelOverride;                                     // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IconTags;                                          // 0x0278(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnGlobalKeyIconTagsModified();
	void UpdateKeyLabel();

	class FText GetDisplayName() const;
	ESlateVisibility GetDisplayNameVisibility() const;
	class UTexture* GetIcon() const;
	struct FSlateBrush GetIconBrush() const;
	ESlateVisibility GetIconVisibility() const;
	bool HasIcon() const;
	bool HasValidKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyLabel">();
	}
	static class UKeyLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyLabel>();
	}
};
static_assert(alignof(UKeyLabel) == 0x000008, "Wrong alignment on UKeyLabel");
static_assert(sizeof(UKeyLabel) == 0x000298, "Wrong size on UKeyLabel");
static_assert(offsetof(UKeyLabel, KeyInvalidText) == 0x000230, "Member 'UKeyLabel::KeyInvalidText' has a wrong offset!");
static_assert(offsetof(UKeyLabel, LabelOverride) == 0x000248, "Member 'UKeyLabel::LabelOverride' has a wrong offset!");
static_assert(offsetof(UKeyLabel, Key) == 0x000260, "Member 'UKeyLabel::Key' has a wrong offset!");
static_assert(offsetof(UKeyLabel, IconTags) == 0x000278, "Member 'UKeyLabel::IconTags' has a wrong offset!");

// Class AutoSettings.SliderSetting
// 0x0008 (0x0288 - 0x0280)
class USliderSetting : public UAutoSettingWidget
{
public:
	float                                         LeftValue;                                         // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightValue;                                        // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSliderValueUpdated(float NormalizedValue, float RawValue);
	void SliderValueUpdated(float NormalizedValue);
	void UpdateSliderValue(float NormalizedValue, float RawValue);

	bool ShouldSaveCurrentValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SliderSetting">();
	}
	static class USliderSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<USliderSetting>();
	}
};
static_assert(alignof(USliderSetting) == 0x000008, "Wrong alignment on USliderSetting");
static_assert(sizeof(USliderSetting) == 0x000288, "Wrong size on USliderSetting");
static_assert(offsetof(USliderSetting, LeftValue) == 0x000280, "Member 'USliderSetting::LeftValue' has a wrong offset!");
static_assert(offsetof(USliderSetting, RightValue) == 0x000284, "Member 'USliderSetting::RightValue' has a wrong offset!");

// Class AutoSettings.NativeSliderSetting
// 0x0010 (0x0298 - 0x0288)
class UNativeSliderSetting : public USliderSetting
{
public:
	class USlider*                                Slider;                                            // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMouseCaptureInProgress;                           // 0x0290(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SliderMouseCaptureBegin();
	void SliderMouseCaptureEnd();
	void SliderValueChanged(float NewValue);
	void UpdateSliderAndText(float RawValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NativeSliderSetting">();
	}
	static class UNativeSliderSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNativeSliderSetting>();
	}
};
static_assert(alignof(UNativeSliderSetting) == 0x000008, "Wrong alignment on UNativeSliderSetting");
static_assert(sizeof(UNativeSliderSetting) == 0x000298, "Wrong size on UNativeSliderSetting");
static_assert(offsetof(UNativeSliderSetting, Slider) == 0x000288, "Member 'UNativeSliderSetting::Slider' has a wrong offset!");
static_assert(offsetof(UNativeSliderSetting, bMouseCaptureInProgress) == 0x000290, "Member 'UNativeSliderSetting::bMouseCaptureInProgress' has a wrong offset!");

// Class AutoSettings.RadioButton
// 0x0040 (0x0270 - 0x0230)
class URadioButton final : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(const class FString& Value)> OnSelected;                           // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x0240(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class FString                                 Value;                                             // 0x0258(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Selected;                                          // 0x0268(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLabel(const class FText& InLabel);
	void SetSelected(bool InSelected);
	void SetValue(const class FString& InValue);
	void TriggerSelection();
	void UpdateLabel(const class FText& InLabel);
	void UpdateSelected(bool InSelected);

	class FText GetLabel() const;
	bool GetSelected() const;
	class FString GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadioButton">();
	}
	static class URadioButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadioButton>();
	}
};
static_assert(alignof(URadioButton) == 0x000008, "Wrong alignment on URadioButton");
static_assert(sizeof(URadioButton) == 0x000270, "Wrong size on URadioButton");
static_assert(offsetof(URadioButton, OnSelected) == 0x000230, "Member 'URadioButton::OnSelected' has a wrong offset!");
static_assert(offsetof(URadioButton, Label) == 0x000240, "Member 'URadioButton::Label' has a wrong offset!");
static_assert(offsetof(URadioButton, Value) == 0x000258, "Member 'URadioButton::Value' has a wrong offset!");
static_assert(offsetof(URadioButton, Selected) == 0x000268, "Member 'URadioButton::Selected' has a wrong offset!");

// Class AutoSettings.RadioSelect
// 0x0040 (0x0270 - 0x0230)
class URadioSelect final : public UUserWidget
{
public:
	TArray<struct FSettingOption>                 Options;                                           // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class URadioButton>               RadioButtonClass;                                  // 0x0240(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value)> SelectionChangedEvent;                // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPanelWidget*                           ButtonContainer;                                   // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URadioButton*>                   RadioButtons;                                      // 0x0260(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void ButtonSelected(const class FString& Value);
	void Select(const class FString& Value);
	void SetOptions(const TArray<struct FSettingOption>& InOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadioSelect">();
	}
	static class URadioSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadioSelect>();
	}
};
static_assert(alignof(URadioSelect) == 0x000008, "Wrong alignment on URadioSelect");
static_assert(sizeof(URadioSelect) == 0x000270, "Wrong size on URadioSelect");
static_assert(offsetof(URadioSelect, Options) == 0x000230, "Member 'URadioSelect::Options' has a wrong offset!");
static_assert(offsetof(URadioSelect, RadioButtonClass) == 0x000240, "Member 'URadioSelect::RadioButtonClass' has a wrong offset!");
static_assert(offsetof(URadioSelect, SelectionChangedEvent) == 0x000248, "Member 'URadioSelect::SelectionChangedEvent' has a wrong offset!");
static_assert(offsetof(URadioSelect, ButtonContainer) == 0x000258, "Member 'URadioSelect::ButtonContainer' has a wrong offset!");
static_assert(offsetof(URadioSelect, RadioButtons) == 0x000260, "Member 'URadioSelect::RadioButtons' has a wrong offset!");

// Class AutoSettings.RadioSelectSetting
// 0x0010 (0x02B0 - 0x02A0)
class URadioSelectSetting final : public USelectSetting
{
public:
	TSubclassOf<class URadioButton>               RadioButtonClass;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URadioSelect*                           RadioSelect;                                       // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RadioSelectionChanged(const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadioSelectSetting">();
	}
	static class URadioSelectSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadioSelectSetting>();
	}
};
static_assert(alignof(URadioSelectSetting) == 0x000008, "Wrong alignment on URadioSelectSetting");
static_assert(sizeof(URadioSelectSetting) == 0x0002B0, "Wrong size on URadioSelectSetting");
static_assert(offsetof(URadioSelectSetting, RadioButtonClass) == 0x0002A0, "Member 'URadioSelectSetting::RadioButtonClass' has a wrong offset!");
static_assert(offsetof(URadioSelectSetting, RadioSelect) == 0x0002A8, "Member 'URadioSelectSetting::RadioSelect' has a wrong offset!");

// Class AutoSettings.SettingOptionFactory
// 0x0000 (0x0028 - 0x0028)
class USettingOptionFactory : public UObject
{
public:
	TArray<struct FSettingOption> ConstructOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingOptionFactory">();
	}
	static class USettingOptionFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingOptionFactory>();
	}
};
static_assert(alignof(USettingOptionFactory) == 0x000008, "Wrong alignment on USettingOptionFactory");
static_assert(sizeof(USettingOptionFactory) == 0x000028, "Wrong size on USettingOptionFactory");

// Class AutoSettings.ResolutionOptionFactory
// 0x0000 (0x0028 - 0x0028)
class UResolutionOptionFactory final : public USettingOptionFactory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResolutionOptionFactory">();
	}
	static class UResolutionOptionFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResolutionOptionFactory>();
	}
};
static_assert(alignof(UResolutionOptionFactory) == 0x000008, "Wrong alignment on UResolutionOptionFactory");
static_assert(sizeof(UResolutionOptionFactory) == 0x000028, "Wrong size on UResolutionOptionFactory");

// Class AutoSettings.ResolutionStringUtils
// 0x0000 (0x0028 - 0x0028)
class UResolutionStringUtils final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResolutionStringUtils">();
	}
	static class UResolutionStringUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResolutionStringUtils>();
	}
};
static_assert(alignof(UResolutionStringUtils) == 0x000008, "Wrong alignment on UResolutionStringUtils");
static_assert(sizeof(UResolutionStringUtils) == 0x000028, "Wrong size on UResolutionStringUtils");

// Class AutoSettings.SettingValueMask
// 0x0000 (0x0028 - 0x0028)
class USettingValueMask : public UObject
{
public:
	class FString MaskValue(const class FString& ConsoleValue) const;
	class FString RecombineValues(const class FString& SettingValue, const class FString& ConsoleValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingValueMask">();
	}
	static class USettingValueMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingValueMask>();
	}
};
static_assert(alignof(USettingValueMask) == 0x000008, "Wrong alignment on USettingValueMask");
static_assert(sizeof(USettingValueMask) == 0x000028, "Wrong size on USettingValueMask");

// Class AutoSettings.ResolutionValueMask
// 0x0000 (0x0028 - 0x0028)
class UResolutionValueMask final : public USettingValueMask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResolutionValueMask">();
	}
	static class UResolutionValueMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResolutionValueMask>();
	}
};
static_assert(alignof(UResolutionValueMask) == 0x000008, "Wrong alignment on UResolutionValueMask");
static_assert(sizeof(UResolutionValueMask) == 0x000028, "Wrong size on UResolutionValueMask");

// Class AutoSettings.SettingContainerUtils
// 0x0000 (0x0028 - 0x0028)
class USettingContainerUtils final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyChildSettings(class UUserWidget* UserWidget, class UWidget* Parent);
	static void CancelChildSettings(class UUserWidget* UserWidget, class UWidget* Parent);
	static bool DoesAnyChildSettingHaveUnappliedChange(class UUserWidget* UserWidget, class UWidget* Parent);
	static bool DoesAnyChildSettingHaveUnsavedChange(class UUserWidget* UserWidget, class UWidget* Parent);
	static TArray<class UAutoSettingWidget*> GetChildSettings(class UUserWidget* UserWidget, class UWidget* Parent);
	static void SaveChildSettings(class UUserWidget* UserWidget, class UWidget* Parent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingContainerUtils">();
	}
	static class USettingContainerUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingContainerUtils>();
	}
};
static_assert(alignof(USettingContainerUtils) == 0x000008, "Wrong alignment on USettingContainerUtils");
static_assert(sizeof(USettingContainerUtils) == 0x000028, "Wrong size on USettingContainerUtils");

// Class AutoSettings.SettingsManager
// 0x0040 (0x0068 - 0x0028)
class USettingsManager final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FAutoSettingData& SettingData)> OnSettingSaved;       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 IniName;                                           // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 IniFilename;                                       // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SectionName;                                       // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void ApplySettingStatic(const struct FAutoSettingData& SettingData);
	static void AutoDetectSettingsStatic();
	static class FString GetInitialValue(class FName Key);
	static class FString GetValue(class FName Key, bool bPreferConfigValue);
	static void RegisterBoolCVarSetting(class FName Name_0, bool DefaultValue, const class FString& Help);
	static void RegisterBoolCVarSettingWithCallback(class FName Name_0, bool DefaultValue, const class FString& Help, TDelegate<void(bool NewValue)> ChangedCallback, bool CallbackImmediately);
	static void RegisterFloatCVarSetting(class FName Name_0, float DefaultValue, const class FString& Help);
	static void RegisterFloatCVarSettingWithCallback(class FName Name_0, float DefaultValue, const class FString& Help, TDelegate<void(float NewValue)> ChangedCallback, bool CallbackImmediately);
	static void RegisterIntCVarSetting(class FName Name_0, int32 DefaultValue, const class FString& Help);
	static void RegisterIntCVarSettingWithCallback(class FName Name_0, int32 DefaultValue, const class FString& Help, TDelegate<void(int32 NewValue)> ChangedCallback, bool CallbackImmediately);
	static void RegisterStringCVarSetting(class FName Name_0, const class FString& DefaultValue, const class FString& Help);
	static void RegisterStringCVarSettingWithCallback(class FName Name_0, const class FString& DefaultValue, const class FString& Help, TDelegate<void(const class FString& NewValue)> ChangedCallback, bool CallbackImmediately);
	static void SaveSettingStatic(const struct FAutoSettingData& SettingData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsManager">();
	}
	static class USettingsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsManager>();
	}
};
static_assert(alignof(USettingsManager) == 0x000008, "Wrong alignment on USettingsManager");
static_assert(sizeof(USettingsManager) == 0x000068, "Wrong size on USettingsManager");
static_assert(offsetof(USettingsManager, OnSettingSaved) == 0x000028, "Member 'USettingsManager::OnSettingSaved' has a wrong offset!");
static_assert(offsetof(USettingsManager, IniName) == 0x000038, "Member 'USettingsManager::IniName' has a wrong offset!");
static_assert(offsetof(USettingsManager, IniFilename) == 0x000048, "Member 'USettingsManager::IniFilename' has a wrong offset!");
static_assert(offsetof(USettingsManager, SectionName) == 0x000058, "Member 'USettingsManager::SectionName' has a wrong offset!");

// Class AutoSettings.Spinner
// 0x0030 (0x0260 - 0x0230)
class USpinner : public UUserWidget
{
public:
	TArray<struct FSettingOption>                 Options;                                           // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllowWrapping;                                    // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& Value)> SelectionChangedEvent;                // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Next();
	void Previous();
	void SelectIndex(int32 Index_0);
	void SelectValue(const class FString& Value);

	int32 GetCurrentIndex() const;
	struct FSettingOption GetCurrentOption() const;
	bool HasValidNext() const;
	bool HasValidPrevious() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Spinner">();
	}
	static class USpinner* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpinner>();
	}
};
static_assert(alignof(USpinner) == 0x000008, "Wrong alignment on USpinner");
static_assert(sizeof(USpinner) == 0x000260, "Wrong size on USpinner");
static_assert(offsetof(USpinner, Options) == 0x000230, "Member 'USpinner::Options' has a wrong offset!");
static_assert(offsetof(USpinner, bAllowWrapping) == 0x000240, "Member 'USpinner::bAllowWrapping' has a wrong offset!");
static_assert(offsetof(USpinner, SelectionChangedEvent) == 0x000248, "Member 'USpinner::SelectionChangedEvent' has a wrong offset!");

// Class AutoSettings.SpinnerSetting
// 0x0008 (0x02A8 - 0x02A0)
class USpinnerSetting : public USelectSetting
{
public:
	class USpinner*                               Spinner;                                           // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SpinnerSelectionChanged(const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpinnerSetting">();
	}
	static class USpinnerSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpinnerSetting>();
	}
};
static_assert(alignof(USpinnerSetting) == 0x000008, "Wrong alignment on USpinnerSetting");
static_assert(sizeof(USpinnerSetting) == 0x0002A8, "Wrong size on USpinnerSetting");
static_assert(offsetof(USpinnerSetting, Spinner) == 0x0002A0, "Member 'USpinnerSetting::Spinner' has a wrong offset!");

// Class AutoSettings.WindowModeValueMask
// 0x0000 (0x0028 - 0x0028)
class UWindowModeValueMask final : public USettingValueMask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindowModeValueMask">();
	}
	static class UWindowModeValueMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWindowModeValueMask>();
	}
};
static_assert(alignof(UWindowModeValueMask) == 0x000008, "Wrong alignment on UWindowModeValueMask");
static_assert(sizeof(UWindowModeValueMask) == 0x000028, "Wrong size on UWindowModeValueMask");

}

