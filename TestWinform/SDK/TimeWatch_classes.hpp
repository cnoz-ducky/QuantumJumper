#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TimeWatch

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "TimeWatch_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "NGDUI_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "UnrealProject_structs.hpp"
#include "UnrealProject_classes.hpp"
#include "SlateCore_structs.hpp"
#include "NGDBackend_structs.hpp"
#include "AIModule_classes.hpp"
#include "AkAudio_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "GameplayTasks_classes.hpp"
#include "NGDOnlineService_classes.hpp"
#include "CinematicCamera_classes.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Class TimeWatch.TWItemDataAsset
// 0x0090 (0x00C0 - 0x0030)
class UTWItemDataAsset : public UDataAsset
{
public:
	TSoftObjectPtr<class UTexture2D>              RewardIcon;                                        // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RewardType;                                        // 0x0058(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             StoreIconLarge;                                    // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StoreIconSmall;                                    // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWItemDataAsset*                       RootItem;                                          // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DomainSKU;                                         // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GroupSKU;                                          // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugStoreState;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAvailableInOfflineMode;                           // 0x00AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SKU;                                               // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FText GetDisplayName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWItemDataAsset">();
	}
	static class UTWItemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWItemDataAsset>();
	}
};
static_assert(alignof(UTWItemDataAsset) == 0x000008, "Wrong alignment on UTWItemDataAsset");
static_assert(sizeof(UTWItemDataAsset) == 0x0000C0, "Wrong size on UTWItemDataAsset");
static_assert(offsetof(UTWItemDataAsset, RewardIcon) == 0x000030, "Member 'UTWItemDataAsset::RewardIcon' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, RewardType) == 0x000058, "Member 'UTWItemDataAsset::RewardType' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, StoreIconLarge) == 0x000070, "Member 'UTWItemDataAsset::StoreIconLarge' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, StoreIconSmall) == 0x000078, "Member 'UTWItemDataAsset::StoreIconSmall' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, RootItem) == 0x000080, "Member 'UTWItemDataAsset::RootItem' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, DomainSKU) == 0x000088, "Member 'UTWItemDataAsset::DomainSKU' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, GroupSKU) == 0x000098, "Member 'UTWItemDataAsset::GroupSKU' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, DebugStoreState) == 0x0000A8, "Member 'UTWItemDataAsset::DebugStoreState' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, bAvailableInOfflineMode) == 0x0000AC, "Member 'UTWItemDataAsset::bAvailableInOfflineMode' has a wrong offset!");
static_assert(offsetof(UTWItemDataAsset, SKU) == 0x0000B0, "Member 'UTWItemDataAsset::SKU' has a wrong offset!");

// Class TimeWatch.TWPlayerTitleDataAsset
// 0x0020 (0x00E0 - 0x00C0)
class UTWPlayerTitleDataAsset final : public UTWItemDataAsset
{
public:
	class FText                                   DisplayText;                                       // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsDevTitle;                                       // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlayerTitleDataAsset">();
	}
	static class UTWPlayerTitleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPlayerTitleDataAsset>();
	}
};
static_assert(alignof(UTWPlayerTitleDataAsset) == 0x000008, "Wrong alignment on UTWPlayerTitleDataAsset");
static_assert(sizeof(UTWPlayerTitleDataAsset) == 0x0000E0, "Wrong size on UTWPlayerTitleDataAsset");
static_assert(offsetof(UTWPlayerTitleDataAsset, DisplayText) == 0x0000C0, "Member 'UTWPlayerTitleDataAsset::DisplayText' has a wrong offset!");
static_assert(offsetof(UTWPlayerTitleDataAsset, bIsDevTitle) == 0x0000D8, "Member 'UTWPlayerTitleDataAsset::bIsDevTitle' has a wrong offset!");

// Class TimeWatch.HUDStatePlayerProfile
// 0x0000 (0x0268 - 0x0268)
class UHUDStatePlayerProfile : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStatePlayerProfile">();
	}
	static class UHUDStatePlayerProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStatePlayerProfile>();
	}
};
static_assert(alignof(UHUDStatePlayerProfile) == 0x000008, "Wrong alignment on UHUDStatePlayerProfile");
static_assert(sizeof(UHUDStatePlayerProfile) == 0x000268, "Wrong size on UHUDStatePlayerProfile");

// Class TimeWatch.TWGameplayAbilityTargetActor
// 0x0060 (0x0278 - 0x0218)
class ATWGameplayAbilityTargetActor : public AActor
{
public:
	TMulticastInlineDelegate<void(const struct FTWAbilityCustomDataHandle& OutDataHandle)> OnConfirmedDelegate; // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FTWAbilityCustomDataHandle& OutDataHandle)> OnCancelledDelegate; // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroyOnConfirm;                             // 0x0238(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWAbility*                             OwningAbility;                                     // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWGameplayTask*                        OwningTask;                                        // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTWAbilityCustomDataHandle             TargetData;                                        // 0x0250(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UTWAbilitiesComponent*                  CasterComp;                                        // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CancelTargeting();
	void ConfirmTargeting();
	void GenericAxisChanged(float NewValue);
	void OnGenericLocalCancel();
	void OnGenericLocalConfirm();
	void StartTargeting(class UTWAbility* Ability);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayAbilityTargetActor">();
	}
	static class ATWGameplayAbilityTargetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWGameplayAbilityTargetActor>();
	}
};
static_assert(alignof(ATWGameplayAbilityTargetActor) == 0x000008, "Wrong alignment on ATWGameplayAbilityTargetActor");
static_assert(sizeof(ATWGameplayAbilityTargetActor) == 0x000278, "Wrong size on ATWGameplayAbilityTargetActor");
static_assert(offsetof(ATWGameplayAbilityTargetActor, OnConfirmedDelegate) == 0x000218, "Member 'ATWGameplayAbilityTargetActor::OnConfirmedDelegate' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor, OnCancelledDelegate) == 0x000228, "Member 'ATWGameplayAbilityTargetActor::OnCancelledDelegate' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor, bAutoDestroyOnConfirm) == 0x000238, "Member 'ATWGameplayAbilityTargetActor::bAutoDestroyOnConfirm' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor, OwningAbility) == 0x000240, "Member 'ATWGameplayAbilityTargetActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor, OwningTask) == 0x000248, "Member 'ATWGameplayAbilityTargetActor::OwningTask' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor, TargetData) == 0x000250, "Member 'ATWGameplayAbilityTargetActor::TargetData' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor, CasterComp) == 0x000270, "Member 'ATWGameplayAbilityTargetActor::CasterComp' has a wrong offset!");

// Class TimeWatch.TWGameplayAbilityTargetActor_Projectile
// 0x0030 (0x02A8 - 0x0278)
class ATWGameplayAbilityTargetActor_Projectile final : public ATWGameplayAbilityTargetActor
{
public:
	TSubclassOf<class ATWPhysicalProjectile>      ProjectileClass;                                   // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            PlaceableActorMesh;                                // 0x0280(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaceableMeshOffset;                               // 0x0288(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATemporalWeapon*                        CurrentWeapon;                                     // 0x0298(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchSpeed;                                       // 0x02A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRadius;                                  // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayAbilityTargetActor_Projectile">();
	}
	static class ATWGameplayAbilityTargetActor_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWGameplayAbilityTargetActor_Projectile>();
	}
};
static_assert(alignof(ATWGameplayAbilityTargetActor_Projectile) == 0x000008, "Wrong alignment on ATWGameplayAbilityTargetActor_Projectile");
static_assert(sizeof(ATWGameplayAbilityTargetActor_Projectile) == 0x0002A8, "Wrong size on ATWGameplayAbilityTargetActor_Projectile");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Projectile, ProjectileClass) == 0x000278, "Member 'ATWGameplayAbilityTargetActor_Projectile::ProjectileClass' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Projectile, PlaceableActorMesh) == 0x000280, "Member 'ATWGameplayAbilityTargetActor_Projectile::PlaceableActorMesh' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Projectile, PlaceableMeshOffset) == 0x000288, "Member 'ATWGameplayAbilityTargetActor_Projectile::PlaceableMeshOffset' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Projectile, CurrentWeapon) == 0x000298, "Member 'ATWGameplayAbilityTargetActor_Projectile::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Projectile, LaunchSpeed) == 0x0002A0, "Member 'ATWGameplayAbilityTargetActor_Projectile::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Projectile, ProjectileRadius) == 0x0002A4, "Member 'ATWGameplayAbilityTargetActor_Projectile::ProjectileRadius' has a wrong offset!");

// Class TimeWatch.Tween
// 0x0038 (0x0060 - 0x0028)
class UTween final : public UObject
{
public:
	TMulticastInlineDelegate<void(float CurrentValue)> OnTweenTick;                                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnTweenFinished;                                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tween">();
	}
	static class UTween* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTween>();
	}
};
static_assert(alignof(UTween) == 0x000008, "Wrong alignment on UTween");
static_assert(sizeof(UTween) == 0x000060, "Wrong size on UTween");
static_assert(offsetof(UTween, OnTweenTick) == 0x000028, "Member 'UTween::OnTweenTick' has a wrong offset!");
static_assert(offsetof(UTween, OnTweenFinished) == 0x000038, "Member 'UTween::OnTweenFinished' has a wrong offset!");

// Class TimeWatch.HUDStatePlaySelection
// 0x0000 (0x0268 - 0x0268)
class UHUDStatePlaySelection : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStatePlaySelection">();
	}
	static class UHUDStatePlaySelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStatePlaySelection>();
	}
};
static_assert(alignof(UHUDStatePlaySelection) == 0x000008, "Wrong alignment on UHUDStatePlaySelection");
static_assert(sizeof(UHUDStatePlaySelection) == 0x000268, "Wrong size on UHUDStatePlaySelection");

// Class TimeWatch.Actuate
// 0x0010 (0x0228 - 0x0218)
class AActuate final : public AActor
{
public:
	TArray<class UTween*>                         Tweens;                                            // 0x0218(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class UTween* Animate(float InAnimDuration, float InInitialState, float InFinalState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Actuate">();
	}
	static class AActuate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActuate>();
	}
};
static_assert(alignof(AActuate) == 0x000008, "Wrong alignment on AActuate");
static_assert(sizeof(AActuate) == 0x000228, "Wrong size on AActuate");
static_assert(offsetof(AActuate, Tweens) == 0x000218, "Member 'AActuate::Tweens' has a wrong offset!");

// Class TimeWatch.TWGenericPopup
// 0x0508 (0x07C8 - 0x02C0)
class UTWGenericPopup : public UNGDGenericPopup
{
public:
	class URichTextBlock*                         RichTextBlock_Title;                               // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideConfirmButttonStyle;                      // 0x02C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           ConfirmButttonStyleOverride;                       // 0x02D0(0x0278)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideCancelButttonStyle;                       // 0x0548(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           CancelButttonStyleOverride;                        // 0x0550(0x0278)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGenericPopup">();
	}
	static class UTWGenericPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGenericPopup>();
	}
};
static_assert(alignof(UTWGenericPopup) == 0x000008, "Wrong alignment on UTWGenericPopup");
static_assert(sizeof(UTWGenericPopup) == 0x0007C8, "Wrong size on UTWGenericPopup");
static_assert(offsetof(UTWGenericPopup, RichTextBlock_Title) == 0x0002C0, "Member 'UTWGenericPopup::RichTextBlock_Title' has a wrong offset!");
static_assert(offsetof(UTWGenericPopup, bOverrideConfirmButttonStyle) == 0x0002C8, "Member 'UTWGenericPopup::bOverrideConfirmButttonStyle' has a wrong offset!");
static_assert(offsetof(UTWGenericPopup, ConfirmButttonStyleOverride) == 0x0002D0, "Member 'UTWGenericPopup::ConfirmButttonStyleOverride' has a wrong offset!");
static_assert(offsetof(UTWGenericPopup, bOverrideCancelButttonStyle) == 0x000548, "Member 'UTWGenericPopup::bOverrideCancelButttonStyle' has a wrong offset!");
static_assert(offsetof(UTWGenericPopup, CancelButttonStyleOverride) == 0x000550, "Member 'UTWGenericPopup::CancelButttonStyleOverride' has a wrong offset!");

// Class TimeWatch.HUDStateRedeemCode
// 0x0000 (0x0268 - 0x0268)
class UHUDStateRedeemCode : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateRedeemCode">();
	}
	static class UHUDStateRedeemCode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateRedeemCode>();
	}
};
static_assert(alignof(UHUDStateRedeemCode) == 0x000008, "Wrong alignment on UHUDStateRedeemCode");
static_assert(sizeof(UHUDStateRedeemCode) == 0x000268, "Wrong size on UHUDStateRedeemCode");

// Class TimeWatch.TWChallengeRuleData
// 0x0018 (0x0048 - 0x0030)
class UTWChallengeRuleData final : public UDataAsset
{
public:
	struct FTWChallengeRule                       Rule;                                              // 0x0030(0x0014)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWChallengeRuleData">();
	}
	static class UTWChallengeRuleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWChallengeRuleData>();
	}
};
static_assert(alignof(UTWChallengeRuleData) == 0x000008, "Wrong alignment on UTWChallengeRuleData");
static_assert(sizeof(UTWChallengeRuleData) == 0x000048, "Wrong size on UTWChallengeRuleData");
static_assert(offsetof(UTWChallengeRuleData, Rule) == 0x000030, "Member 'UTWChallengeRuleData::Rule' has a wrong offset!");

// Class TimeWatch.AutomaticTurretBase
// 0x0030 (0x0248 - 0x0218)
class AAutomaticTurretBase final : public AActor
{
public:
	class USceneComponent*                        MuzzleLocation;                                    // 0x0218(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          ShootTriggerArea;                                  // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATimeWatchProjectile>       ProjectileClass;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootCooldown;                                     // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATimeWatchCharacter*                    CurrentTarget;                                     // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCooldown;                                   // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShootTriggerOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnShootTriggerOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	float GetRelativeCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomaticTurretBase">();
	}
	static class AAutomaticTurretBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAutomaticTurretBase>();
	}
};
static_assert(alignof(AAutomaticTurretBase) == 0x000008, "Wrong alignment on AAutomaticTurretBase");
static_assert(sizeof(AAutomaticTurretBase) == 0x000248, "Wrong size on AAutomaticTurretBase");
static_assert(offsetof(AAutomaticTurretBase, MuzzleLocation) == 0x000218, "Member 'AAutomaticTurretBase::MuzzleLocation' has a wrong offset!");
static_assert(offsetof(AAutomaticTurretBase, ShootTriggerArea) == 0x000220, "Member 'AAutomaticTurretBase::ShootTriggerArea' has a wrong offset!");
static_assert(offsetof(AAutomaticTurretBase, ProjectileClass) == 0x000228, "Member 'AAutomaticTurretBase::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AAutomaticTurretBase, ShootCooldown) == 0x000230, "Member 'AAutomaticTurretBase::ShootCooldown' has a wrong offset!");
static_assert(offsetof(AAutomaticTurretBase, CurrentTarget) == 0x000238, "Member 'AAutomaticTurretBase::CurrentTarget' has a wrong offset!");
static_assert(offsetof(AAutomaticTurretBase, CurrentCooldown) == 0x000240, "Member 'AAutomaticTurretBase::CurrentCooldown' has a wrong offset!");

// Class TimeWatch.HUDStateRewardTrack
// 0x0000 (0x0268 - 0x0268)
class UHUDStateRewardTrack : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateRewardTrack">();
	}
	static class UHUDStateRewardTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateRewardTrack>();
	}
};
static_assert(alignof(UHUDStateRewardTrack) == 0x000008, "Wrong alignment on UHUDStateRewardTrack");
static_assert(sizeof(UHUDStateRewardTrack) == 0x000268, "Wrong size on UHUDStateRewardTrack");

// Class TimeWatch.TimeWatchGameModeBase
// 0x0048 (0x03F8 - 0x03B0)
class ATimeWatchGameModeBase : public ANGDGameMode
{
public:
	TSubclassOf<class ATimeWatchCharacter>        TWCharacterClass;                                  // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFluxCloneController>       CloneController;                                   // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFluxAIController>          FluxAIControllerClass;                             // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameEndedAutoCloseSeconds;                         // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x1C];                                     // 0x03DC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSeamlessTravelPlayerReady(class AFluxPlayerController* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchGameModeBase">();
	}
	static class ATimeWatchGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeWatchGameModeBase>();
	}
};
static_assert(alignof(ATimeWatchGameModeBase) == 0x000008, "Wrong alignment on ATimeWatchGameModeBase");
static_assert(sizeof(ATimeWatchGameModeBase) == 0x0003F8, "Wrong size on ATimeWatchGameModeBase");
static_assert(offsetof(ATimeWatchGameModeBase, TWCharacterClass) == 0x0003B0, "Member 'ATimeWatchGameModeBase::TWCharacterClass' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameModeBase, CloneController) == 0x0003B8, "Member 'ATimeWatchGameModeBase::CloneController' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameModeBase, FluxAIControllerClass) == 0x0003C0, "Member 'ATimeWatchGameModeBase::FluxAIControllerClass' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameModeBase, GameEndedAutoCloseSeconds) == 0x0003D8, "Member 'ATimeWatchGameModeBase::GameEndedAutoCloseSeconds' has a wrong offset!");

// Class TimeWatch.TimeWatchGameMode
// 0x0078 (0x0470 - 0x03F8)
class ATimeWatchGameMode : public ATimeWatchGameModeBase
{
public:
	uint8                                         Pad_3F8[0xC];                                      // 0x03F8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopCooldown;                                      // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloneCooldown;                                     // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GameCooldown;                                      // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UTimeWatchEvent>, struct FTWEventGameData> TWEventsGameData;              // 0x0410(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetScoreIncrement();
	void MatchResultUpdateCompleted(const class FString& MatchResultJsonString, bool bWasSuccessful, const class FString& ErrorString);
	void OnGameReadyCoolDownCompleted();
	void ProcessTWEvent(class UTimeWatchEvent* Event);
	void SetupNewPlayer(class APlayerController* NewPlayer);
	void SwitchToSpectatorMode(class APlayerController* Player);

	int32 GetScoringTeamID() const;
	class ATimeWatchGameState* GetTWGameState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchGameMode">();
	}
	static class ATimeWatchGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeWatchGameMode>();
	}
};
static_assert(alignof(ATimeWatchGameMode) == 0x000008, "Wrong alignment on ATimeWatchGameMode");
static_assert(sizeof(ATimeWatchGameMode) == 0x000470, "Wrong size on ATimeWatchGameMode");
static_assert(offsetof(ATimeWatchGameMode, LoopCooldown) == 0x000404, "Member 'ATimeWatchGameMode::LoopCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameMode, CloneCooldown) == 0x000408, "Member 'ATimeWatchGameMode::CloneCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameMode, GameCooldown) == 0x00040C, "Member 'ATimeWatchGameMode::GameCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameMode, TWEventsGameData) == 0x000410, "Member 'ATimeWatchGameMode::TWEventsGameData' has a wrong offset!");

// Class TimeWatch.BenchmarkGameMode
// 0x0000 (0x0470 - 0x0470)
class ABenchmarkGameMode final : public ATimeWatchGameMode
{
public:
	void BenchMarkEnd();
	void BenchMarkStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BenchmarkGameMode">();
	}
	static class ABenchmarkGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABenchmarkGameMode>();
	}
};
static_assert(alignof(ABenchmarkGameMode) == 0x000008, "Wrong alignment on ABenchmarkGameMode");
static_assert(sizeof(ABenchmarkGameMode) == 0x000470, "Wrong size on ABenchmarkGameMode");

// Class TimeWatch.TWGameplayAbilitySystem
// 0x0098 (0x0148 - 0x00B0)
class UTWGameplayAbilitySystem final : public UActorComponent
{
public:
	TArray<struct FTWAbilityCustomDataHandle>     ExecutionHistory;                                  // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWAbility*>                     AbilitiesInstances;                                // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWAbility*>                     AbilitiesToRestore;                                // 0x00D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWAbility*>                     PendingAbilitiesInstances;                         // 0x00E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ATimeWatchCharacter*, struct FAbilityCastTimestamp> LastCastTimestamp;                // 0x00F8(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static struct FTWAbilityCustomDataHandle AbilityCustomDataFromTargetActors(const TArray<class AActor*>& TargetActors);
	static struct FTWAbilityCustomDataHandle AbilityCustomDataFromVectors(const TArray<struct FVector>& InVectors);
	static bool CopyDataToHandle_TargetActors(struct FTWAbilityCustomDataHandle& InDataHandle, struct FTWAbilityCustomDataHandle* OutDataHandle, const struct FTWAbilityCustomData_TargetActors& InData);
	static bool CopyDataToHandle_Vectors(struct FTWAbilityCustomDataHandle& InDataHandle, struct FTWAbilityCustomDataHandle* OutDataHandle, const struct FTWAbilityCustomData_Vectors& InData);
	static bool GetDataCopyFromHandle_TargetActors(const struct FTWAbilityCustomDataHandle& InDataHandle, TArray<struct FTWAbilityCustomData_TargetActors>* OutData);
	static bool GetDataCopyFromHandle_Vectors(const struct FTWAbilityCustomDataHandle& InDataHandle, TArray<struct FTWAbilityCustomData_Vectors>* OutData);
	static bool ShouldTriggerLogic(class UTWGameplayAbilitySystem* TWAbilitySystem, class ATimeWatchCharacter* CasterAvatar, const struct FTWAbilityCustomDataHandle& AbilityDataHandle);

	struct FTWAbilityExecutionData GetAbilityExecutionData(const struct FTWAbilityCustomDataHandle& AbilityDataHandle) const;
	TArray<class AActor*> GetAbilityTargets(const struct FTWAbilityCustomDataHandle& AbilityDataHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayAbilitySystem">();
	}
	static class UTWGameplayAbilitySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGameplayAbilitySystem>();
	}
};
static_assert(alignof(UTWGameplayAbilitySystem) == 0x000008, "Wrong alignment on UTWGameplayAbilitySystem");
static_assert(sizeof(UTWGameplayAbilitySystem) == 0x000148, "Wrong size on UTWGameplayAbilitySystem");
static_assert(offsetof(UTWGameplayAbilitySystem, ExecutionHistory) == 0x0000B0, "Member 'UTWGameplayAbilitySystem::ExecutionHistory' has a wrong offset!");
static_assert(offsetof(UTWGameplayAbilitySystem, AbilitiesInstances) == 0x0000C0, "Member 'UTWGameplayAbilitySystem::AbilitiesInstances' has a wrong offset!");
static_assert(offsetof(UTWGameplayAbilitySystem, AbilitiesToRestore) == 0x0000D0, "Member 'UTWGameplayAbilitySystem::AbilitiesToRestore' has a wrong offset!");
static_assert(offsetof(UTWGameplayAbilitySystem, PendingAbilitiesInstances) == 0x0000E0, "Member 'UTWGameplayAbilitySystem::PendingAbilitiesInstances' has a wrong offset!");
static_assert(offsetof(UTWGameplayAbilitySystem, LastCastTimestamp) == 0x0000F8, "Member 'UTWGameplayAbilitySystem::LastCastTimestamp' has a wrong offset!");

// Class TimeWatch.CameraTransitionPoint
// 0x0008 (0x0220 - 0x0218)
class ACameraTransitionPoint final : public AActor
{
public:
	int32                                         TeamId;                                            // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraPointType                              CameraPointType;                                   // 0x021C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraTransitionPoint">();
	}
	static class ACameraTransitionPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraTransitionPoint>();
	}
};
static_assert(alignof(ACameraTransitionPoint) == 0x000008, "Wrong alignment on ACameraTransitionPoint");
static_assert(sizeof(ACameraTransitionPoint) == 0x000220, "Wrong size on ACameraTransitionPoint");
static_assert(offsetof(ACameraTransitionPoint, TeamId) == 0x000218, "Member 'ACameraTransitionPoint::TeamId' has a wrong offset!");
static_assert(offsetof(ACameraTransitionPoint, CameraPointType) == 0x00021C, "Member 'ACameraTransitionPoint::CameraPointType' has a wrong offset!");

// Class TimeWatch.CaptureGameMode
// 0x0008 (0x0478 - 0x0470)
class ACaptureGameMode final : public ATimeWatchGameMode
{
public:
	class AScoreAreaVolume*                       ScoreArea;                                         // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureGameMode">();
	}
	static class ACaptureGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptureGameMode>();
	}
};
static_assert(alignof(ACaptureGameMode) == 0x000008, "Wrong alignment on ACaptureGameMode");
static_assert(sizeof(ACaptureGameMode) == 0x000478, "Wrong size on ACaptureGameMode");
static_assert(offsetof(ACaptureGameMode, ScoreArea) == 0x000470, "Member 'ACaptureGameMode::ScoreArea' has a wrong offset!");

// Class TimeWatch.TWChallengeDetailWidget
// 0x0050 (0x0288 - 0x0238)
class UTWChallengeDetailWidget final : public UUserWidgetBase
{
public:
	class UScaleBox*                              ScaleBox_NoCounterBox;                             // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           VerticalBox_CounterBox;                            // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_NoCounterChallengeDescription;           // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_CounterChallengeDescription;             // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_StatusActive;                              // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_StatusCompleted;                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_Counter;                                 // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_Separator;                               // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_MaxCounter;                              // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWChallengeEvent*                      ChallengeEvent;                                    // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWChallengeDetailWidget">();
	}
	static class UTWChallengeDetailWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWChallengeDetailWidget>();
	}
};
static_assert(alignof(UTWChallengeDetailWidget) == 0x000008, "Wrong alignment on UTWChallengeDetailWidget");
static_assert(sizeof(UTWChallengeDetailWidget) == 0x000288, "Wrong size on UTWChallengeDetailWidget");
static_assert(offsetof(UTWChallengeDetailWidget, ScaleBox_NoCounterBox) == 0x000238, "Member 'UTWChallengeDetailWidget::ScaleBox_NoCounterBox' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, VerticalBox_CounterBox) == 0x000240, "Member 'UTWChallengeDetailWidget::VerticalBox_CounterBox' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, TextBlock_NoCounterChallengeDescription) == 0x000248, "Member 'UTWChallengeDetailWidget::TextBlock_NoCounterChallengeDescription' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, TextBlock_CounterChallengeDescription) == 0x000250, "Member 'UTWChallengeDetailWidget::TextBlock_CounterChallengeDescription' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, Overlay_StatusActive) == 0x000258, "Member 'UTWChallengeDetailWidget::Overlay_StatusActive' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, Overlay_StatusCompleted) == 0x000260, "Member 'UTWChallengeDetailWidget::Overlay_StatusCompleted' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, TextBlock_Counter) == 0x000268, "Member 'UTWChallengeDetailWidget::TextBlock_Counter' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, TextBlock_Separator) == 0x000270, "Member 'UTWChallengeDetailWidget::TextBlock_Separator' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, TextBlock_MaxCounter) == 0x000278, "Member 'UTWChallengeDetailWidget::TextBlock_MaxCounter' has a wrong offset!");
static_assert(offsetof(UTWChallengeDetailWidget, ChallengeEvent) == 0x000280, "Member 'UTWChallengeDetailWidget::ChallengeEvent' has a wrong offset!");

// Class TimeWatch.TimeWatchHUD
// 0x0188 (0x0528 - 0x03A0)
class ATimeWatchHUD : public ANGDLayeredHUD
{
public:
	class UNGDAkComponent*                        NGDAk_ScoreSounds;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        NGDAk_ClockSounds;                                 // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        ClockTickSoundConfig;                              // 0x03B0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        ClockFinalSoundConfig;                             // 0x0408(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        AllyScoreSoundConfig;                              // 0x0460(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        EnemyScoreSoundConfig;                             // 0x04B8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWasTWHUDInitialized;                              // 0x0520(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRematchData                           RematchData;                                       // 0x0521(0x0003)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_524[0x4];                                      // 0x0524(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanTWADSEvents();
	void CloseChat();
	TSubclassOf<class UNGDCrosshairWidget> GetCrosshairClass();
	class UNGDCrosshairWidget* GetCrosshairWidget();
	void HideTWCrossHair();
	void InitializeTWHUD();
	void OnChatMessagePostRequested(const class FText& TextMessage, EChatChannel Channel);
	void OnEnemyKilled(class ATimeWatchCharacter* Victim);
	void OnHittingCharacter(class AActor* InHittedActor, class FName InHittedBone, bool bIsMeleeHit);
	void OnPlayerHit(const struct FVector& HitDirection, const bool IsCritical);
	void OnStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnStatePresented(class UNGDHUDState* PresentedState);
	void OnTeamScoredPoint(int32 TeamId);
	void OnTWExplosion(class AActor* InOwner);
	void OnVictoryConditionReached();
	void OpenChat();
	void PushGameEndScreen();
	void PushMatchResultsScreen();
	void RefreshChatStatus();
	void RefreshCrosshairColor();
	void RegisterTWADSEvents(class ATimeWatchCharacter* TWCharacter);
	void SetCrosshair(TSubclassOf<class UNGDCrosshairWidget> WeaponCrosshairClass);
	void SetOthersWantsRematch(bool bOtherWantsRematch);
	void ShowMatchResults();
	void ShowTWCrossHair();
	void VoidRematch();

	class ATemporalWeapon* GetCurrentWeapon() const;
	class ATimeWatchCharacter* GetTWCharacter() const;
	class ATimeWatchGameState* GetTWGameState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchHUD">();
	}
	static class ATimeWatchHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeWatchHUD>();
	}
};
static_assert(alignof(ATimeWatchHUD) == 0x000008, "Wrong alignment on ATimeWatchHUD");
static_assert(sizeof(ATimeWatchHUD) == 0x000528, "Wrong size on ATimeWatchHUD");
static_assert(offsetof(ATimeWatchHUD, NGDAk_ScoreSounds) == 0x0003A0, "Member 'ATimeWatchHUD::NGDAk_ScoreSounds' has a wrong offset!");
static_assert(offsetof(ATimeWatchHUD, NGDAk_ClockSounds) == 0x0003A8, "Member 'ATimeWatchHUD::NGDAk_ClockSounds' has a wrong offset!");
static_assert(offsetof(ATimeWatchHUD, ClockTickSoundConfig) == 0x0003B0, "Member 'ATimeWatchHUD::ClockTickSoundConfig' has a wrong offset!");
static_assert(offsetof(ATimeWatchHUD, ClockFinalSoundConfig) == 0x000408, "Member 'ATimeWatchHUD::ClockFinalSoundConfig' has a wrong offset!");
static_assert(offsetof(ATimeWatchHUD, AllyScoreSoundConfig) == 0x000460, "Member 'ATimeWatchHUD::AllyScoreSoundConfig' has a wrong offset!");
static_assert(offsetof(ATimeWatchHUD, EnemyScoreSoundConfig) == 0x0004B8, "Member 'ATimeWatchHUD::EnemyScoreSoundConfig' has a wrong offset!");
static_assert(offsetof(ATimeWatchHUD, bWasTWHUDInitialized) == 0x000520, "Member 'ATimeWatchHUD::bWasTWHUDInitialized' has a wrong offset!");
static_assert(offsetof(ATimeWatchHUD, RematchData) == 0x000521, "Member 'ATimeWatchHUD::RematchData' has a wrong offset!");

// Class TimeWatch.CaptureHUD
// 0x0000 (0x0528 - 0x0528)
class ACaptureHUD final : public ATimeWatchHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureHUD">();
	}
	static class ACaptureHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptureHUD>();
	}
};
static_assert(alignof(ACaptureHUD) == 0x000008, "Wrong alignment on ACaptureHUD");
static_assert(sizeof(ACaptureHUD) == 0x000528, "Wrong size on ACaptureHUD");

// Class TimeWatch.ChatWidget
// 0x0100 (0x0338 - 0x0238)
class UChatWidget final : public UUserWidgetBase
{
public:
	uint8                                         Pad_238[0x20];                                     // 0x0238(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NotificationsLifeSpan;                             // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSequenceDelay;                                 // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EChatChannel, struct FChatChannelUIConfig> ChannelsUIConfig;                                // 0x0260(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UEditableTextBox*                       EditableTextBox_Message;                           // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ChannelTag;                              // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_Log;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_Log;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                Border_InputBox;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                Border_Background;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UNotificationWidget*>            NotificationsHistory;                              // 0x02E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UNotificationWidget*>            NotificationsToHide;                               // 0x02F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UNotificationWidget>        AllWidgetClass;                                    // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNotificationWidget>        TeamWidgetClass;                                   // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EChatChannel>                          AvailableChannels;                                 // 0x0328(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnChatClosed();
	void OnChatOpened();
	void OnMessageEntered(const class FText& Text, ETextCommit CommitMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatWidget">();
	}
	static class UChatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatWidget>();
	}
};
static_assert(alignof(UChatWidget) == 0x000008, "Wrong alignment on UChatWidget");
static_assert(sizeof(UChatWidget) == 0x000338, "Wrong size on UChatWidget");
static_assert(offsetof(UChatWidget, NotificationsLifeSpan) == 0x000258, "Member 'UChatWidget::NotificationsLifeSpan' has a wrong offset!");
static_assert(offsetof(UChatWidget, HideSequenceDelay) == 0x00025C, "Member 'UChatWidget::HideSequenceDelay' has a wrong offset!");
static_assert(offsetof(UChatWidget, ChannelsUIConfig) == 0x000260, "Member 'UChatWidget::ChannelsUIConfig' has a wrong offset!");
static_assert(offsetof(UChatWidget, EditableTextBox_Message) == 0x0002B0, "Member 'UChatWidget::EditableTextBox_Message' has a wrong offset!");
static_assert(offsetof(UChatWidget, TextBlock_ChannelTag) == 0x0002B8, "Member 'UChatWidget::TextBlock_ChannelTag' has a wrong offset!");
static_assert(offsetof(UChatWidget, VerticalBox_Log) == 0x0002C0, "Member 'UChatWidget::VerticalBox_Log' has a wrong offset!");
static_assert(offsetof(UChatWidget, ScrollBox_Log) == 0x0002C8, "Member 'UChatWidget::ScrollBox_Log' has a wrong offset!");
static_assert(offsetof(UChatWidget, Border_InputBox) == 0x0002D0, "Member 'UChatWidget::Border_InputBox' has a wrong offset!");
static_assert(offsetof(UChatWidget, Border_Background) == 0x0002D8, "Member 'UChatWidget::Border_Background' has a wrong offset!");
static_assert(offsetof(UChatWidget, NotificationsHistory) == 0x0002E0, "Member 'UChatWidget::NotificationsHistory' has a wrong offset!");
static_assert(offsetof(UChatWidget, NotificationsToHide) == 0x0002F0, "Member 'UChatWidget::NotificationsToHide' has a wrong offset!");
static_assert(offsetof(UChatWidget, AllWidgetClass) == 0x000300, "Member 'UChatWidget::AllWidgetClass' has a wrong offset!");
static_assert(offsetof(UChatWidget, TeamWidgetClass) == 0x000308, "Member 'UChatWidget::TeamWidgetClass' has a wrong offset!");
static_assert(offsetof(UChatWidget, AvailableChannels) == 0x000328, "Member 'UChatWidget::AvailableChannels' has a wrong offset!");

// Class TimeWatch.DailyBoostItemWidget
// 0x0010 (0x0290 - 0x0280)
class UDailyBoostItemWidget : public UNGDUserWidget
{
public:
	class UTexture2D*                             ItemCompletedImage;                                // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ItemIncompletedImage;                              // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetIsItemCompleted(bool IsCompleted, const struct FLinearColor& WidgetColor);
	void SetItemInfo(const class FString& ItemInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyBoostItemWidget">();
	}
	static class UDailyBoostItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDailyBoostItemWidget>();
	}
};
static_assert(alignof(UDailyBoostItemWidget) == 0x000008, "Wrong alignment on UDailyBoostItemWidget");
static_assert(sizeof(UDailyBoostItemWidget) == 0x000290, "Wrong size on UDailyBoostItemWidget");
static_assert(offsetof(UDailyBoostItemWidget, ItemCompletedImage) == 0x000280, "Member 'UDailyBoostItemWidget::ItemCompletedImage' has a wrong offset!");
static_assert(offsetof(UDailyBoostItemWidget, ItemIncompletedImage) == 0x000288, "Member 'UDailyBoostItemWidget::ItemIncompletedImage' has a wrong offset!");

// Class TimeWatch.TWChallengeObserver
// 0x0060 (0x0110 - 0x00B0)
class UTWChallengeObserver final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTWChallengeEvent*>              ActiveChallenges;                                  // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTWChallengeEvent*>              CompletedChallenges;                               // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTWChallengeEvent* ChallengeEvent)> OnChallengeCompleteDelegate; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTWChallengeEventData* ChallengeEventData)> OnChallengeDataLoadComplete; // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTWChallengeEventData* ChallengeEventData)> OnChallengeDataUnloadComplete; // 0x0100(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void LoadChallenges(class UTWChallengeEventData* DataAssetChallenge, const TArray<struct FTWChallengeEventInfo>& NonDataAssetChallenge);
	void OnChallengeProgress(class UTWChallengeEvent* ChallengeEvent, const struct FTWChallengeRule& Rule);
	void UnloadChallenges(class UTWChallengeEventData* DataAssetChallenge, const TArray<struct FTWChallengeEventInfo>& NonDataAssetChallenge);
	void UpdateChallenge(class FName RuleName, int32 RuleCount, bool bDeleteOnCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWChallengeObserver">();
	}
	static class UTWChallengeObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWChallengeObserver>();
	}
};
static_assert(alignof(UTWChallengeObserver) == 0x000008, "Wrong alignment on UTWChallengeObserver");
static_assert(sizeof(UTWChallengeObserver) == 0x000110, "Wrong size on UTWChallengeObserver");
static_assert(offsetof(UTWChallengeObserver, ActiveChallenges) == 0x0000C0, "Member 'UTWChallengeObserver::ActiveChallenges' has a wrong offset!");
static_assert(offsetof(UTWChallengeObserver, CompletedChallenges) == 0x0000D0, "Member 'UTWChallengeObserver::CompletedChallenges' has a wrong offset!");
static_assert(offsetof(UTWChallengeObserver, OnChallengeCompleteDelegate) == 0x0000E0, "Member 'UTWChallengeObserver::OnChallengeCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UTWChallengeObserver, OnChallengeDataLoadComplete) == 0x0000F0, "Member 'UTWChallengeObserver::OnChallengeDataLoadComplete' has a wrong offset!");
static_assert(offsetof(UTWChallengeObserver, OnChallengeDataUnloadComplete) == 0x000100, "Member 'UTWChallengeObserver::OnChallengeDataUnloadComplete' has a wrong offset!");

// Class TimeWatch.DeathMatchGameMode
// 0x0000 (0x0470 - 0x0470)
class ADeathMatchGameMode final : public ATimeWatchGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathMatchGameMode">();
	}
	static class ADeathMatchGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathMatchGameMode>();
	}
};
static_assert(alignof(ADeathMatchGameMode) == 0x000008, "Wrong alignment on ADeathMatchGameMode");
static_assert(sizeof(ADeathMatchGameMode) == 0x000470, "Wrong size on ADeathMatchGameMode");

// Class TimeWatch.DeathMatchHUD
// 0x0000 (0x0528 - 0x0528)
class ADeathMatchHUD final : public ATimeWatchHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathMatchHUD">();
	}
	static class ADeathMatchHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathMatchHUD>();
	}
};
static_assert(alignof(ADeathMatchHUD) == 0x000008, "Wrong alignment on ADeathMatchHUD");
static_assert(sizeof(ADeathMatchHUD) == 0x000528, "Wrong size on ADeathMatchHUD");

// Class TimeWatch.TW2DCompass
// 0x0040 (0x02C0 - 0x0280)
class UTW2DCompass : public UNGDUserWidget
{
public:
	class UOverlay*                               Overlay_Compass;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_CompassArrow;                              // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EllipseRadius;                                     // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetSize;                                        // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorOffset;                                       // 0x02A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOpacityCurve;                               // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ScaleByDistance;                                   // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            OpacityFromCenter;                                 // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TW2DCompass">();
	}
	static class UTW2DCompass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTW2DCompass>();
	}
};
static_assert(alignof(UTW2DCompass) == 0x000008, "Wrong alignment on UTW2DCompass");
static_assert(sizeof(UTW2DCompass) == 0x0002C0, "Wrong size on UTW2DCompass");
static_assert(offsetof(UTW2DCompass, Overlay_Compass) == 0x000280, "Member 'UTW2DCompass::Overlay_Compass' has a wrong offset!");
static_assert(offsetof(UTW2DCompass, Overlay_CompassArrow) == 0x000288, "Member 'UTW2DCompass::Overlay_CompassArrow' has a wrong offset!");
static_assert(offsetof(UTW2DCompass, EllipseRadius) == 0x000290, "Member 'UTW2DCompass::EllipseRadius' has a wrong offset!");
static_assert(offsetof(UTW2DCompass, WidgetSize) == 0x000298, "Member 'UTW2DCompass::WidgetSize' has a wrong offset!");
static_assert(offsetof(UTW2DCompass, ActorOffset) == 0x0002A0, "Member 'UTW2DCompass::ActorOffset' has a wrong offset!");
static_assert(offsetof(UTW2DCompass, bIgnoreOpacityCurve) == 0x0002AC, "Member 'UTW2DCompass::bIgnoreOpacityCurve' has a wrong offset!");
static_assert(offsetof(UTW2DCompass, ScaleByDistance) == 0x0002B0, "Member 'UTW2DCompass::ScaleByDistance' has a wrong offset!");
static_assert(offsetof(UTW2DCompass, OpacityFromCenter) == 0x0002B8, "Member 'UTW2DCompass::OpacityFromCenter' has a wrong offset!");

// Class TimeWatch.CaptureCompassWidget
// 0x0028 (0x02E8 - 0x02C0)
class UCaptureCompassWidget : public UTW2DCompass
{
public:
	class AActor*                                 ScoreArea;                                         // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ECaptureState                                 ForceCompassState;                                 // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetCompassName();
	void OnStateChanged(ECaptureState NewState, const struct FLinearColor& Color);
	bool ShowCapturePointStroke();
	bool ShowCaptureStateText();
	void UpdateDominationCompassText();
	void UpdateWidgetState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureCompassWidget">();
	}
	static class UCaptureCompassWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptureCompassWidget>();
	}
};
static_assert(alignof(UCaptureCompassWidget) == 0x000008, "Wrong alignment on UCaptureCompassWidget");
static_assert(sizeof(UCaptureCompassWidget) == 0x0002E8, "Wrong size on UCaptureCompassWidget");
static_assert(offsetof(UCaptureCompassWidget, ScoreArea) == 0x0002C0, "Member 'UCaptureCompassWidget::ScoreArea' has a wrong offset!");
static_assert(offsetof(UCaptureCompassWidget, ForceCompassState) == 0x0002E0, "Member 'UCaptureCompassWidget::ForceCompassState' has a wrong offset!");

// Class TimeWatch.ScoreAreaVolume
// 0x0038 (0x0250 - 0x0218)
class AScoreAreaVolume : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnContestingTeamIDChange;                          // 0x0218(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	int32                                         ContestingTeamID;                                  // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStayCapturedAfterLeaving;                         // 0x022C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATimeWatchCharacter*>            ContestingClones;                                  // 0x0230(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         OverlappingActors;                                 // 0x0240(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Cosmetic_OnContestingTeamIDChanged();
	void OnRep_ContestingTeamID();

	bool HasCharacterInside() const;
	bool IsInside(class ATimeWatchCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoreAreaVolume">();
	}
	static class AScoreAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScoreAreaVolume>();
	}
};
static_assert(alignof(AScoreAreaVolume) == 0x000008, "Wrong alignment on AScoreAreaVolume");
static_assert(sizeof(AScoreAreaVolume) == 0x000250, "Wrong size on AScoreAreaVolume");
static_assert(offsetof(AScoreAreaVolume, OnContestingTeamIDChange) == 0x000218, "Member 'AScoreAreaVolume::OnContestingTeamIDChange' has a wrong offset!");
static_assert(offsetof(AScoreAreaVolume, ContestingTeamID) == 0x000228, "Member 'AScoreAreaVolume::ContestingTeamID' has a wrong offset!");
static_assert(offsetof(AScoreAreaVolume, bStayCapturedAfterLeaving) == 0x00022C, "Member 'AScoreAreaVolume::bStayCapturedAfterLeaving' has a wrong offset!");
static_assert(offsetof(AScoreAreaVolume, ContestingClones) == 0x000230, "Member 'AScoreAreaVolume::ContestingClones' has a wrong offset!");
static_assert(offsetof(AScoreAreaVolume, OverlappingActors) == 0x000240, "Member 'AScoreAreaVolume::OverlappingActors' has a wrong offset!");

// Class TimeWatch.DominationAreaVolume
// 0x0028 (0x0278 - 0x0250)
class ADominationAreaVolume final : public AScoreAreaVolume
{
public:
	TMulticastInlineDelegate<void()>              OnVolumeNameSet;                                   // 0x0250(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DominationAreaVolume">();
	}
	static class ADominationAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADominationAreaVolume>();
	}
};
static_assert(alignof(ADominationAreaVolume) == 0x000008, "Wrong alignment on ADominationAreaVolume");
static_assert(sizeof(ADominationAreaVolume) == 0x000278, "Wrong size on ADominationAreaVolume");
static_assert(offsetof(ADominationAreaVolume, OnVolumeNameSet) == 0x000250, "Member 'ADominationAreaVolume::OnVolumeNameSet' has a wrong offset!");

// Class TimeWatch.TWStandardButtonWidget
// 0x0840 (0x0AC0 - 0x0280)
class UTWStandardButtonWidget : public UNGDUserWidget
{
public:
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnDoubleClicked;                                   // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRightClicked;                                    // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        OnClickedAudio;                                    // 0x02B0(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        OnHoveredAudio;                                    // 0x0308(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseEditorButtonSettings;                          // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldCheckForDoubleClick;                        // 0x0361(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0x2];                                      // 0x0362(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoubleClickTreshold;                               // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonStyle;                                       // 0x0368(0x0278)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ButtonColorAndOpacity;                             // 0x05E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ButtonBackgroundColor;                             // 0x05F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseEditorTextSettings;                            // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_601[0x7];                                      // 0x0601(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonTextBlock;                                   // 0x0608(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            ButtonTextColorAndOpacity;                         // 0x0620(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         ButtonTextFont;                                    // 0x0648(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ButtonTextShadowOffset;                            // 0x0698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ButtonTextShadowColorAndOpacity;                   // 0x06A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWidgetTransform                       ButtonTextTransform;                               // 0x06B0(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6CC[0x4];                                      // 0x06CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            SecondaryTextColorAndOpacity;                      // 0x06D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         SecondaryTextFont;                                 // 0x06F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SecondaryTextShadowOffset;                         // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SecondaryTextShadowColorAndOpacity;                // 0x0750(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWidgetTransform                       SecondaryTextTransform;                            // 0x0760(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseEditorImageSettings;                           // 0x077C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77D[0x3];                                      // 0x077D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            ButtonImageBrush;                                  // 0x0780(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ButtonImageColorAndOpacity;                        // 0x0808(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_Selection;                                  // 0x0818(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ButtonImage;                                 // 0x0820(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ButtonIcon;                                  // 0x0828(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ButtonName;                              // 0x0830(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_SecondaryText;                           // 0x0838(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FButtonStyle                           CachedButtonStyle;                                 // 0x0840(0x0278)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bButtonFocused;                                    // 0x0AB8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AB9[0x3];                                      // 0x0AB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastClickTimeStamp;                                // 0x0ABC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_TWFocusLostEvent();
	void BP_TWFocusReceivedEvent();
	void ButtonEvents_OnClicked();
	void ButtonEvents_OnHovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWStandardButtonWidget">();
	}
	static class UTWStandardButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWStandardButtonWidget>();
	}
};
static_assert(alignof(UTWStandardButtonWidget) == 0x000008, "Wrong alignment on UTWStandardButtonWidget");
static_assert(sizeof(UTWStandardButtonWidget) == 0x000AC0, "Wrong size on UTWStandardButtonWidget");
static_assert(offsetof(UTWStandardButtonWidget, OnDoubleClicked) == 0x000290, "Member 'UTWStandardButtonWidget::OnDoubleClicked' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, OnRightClicked) == 0x0002A0, "Member 'UTWStandardButtonWidget::OnRightClicked' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, OnClickedAudio) == 0x0002B0, "Member 'UTWStandardButtonWidget::OnClickedAudio' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, OnHoveredAudio) == 0x000308, "Member 'UTWStandardButtonWidget::OnHoveredAudio' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, bUseEditorButtonSettings) == 0x000360, "Member 'UTWStandardButtonWidget::bUseEditorButtonSettings' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, bShouldCheckForDoubleClick) == 0x000361, "Member 'UTWStandardButtonWidget::bShouldCheckForDoubleClick' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, DoubleClickTreshold) == 0x000364, "Member 'UTWStandardButtonWidget::DoubleClickTreshold' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonStyle) == 0x000368, "Member 'UTWStandardButtonWidget::ButtonStyle' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonColorAndOpacity) == 0x0005E0, "Member 'UTWStandardButtonWidget::ButtonColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonBackgroundColor) == 0x0005F0, "Member 'UTWStandardButtonWidget::ButtonBackgroundColor' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, bUseEditorTextSettings) == 0x000600, "Member 'UTWStandardButtonWidget::bUseEditorTextSettings' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonTextBlock) == 0x000608, "Member 'UTWStandardButtonWidget::ButtonTextBlock' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonTextColorAndOpacity) == 0x000620, "Member 'UTWStandardButtonWidget::ButtonTextColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonTextFont) == 0x000648, "Member 'UTWStandardButtonWidget::ButtonTextFont' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonTextShadowOffset) == 0x000698, "Member 'UTWStandardButtonWidget::ButtonTextShadowOffset' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonTextShadowColorAndOpacity) == 0x0006A0, "Member 'UTWStandardButtonWidget::ButtonTextShadowColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonTextTransform) == 0x0006B0, "Member 'UTWStandardButtonWidget::ButtonTextTransform' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, SecondaryTextColorAndOpacity) == 0x0006D0, "Member 'UTWStandardButtonWidget::SecondaryTextColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, SecondaryTextFont) == 0x0006F8, "Member 'UTWStandardButtonWidget::SecondaryTextFont' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, SecondaryTextShadowOffset) == 0x000748, "Member 'UTWStandardButtonWidget::SecondaryTextShadowOffset' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, SecondaryTextShadowColorAndOpacity) == 0x000750, "Member 'UTWStandardButtonWidget::SecondaryTextShadowColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, SecondaryTextTransform) == 0x000760, "Member 'UTWStandardButtonWidget::SecondaryTextTransform' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, bUseEditorImageSettings) == 0x00077C, "Member 'UTWStandardButtonWidget::bUseEditorImageSettings' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonImageBrush) == 0x000780, "Member 'UTWStandardButtonWidget::ButtonImageBrush' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, ButtonImageColorAndOpacity) == 0x000808, "Member 'UTWStandardButtonWidget::ButtonImageColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, Button_Selection) == 0x000818, "Member 'UTWStandardButtonWidget::Button_Selection' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, Image_ButtonImage) == 0x000820, "Member 'UTWStandardButtonWidget::Image_ButtonImage' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, Image_ButtonIcon) == 0x000828, "Member 'UTWStandardButtonWidget::Image_ButtonIcon' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, TextBlock_ButtonName) == 0x000830, "Member 'UTWStandardButtonWidget::TextBlock_ButtonName' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, TextBlock_SecondaryText) == 0x000838, "Member 'UTWStandardButtonWidget::TextBlock_SecondaryText' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, CachedButtonStyle) == 0x000840, "Member 'UTWStandardButtonWidget::CachedButtonStyle' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, bButtonFocused) == 0x000AB8, "Member 'UTWStandardButtonWidget::bButtonFocused' has a wrong offset!");
static_assert(offsetof(UTWStandardButtonWidget, LastClickTimeStamp) == 0x000ABC, "Member 'UTWStandardButtonWidget::LastClickTimeStamp' has a wrong offset!");

// Class TimeWatch.TWCustomizationButtonWidget
// 0x0C78 (0x1738 - 0x0AC0)
class UTWCustomizationButtonWidget : public UTWStandardButtonWidget
{
public:
	TMulticastInlineDelegate<void()>              OnRightClick;                                      // 0x0AC0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FButtonStyle                           ButtonStyle_Empty;                                 // 0x0AD0(0x0278)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonStyle_Selected;                              // 0x0D48(0x0278)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonStyle_Unselected;                            // 0x0FC0(0x0278)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonStyle_Active;                                // 0x1238(0x0278)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonStyle_ForceHover;                            // 0x14B0(0x0278)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LockedIcon;                                  // 0x1728(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1730[0x8];                                     // 0x1730(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCustomizationButtonWidget">();
	}
	static class UTWCustomizationButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWCustomizationButtonWidget>();
	}
};
static_assert(alignof(UTWCustomizationButtonWidget) == 0x000008, "Wrong alignment on UTWCustomizationButtonWidget");
static_assert(sizeof(UTWCustomizationButtonWidget) == 0x001738, "Wrong size on UTWCustomizationButtonWidget");
static_assert(offsetof(UTWCustomizationButtonWidget, OnRightClick) == 0x000AC0, "Member 'UTWCustomizationButtonWidget::OnRightClick' has a wrong offset!");
static_assert(offsetof(UTWCustomizationButtonWidget, ButtonStyle_Empty) == 0x000AD0, "Member 'UTWCustomizationButtonWidget::ButtonStyle_Empty' has a wrong offset!");
static_assert(offsetof(UTWCustomizationButtonWidget, ButtonStyle_Selected) == 0x000D48, "Member 'UTWCustomizationButtonWidget::ButtonStyle_Selected' has a wrong offset!");
static_assert(offsetof(UTWCustomizationButtonWidget, ButtonStyle_Unselected) == 0x000FC0, "Member 'UTWCustomizationButtonWidget::ButtonStyle_Unselected' has a wrong offset!");
static_assert(offsetof(UTWCustomizationButtonWidget, ButtonStyle_Active) == 0x001238, "Member 'UTWCustomizationButtonWidget::ButtonStyle_Active' has a wrong offset!");
static_assert(offsetof(UTWCustomizationButtonWidget, ButtonStyle_ForceHover) == 0x0014B0, "Member 'UTWCustomizationButtonWidget::ButtonStyle_ForceHover' has a wrong offset!");
static_assert(offsetof(UTWCustomizationButtonWidget, Image_LockedIcon) == 0x001728, "Member 'UTWCustomizationButtonWidget::Image_LockedIcon' has a wrong offset!");

// Class TimeWatch.TWCharacterButtonWidget
// 0x0060 (0x1798 - 0x1738)
class UTWCharacterButtonWidget : public UTWCustomizationButtonWidget
{
public:
	class UImage*                                 Image_Selected;                                    // 0x1738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Locked;                                      // 0x1740(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1748[0x40];                                    // 0x1748(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWCharacterDataAsset*                  CharacterData;                                     // 0x1788(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTagWidget*                           Tag_FreeItem;                                      // 0x1790(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCharacterButtonClicked();
	void OnCharacterButtonFocusChanged(bool IsFocused);
	void OnCharacterButtonHovered();
	void OnCharacterButtonRightClicked();
	void OnCharacterButtonUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCharacterButtonWidget">();
	}
	static class UTWCharacterButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWCharacterButtonWidget>();
	}
};
static_assert(alignof(UTWCharacterButtonWidget) == 0x000008, "Wrong alignment on UTWCharacterButtonWidget");
static_assert(sizeof(UTWCharacterButtonWidget) == 0x001798, "Wrong size on UTWCharacterButtonWidget");
static_assert(offsetof(UTWCharacterButtonWidget, Image_Selected) == 0x001738, "Member 'UTWCharacterButtonWidget::Image_Selected' has a wrong offset!");
static_assert(offsetof(UTWCharacterButtonWidget, Image_Locked) == 0x001740, "Member 'UTWCharacterButtonWidget::Image_Locked' has a wrong offset!");
static_assert(offsetof(UTWCharacterButtonWidget, CharacterData) == 0x001788, "Member 'UTWCharacterButtonWidget::CharacterData' has a wrong offset!");
static_assert(offsetof(UTWCharacterButtonWidget, Tag_FreeItem) == 0x001790, "Member 'UTWCharacterButtonWidget::Tag_FreeItem' has a wrong offset!");

// Class TimeWatch.DominationGameMode
// 0x0010 (0x0480 - 0x0470)
class ADominationGameMode final : public ATimeWatchGameMode
{
public:
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DominationGameMode">();
	}
	static class ADominationGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADominationGameMode>();
	}
};
static_assert(alignof(ADominationGameMode) == 0x000008, "Wrong alignment on ADominationGameMode");
static_assert(sizeof(ADominationGameMode) == 0x000480, "Wrong size on ADominationGameMode");

// Class TimeWatch.DominationHUD
// 0x0000 (0x0528 - 0x0528)
class ADominationHUD final : public ATimeWatchHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DominationHUD">();
	}
	static class ADominationHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADominationHUD>();
	}
};
static_assert(alignof(ADominationHUD) == 0x000008, "Wrong alignment on ADominationHUD");
static_assert(sizeof(ADominationHUD) == 0x000528, "Wrong size on ADominationHUD");

// Class TimeWatch.TWCloneTimelineWidget
// 0x0038 (0x02B8 - 0x0280)
class UTWCloneTimelineWidget final : public UNGDUserWidget
{
public:
	struct FCloneTimelineData                     Data;                                              // 0x0280(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class ATimeWatchCharacter*                    OwnerClone;                                        // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CloneIndex;                                        // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDeathIcon_BP(float TimeValue);

	int32 GetCloneIndex() const;
	class ATimeWatchCharacter* GetOwnerClone() const;
	class ATimeWatchGameState* GetTWGameState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCloneTimelineWidget">();
	}
	static class UTWCloneTimelineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWCloneTimelineWidget>();
	}
};
static_assert(alignof(UTWCloneTimelineWidget) == 0x000008, "Wrong alignment on UTWCloneTimelineWidget");
static_assert(sizeof(UTWCloneTimelineWidget) == 0x0002B8, "Wrong size on UTWCloneTimelineWidget");
static_assert(offsetof(UTWCloneTimelineWidget, Data) == 0x000280, "Member 'UTWCloneTimelineWidget::Data' has a wrong offset!");
static_assert(offsetof(UTWCloneTimelineWidget, OwnerClone) == 0x0002A8, "Member 'UTWCloneTimelineWidget::OwnerClone' has a wrong offset!");
static_assert(offsetof(UTWCloneTimelineWidget, CloneIndex) == 0x0002B0, "Member 'UTWCloneTimelineWidget::CloneIndex' has a wrong offset!");

// Class TimeWatch.DominationScorePoint
// 0x0048 (0x02C8 - 0x0280)
class UDominationScorePoint final : public UNGDUserWidget
{
public:
	class UImage*                                 Image_Background;                                  // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PointName;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NeutralControlBackgroundColor;                     // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CapturedTextColor;                                 // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NeutralTextColor;                                  // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADominationAreaVolume*                  DominationAreaVolume;                              // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateBackgroundShapeAndColor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DominationScorePoint">();
	}
	static class UDominationScorePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDominationScorePoint>();
	}
};
static_assert(alignof(UDominationScorePoint) == 0x000008, "Wrong alignment on UDominationScorePoint");
static_assert(sizeof(UDominationScorePoint) == 0x0002C8, "Wrong size on UDominationScorePoint");
static_assert(offsetof(UDominationScorePoint, Image_Background) == 0x000280, "Member 'UDominationScorePoint::Image_Background' has a wrong offset!");
static_assert(offsetof(UDominationScorePoint, Text_PointName) == 0x000288, "Member 'UDominationScorePoint::Text_PointName' has a wrong offset!");
static_assert(offsetof(UDominationScorePoint, NeutralControlBackgroundColor) == 0x000290, "Member 'UDominationScorePoint::NeutralControlBackgroundColor' has a wrong offset!");
static_assert(offsetof(UDominationScorePoint, CapturedTextColor) == 0x0002A0, "Member 'UDominationScorePoint::CapturedTextColor' has a wrong offset!");
static_assert(offsetof(UDominationScorePoint, NeutralTextColor) == 0x0002B0, "Member 'UDominationScorePoint::NeutralTextColor' has a wrong offset!");
static_assert(offsetof(UDominationScorePoint, DominationAreaVolume) == 0x0002C0, "Member 'UDominationScorePoint::DominationAreaVolume' has a wrong offset!");

// Class TimeWatch.DropDownScrollListElementWidget
// 0x0598 (0x07D0 - 0x0238)
class UDropDownScrollListElementWidget final : public UUserWidgetBase
{
public:
	TMulticastInlineDelegate<void(const struct FDropdownScrollListElement& ClickedElement)> OnElementSelected; // 0x0238(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UButton*                                Button_ElementButton;                              // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ElementName;                             // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FButtonStyle                           DefaultButtonStyle;                                // 0x0258(0x0278)(Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            DefaultColorFont;                                  // 0x04D0(0x0028)(Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonStyle_Selected;                              // 0x04F8(0x0278)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            FontStyle_Selected;                                // 0x0770(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDropdownScrollListElement             DropDownElement;                                   // 0x0798(0x0028)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                LastButtonPress;                                   // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnElementButtonClicked();
	void OnElementButtonHovered();
	void OnElementButtonUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropDownScrollListElementWidget">();
	}
	static class UDropDownScrollListElementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropDownScrollListElementWidget>();
	}
};
static_assert(alignof(UDropDownScrollListElementWidget) == 0x000008, "Wrong alignment on UDropDownScrollListElementWidget");
static_assert(sizeof(UDropDownScrollListElementWidget) == 0x0007D0, "Wrong size on UDropDownScrollListElementWidget");
static_assert(offsetof(UDropDownScrollListElementWidget, OnElementSelected) == 0x000238, "Member 'UDropDownScrollListElementWidget::OnElementSelected' has a wrong offset!");
static_assert(offsetof(UDropDownScrollListElementWidget, Button_ElementButton) == 0x000248, "Member 'UDropDownScrollListElementWidget::Button_ElementButton' has a wrong offset!");
static_assert(offsetof(UDropDownScrollListElementWidget, TextBlock_ElementName) == 0x000250, "Member 'UDropDownScrollListElementWidget::TextBlock_ElementName' has a wrong offset!");
static_assert(offsetof(UDropDownScrollListElementWidget, DefaultButtonStyle) == 0x000258, "Member 'UDropDownScrollListElementWidget::DefaultButtonStyle' has a wrong offset!");
static_assert(offsetof(UDropDownScrollListElementWidget, DefaultColorFont) == 0x0004D0, "Member 'UDropDownScrollListElementWidget::DefaultColorFont' has a wrong offset!");
static_assert(offsetof(UDropDownScrollListElementWidget, ButtonStyle_Selected) == 0x0004F8, "Member 'UDropDownScrollListElementWidget::ButtonStyle_Selected' has a wrong offset!");
static_assert(offsetof(UDropDownScrollListElementWidget, FontStyle_Selected) == 0x000770, "Member 'UDropDownScrollListElementWidget::FontStyle_Selected' has a wrong offset!");
static_assert(offsetof(UDropDownScrollListElementWidget, DropDownElement) == 0x000798, "Member 'UDropDownScrollListElementWidget::DropDownElement' has a wrong offset!");
static_assert(offsetof(UDropDownScrollListElementWidget, LastButtonPress) == 0x0007C8, "Member 'UDropDownScrollListElementWidget::LastButtonPress' has a wrong offset!");

// Class TimeWatch.CharacterGhostAnimInstance
// 0x0070 (0x02E0 - 0x0270)
class UCharacterGhostAnimInstance : public UNGDAnimInstance
{
public:
	struct FPoseSnapshot                          fluxPoseLeft;                                      // 0x0268(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPoseSnapshot                          fluxPoseRight;                                     // 0x02A0(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         fluxDelta;                                         // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterGhostAnimInstance">();
	}
	static class UCharacterGhostAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterGhostAnimInstance>();
	}
};
static_assert(alignof(UCharacterGhostAnimInstance) == 0x000010, "Wrong alignment on UCharacterGhostAnimInstance");
static_assert(sizeof(UCharacterGhostAnimInstance) == 0x0002E0, "Wrong size on UCharacterGhostAnimInstance");
static_assert(offsetof(UCharacterGhostAnimInstance, fluxPoseLeft) == 0x000268, "Member 'UCharacterGhostAnimInstance::fluxPoseLeft' has a wrong offset!");
static_assert(offsetof(UCharacterGhostAnimInstance, fluxPoseRight) == 0x0002A0, "Member 'UCharacterGhostAnimInstance::fluxPoseRight' has a wrong offset!");
static_assert(offsetof(UCharacterGhostAnimInstance, fluxDelta) == 0x0002D8, "Member 'UCharacterGhostAnimInstance::fluxDelta' has a wrong offset!");

// Class TimeWatch.DropdownScrollListWidget
// 0x00B8 (0x02F0 - 0x0238)
class UDropdownScrollListWidget final : public UUserWidgetBase
{
public:
	TMulticastInlineDelegate<void(const class FString& ElementIndentifier)> OnElementSelect;         // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UDropDownScrollListElementWidget> DropDownScrollListElementTemplate;           // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDropdownScrollListElement>     DefaultOptions;                                    // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UDropDownScrollListElementWidget*> DropDownElementsMap;                // 0x0260(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FString                                 SelectedElementIdentifier;                         // 0x02B0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ButtonVerticalPadding;                             // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScrollBox*                             ScrollBox_DropdownMenu;                            // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDropDownScrollListElementWidget*       LastSelectedElement;                               // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   SelectedOptionText;                                // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnDropDownElementSelected(const struct FDropdownScrollListElement& NewSelectedElement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropdownScrollListWidget">();
	}
	static class UDropdownScrollListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropdownScrollListWidget>();
	}
};
static_assert(alignof(UDropdownScrollListWidget) == 0x000008, "Wrong alignment on UDropdownScrollListWidget");
static_assert(sizeof(UDropdownScrollListWidget) == 0x0002F0, "Wrong size on UDropdownScrollListWidget");
static_assert(offsetof(UDropdownScrollListWidget, OnElementSelect) == 0x000238, "Member 'UDropdownScrollListWidget::OnElementSelect' has a wrong offset!");
static_assert(offsetof(UDropdownScrollListWidget, DropDownScrollListElementTemplate) == 0x000248, "Member 'UDropdownScrollListWidget::DropDownScrollListElementTemplate' has a wrong offset!");
static_assert(offsetof(UDropdownScrollListWidget, DefaultOptions) == 0x000250, "Member 'UDropdownScrollListWidget::DefaultOptions' has a wrong offset!");
static_assert(offsetof(UDropdownScrollListWidget, DropDownElementsMap) == 0x000260, "Member 'UDropdownScrollListWidget::DropDownElementsMap' has a wrong offset!");
static_assert(offsetof(UDropdownScrollListWidget, SelectedElementIdentifier) == 0x0002B0, "Member 'UDropdownScrollListWidget::SelectedElementIdentifier' has a wrong offset!");
static_assert(offsetof(UDropdownScrollListWidget, ButtonVerticalPadding) == 0x0002C0, "Member 'UDropdownScrollListWidget::ButtonVerticalPadding' has a wrong offset!");
static_assert(offsetof(UDropdownScrollListWidget, ScrollBox_DropdownMenu) == 0x0002C8, "Member 'UDropdownScrollListWidget::ScrollBox_DropdownMenu' has a wrong offset!");
static_assert(offsetof(UDropdownScrollListWidget, LastSelectedElement) == 0x0002D0, "Member 'UDropdownScrollListWidget::LastSelectedElement' has a wrong offset!");
static_assert(offsetof(UDropdownScrollListWidget, SelectedOptionText) == 0x0002D8, "Member 'UDropdownScrollListWidget::SelectedOptionText' has a wrong offset!");

// Class TimeWatch.FluxAIController
// 0x0000 (0x0320 - 0x0320)
class AFluxAIController final : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxAIController">();
	}
	static class AFluxAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluxAIController>();
	}
};
static_assert(alignof(AFluxAIController) == 0x000008, "Wrong alignment on AFluxAIController");
static_assert(sizeof(AFluxAIController) == 0x000320, "Wrong size on AFluxAIController");

// Class TimeWatch.FluxAnimInstance
// 0x0100 (0x0470 - 0x0370)
class UFluxAnimInstance : public UNGDCharacterAnimInstance
{
public:
	bool                                          fluxIsRewinding;                                   // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          fluxPoseLeft;                                      // 0x0370(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPoseSnapshot                          fluxPoseRight;                                     // 0x03A8(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         fluxDelta;                                         // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReloading;                                       // 0x03E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMontageResumeData>             WeaponAnimResumeData;                              // 0x03E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x1];                                      // 0x03F8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EWeaponType                                   CurrentWeaponType;                                 // 0x03F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   PreviousWeaponType;                                // 0x03FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChangingWeapons;                                // 0x03FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponChangeProgress;                              // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCosmeticWeaponChanged;                         // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IKHandsAlpha;                                      // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingDelayFactor;                                 // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadAnimDuration;                                // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_414[0xC];                                      // 0x0414(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InverseAimPointLocalTransform;                     // 0x0420(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0450(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationPrevFrame;                                 // 0x045C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxAnimInstance">();
	}
	static class UFluxAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxAnimInstance>();
	}
};
static_assert(alignof(UFluxAnimInstance) == 0x000010, "Wrong alignment on UFluxAnimInstance");
static_assert(sizeof(UFluxAnimInstance) == 0x000470, "Wrong size on UFluxAnimInstance");
static_assert(offsetof(UFluxAnimInstance, fluxIsRewinding) == 0x000368, "Member 'UFluxAnimInstance::fluxIsRewinding' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, fluxPoseLeft) == 0x000370, "Member 'UFluxAnimInstance::fluxPoseLeft' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, fluxPoseRight) == 0x0003A8, "Member 'UFluxAnimInstance::fluxPoseRight' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, fluxDelta) == 0x0003E0, "Member 'UFluxAnimInstance::fluxDelta' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, IsReloading) == 0x0003E4, "Member 'UFluxAnimInstance::IsReloading' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, WeaponAnimResumeData) == 0x0003E8, "Member 'UFluxAnimInstance::WeaponAnimResumeData' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, CurrentWeaponType) == 0x0003F9, "Member 'UFluxAnimInstance::CurrentWeaponType' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, PreviousWeaponType) == 0x0003FA, "Member 'UFluxAnimInstance::PreviousWeaponType' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, bIsChangingWeapons) == 0x0003FB, "Member 'UFluxAnimInstance::bIsChangingWeapons' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, WeaponChangeProgress) == 0x0003FC, "Member 'UFluxAnimInstance::WeaponChangeProgress' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, bHasCosmeticWeaponChanged) == 0x000400, "Member 'UFluxAnimInstance::bHasCosmeticWeaponChanged' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, IKHandsAlpha) == 0x000404, "Member 'UFluxAnimInstance::IKHandsAlpha' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, AimingDelayFactor) == 0x000408, "Member 'UFluxAnimInstance::AimingDelayFactor' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, ReloadAnimDuration) == 0x00040C, "Member 'UFluxAnimInstance::ReloadAnimDuration' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, Speed) == 0x000410, "Member 'UFluxAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, InverseAimPointLocalTransform) == 0x000420, "Member 'UFluxAnimInstance::InverseAimPointLocalTransform' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, Location) == 0x000450, "Member 'UFluxAnimInstance::Location' has a wrong offset!");
static_assert(offsetof(UFluxAnimInstance, LocationPrevFrame) == 0x00045C, "Member 'UFluxAnimInstance::LocationPrevFrame' has a wrong offset!");

// Class TimeWatch.FluxCapacitor
// 0x0000 (0x0218 - 0x0218)
class AFluxCapacitor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxCapacitor">();
	}
	static class AFluxCapacitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluxCapacitor>();
	}
};
static_assert(alignof(AFluxCapacitor) == 0x000008, "Wrong alignment on AFluxCapacitor");
static_assert(sizeof(AFluxCapacitor) == 0x000218, "Wrong size on AFluxCapacitor");

// Class TimeWatch.TWClonePointWidget
// 0x0058 (0x02D8 - 0x0280)
class UTWClonePointWidget : public UNGDUserWidget
{
public:
	class UMaterialInterface*                     LeftGradientMaterial;                              // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     RightGradientMaterial;                             // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftPoint;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightPoint;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_CloneNumber;                                  // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x30];                                     // 0x02A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWClonePointWidget">();
	}
	static class UTWClonePointWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWClonePointWidget>();
	}
};
static_assert(alignof(UTWClonePointWidget) == 0x000008, "Wrong alignment on UTWClonePointWidget");
static_assert(sizeof(UTWClonePointWidget) == 0x0002D8, "Wrong size on UTWClonePointWidget");
static_assert(offsetof(UTWClonePointWidget, LeftGradientMaterial) == 0x000280, "Member 'UTWClonePointWidget::LeftGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWClonePointWidget, RightGradientMaterial) == 0x000288, "Member 'UTWClonePointWidget::RightGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWClonePointWidget, Image_LeftPoint) == 0x000290, "Member 'UTWClonePointWidget::Image_LeftPoint' has a wrong offset!");
static_assert(offsetof(UTWClonePointWidget, Image_RightPoint) == 0x000298, "Member 'UTWClonePointWidget::Image_RightPoint' has a wrong offset!");
static_assert(offsetof(UTWClonePointWidget, Text_CloneNumber) == 0x0002A0, "Member 'UTWClonePointWidget::Text_CloneNumber' has a wrong offset!");

// Class TimeWatch.FluxCloneController
// 0x0000 (0x0290 - 0x0290)
class AFluxCloneController final : public AController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxCloneController">();
	}
	static class AFluxCloneController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluxCloneController>();
	}
};
static_assert(alignof(AFluxCloneController) == 0x000008, "Wrong alignment on AFluxCloneController");
static_assert(sizeof(AFluxCloneController) == 0x000290, "Wrong size on AFluxCloneController");

// Class TimeWatch.TimeWatchGameState
// 0x04A0 (0x0788 - 0x02E8)
class ATimeWatchGameState : public ANGDGameState
{
public:
	uint8                                         Pad_2E8[0x50];                                     // 0x02E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnScoreChanged;                                    // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoopChanged;                                     // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVictoryCondition;                                // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnShowMatchResults;                                // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnWeaponSelectionCollapse;                         // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 TeamId)>  OnTeamScoredPoint;                                 // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 TeamId)>  OnTeamScoringChanged;                              // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMatchEventLogCreated;                            // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllClonesReady;                                  // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTeamsAssigned;                                   // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTeamAdvantageChanged;                            // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnContinueInSkipChallengePopup;                    // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FPingMarker& PingMarker)> OnPingMarkerAdded;          // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 PingMarkerID)> OnPingMarkerRemoved;                          // 0x0408(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSyncWaitTime;                                   // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSyncWaitTime;                                   // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeBeforeCatchupWarning;                       // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGameTimeBeforeDisconnectWarning;                // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BubbleCollapseAnimationLength;                     // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDilationScalar;                                // 0x0434(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TeamAdvantage;                                     // 0x0440(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	int32                                         StateCompletePlayers;                              // 0x0450(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATWProjectileManager*                   ProjectileManager;                                 // 0x0458(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldShowWeaponInteractionWidget;                // 0x0460(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplayCharSelectionData               LoadedReplayCharSelectionData;                     // 0x0468(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FPingMarker>               PingMarkers;                                       // 0x0490(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FMatchDescriptor                       GameStateMatchDescriptor;                          // 0x04E0(0x0050)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         RoundCounter;                                      // 0x0530(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LoopCounter;                                       // 0x0534(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x4];                                      // 0x0538(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastRoundMaxLoopReached;                           // 0x053C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ScoringTeam;                                       // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           EnviromentalTime;                                  // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MPC_OutlineColors;                                 // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MPC_EviromentalTeamColors;                         // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMatchEventLog*                         MatchEventLog;                                     // 0x0560(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownTime;                                      // 0x0568(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponSelectionCollapseAnimStartTime;              // 0x056C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x1];                                      // 0x0570(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EFluxLoopResult                               LastLoopResult;                                    // 0x0571(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_572[0x2];                                      // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameCooldown;                                      // 0x0574(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoopCooldown;                                      // 0x0578(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloneCooldown;                                     // 0x057C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastLoopPreviewCooldown;                           // 0x0580(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardEndCooldown;                                // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowPlayerInputAfterScore;                       // 0x0588(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTimelinesShouldRecord;                            // 0x0589(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58A[0x6];                                      // 0x058A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomTimeDilationRemainingTime;                   // 0x0590(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScore                                 Score;                                             // 0x0598(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UTWGameGlobals*                         TWGameGlobals;                                     // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWGameEventObserver*                   TWGameObserver;                                    // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWGameplayAbilitySystem*               TWAbilitySystem;                                   // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATWProjectileManager>       ProjectileManagerClass;                            // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState)> OnStateChanged; // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x05E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RewindOffset;                                      // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RewindRate;                                        // 0x05E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoopRewindRatio;                                   // 0x05EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoopReplayRewindRate;                              // 0x05F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoopReplayRewindStopAtRatio;                       // 0x05F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreezeTimeAfterScore;                              // 0x05F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TimeDilationScalarCurve;                           // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TimeDilationScalarCurve_ForwardEnd;                // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            PreForwardCurlPlayRateScalar;                      // 0x0610(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UFluxTimeline>, class UCurveFloat*> ActorsCustomTimeDilationScalarCurves; // 0x0618(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentTime;                                       // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTime_Server;                                // 0x066C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_670[0x4];                                      // 0x0670(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentClone;                                      // 0x0674(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentLoop;                                       // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFluxCapacitorStates                          CurrentState;                                      // 0x067C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFluxCapacitorStates                          PreviousState;                                     // 0x067D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FluxTimerPaused;                                   // 0x067E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67F[0x1];                                      // 0x067F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        GameRandomSeed;                                    // 0x0680(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UFluxTimeline>>   Timelines;                                         // 0x0688(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<int32, struct FPostSoundParams>          PendingDurationSoundEvents;                        // 0x0698(0x0050)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FReversableSoundEvent>          ReversableSoundEvents;                             // 0x06E8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F8[0x8];                                      // 0x06F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATimeWatchCharacter*>            AllClones;                                         // 0x0700(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class APlayerState*>                   AllPlayerStates;                                   // 0x0710(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTWChallengeObserver*                   ChallengeObserver;                                 // 0x0720(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0x10];                                     // 0x0728(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerAutoCloseTimer;                              // 0x0738(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73C[0xC];                                      // 0x073C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATWTutorialTooltipManager>  DefaultTooltipManagerClass;                        // 0x0748(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_750[0x28];                                     // 0x0750(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWSwitchInteractionsAuditor*           SwitchInteractionAuditor;                          // 0x0778(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_780[0x8];                                      // 0x0780(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddScore(int32 TeamId, int32 ScoreIncrement, bool bBroadcast);
	void AdvanceState();
	void AuthorityCyclePlayersClone(int32 PlayerPosition);
	void AuthoritySetFluxState(EFluxCapacitorStates NewState);
	float GetCooldownTime();
	class ATimeWatchCharacter* GetCurrentClone(const class APlayerController* PC);
	float GetCurrentRelativeTime();
	float GetCustomGameTimeSynchronized();
	class UTWGameEventObserver* GetGameEventObserver();
	int32 GetLoopCounter();
	int32 GetRoundcounter();
	float GetServerAutoCloseTimer();
	int32 GetTeamScore(int32 TeamId);
	class ATWTutorialTooltipManager* GetTutorialTooltipManager();
	int32 GetWinningTeam();
	bool IsResetClonesEachLoopActive();
	void MultiCast_AddPingMarker(const struct FPingMarker& NewPing);
	void MultiCast_RemovePingMarker(int32 ID);
	void Multicast_SetWeaponSelectionCollapsed(bool Value);
	void Multicast_TriggerTimeBubble(uint8 UnnecessaryParameter);
	void MulticastLoopFinishedWithResult(EFluxLoopResult Result);
	void MulticastShowAllWeaponSwitchers();
	void MulticastStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void MulticastTeamScoredPoint(int32 TeamId);
	void OnChangedLoopLength();
	void OnRep_CurrentTime_Server(float OldValue);
	void OnRep_MatchDescriptor();
	void OnRep_MatchEventLog();
	void OnRep_ScoreTable();
	void OnRep_ScoringTeam();
	void OnRep_TeamAdvantage();
	void OnSoundCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void OnSoundPosted(const struct FPostSoundParams& PostParams, int32 PlayingID, class UNGDAkComponent* AkComponentInstance);
	void SetCharaterSelectionStatus(bool bIsActive);
	void SetCloneCooldown(int32 NewCloneCooldown);
	void SetGameCooldown(int32 NewGameCooldown);
	void SetLevelGoal(int32 NewGoal);
	void SetLoopCooldown(int32 NewLoopCooldown);
	void SetLoopLength(float NewLength);
	void SetServerAutoCloseTimer(float InSecondsToClose);
	void SetWinner(int32 TeamId, EEndGameReason Reason);
	void ShowChallengeEndPopUp();
	void ShowSkipChallengePopup(bool PauseOnShow, const class FText& LocTitle);
	void StartCooldown(float CooldownTimeToSet);
	bool TryDestroyTimeBubble();
	bool UpdateScoringTeam(int32 NewScoringTeam);

	bool AreGameplayFeedbackActive() const;
	TArray<class ATimeWatchCharacter*> GetAllAlliedClones(int32 TeamPlayerID, int32 TeamId) const;
	TArray<class ATimeWatchCharacter*> GetAllClones() const;
	TArray<class ATimeWatchCharacter*> GetAllClonesByLoopIndex(int32 LoopIndex) const;
	TArray<class ATimeWatchCharacter*> GetAllClonesForPlayer(int32 PlayerId) const;
	TArray<class ATimeWatchCharacter*> GetAllClonesForTeam(int32 TeamId) const;
	class UTWChallengeObserver* GetChallengeObserver() const;
	class ATimeWatchCharacter* GetClone(int32 TeamId, int32 CloneId) const;
	int32 GetCloneCount() const;
	class ATimeWatchCharacter* GetCloneForPlayer(int32 PlayerId, int32 CloneId) const;
	int32 GetCurrentCloneIndex() const;
	float GetCurrentTime() const;
	EEndGameReason GetEndGameReason() const;
	EFluxLoopResult GetLastLoopResult() const;
	int32 GetLastScoringTeamID() const;
	int32 GetLevelGoal() const;
	float GetLoopLength() const;
	class AMatchEventLog* GetMatchEventLog() const;
	EOvertimeMode GetOverTimeMode() const;
	int32 GetPlayerCount() const;
	float GetPlayRate() const;
	int32 GetScore(const int32 TeamId) const;
	bool HasGameStarted() const;
	bool IsServerUnresponsive() const;
	bool IsTimeFreeze() const;
	bool IsTimeGoingBackwards() const;
	bool IsTimeGoingForward() const;
	bool IsWaitingForPlayerSync() const;
	bool ShouldSpawnTimeBubble() const;
	bool UsingQuantumTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchGameState">();
	}
	static class ATimeWatchGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeWatchGameState>();
	}
};
static_assert(alignof(ATimeWatchGameState) == 0x000008, "Wrong alignment on ATimeWatchGameState");
static_assert(sizeof(ATimeWatchGameState) == 0x000788, "Wrong size on ATimeWatchGameState");
static_assert(offsetof(ATimeWatchGameState, OnScoreChanged) == 0x000338, "Member 'ATimeWatchGameState::OnScoreChanged' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnLoopChanged) == 0x000348, "Member 'ATimeWatchGameState::OnLoopChanged' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnVictoryCondition) == 0x000358, "Member 'ATimeWatchGameState::OnVictoryCondition' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnShowMatchResults) == 0x000368, "Member 'ATimeWatchGameState::OnShowMatchResults' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnWeaponSelectionCollapse) == 0x000378, "Member 'ATimeWatchGameState::OnWeaponSelectionCollapse' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnTeamScoredPoint) == 0x000388, "Member 'ATimeWatchGameState::OnTeamScoredPoint' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnTeamScoringChanged) == 0x000398, "Member 'ATimeWatchGameState::OnTeamScoringChanged' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnMatchEventLogCreated) == 0x0003A8, "Member 'ATimeWatchGameState::OnMatchEventLogCreated' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnAllClonesReady) == 0x0003B8, "Member 'ATimeWatchGameState::OnAllClonesReady' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnTeamsAssigned) == 0x0003C8, "Member 'ATimeWatchGameState::OnTeamsAssigned' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnTeamAdvantageChanged) == 0x0003D8, "Member 'ATimeWatchGameState::OnTeamAdvantageChanged' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnContinueInSkipChallengePopup) == 0x0003E8, "Member 'ATimeWatchGameState::OnContinueInSkipChallengePopup' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnPingMarkerAdded) == 0x0003F8, "Member 'ATimeWatchGameState::OnPingMarkerAdded' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnPingMarkerRemoved) == 0x000408, "Member 'ATimeWatchGameState::OnPingMarkerRemoved' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, MaxSyncWaitTime) == 0x000420, "Member 'ATimeWatchGameState::MaxSyncWaitTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, MinSyncWaitTime) == 0x000424, "Member 'ATimeWatchGameState::MinSyncWaitTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, MaxTimeBeforeCatchupWarning) == 0x000428, "Member 'ATimeWatchGameState::MaxTimeBeforeCatchupWarning' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, MaxGameTimeBeforeDisconnectWarning) == 0x00042C, "Member 'ATimeWatchGameState::MaxGameTimeBeforeDisconnectWarning' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, BubbleCollapseAnimationLength) == 0x000430, "Member 'ATimeWatchGameState::BubbleCollapseAnimationLength' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, TimeDilationScalar) == 0x000434, "Member 'ATimeWatchGameState::TimeDilationScalar' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, TeamAdvantage) == 0x000440, "Member 'ATimeWatchGameState::TeamAdvantage' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, StateCompletePlayers) == 0x000450, "Member 'ATimeWatchGameState::StateCompletePlayers' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, ProjectileManager) == 0x000458, "Member 'ATimeWatchGameState::ProjectileManager' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, bShouldShowWeaponInteractionWidget) == 0x000460, "Member 'ATimeWatchGameState::bShouldShowWeaponInteractionWidget' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LoadedReplayCharSelectionData) == 0x000468, "Member 'ATimeWatchGameState::LoadedReplayCharSelectionData' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, PingMarkers) == 0x000490, "Member 'ATimeWatchGameState::PingMarkers' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, GameStateMatchDescriptor) == 0x0004E0, "Member 'ATimeWatchGameState::GameStateMatchDescriptor' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, RoundCounter) == 0x000530, "Member 'ATimeWatchGameState::RoundCounter' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LoopCounter) == 0x000534, "Member 'ATimeWatchGameState::LoopCounter' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LastRoundMaxLoopReached) == 0x00053C, "Member 'ATimeWatchGameState::LastRoundMaxLoopReached' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, ScoringTeam) == 0x000540, "Member 'ATimeWatchGameState::ScoringTeam' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, EnviromentalTime) == 0x000548, "Member 'ATimeWatchGameState::EnviromentalTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, MPC_OutlineColors) == 0x000550, "Member 'ATimeWatchGameState::MPC_OutlineColors' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, MPC_EviromentalTeamColors) == 0x000558, "Member 'ATimeWatchGameState::MPC_EviromentalTeamColors' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, MatchEventLog) == 0x000560, "Member 'ATimeWatchGameState::MatchEventLog' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, CooldownTime) == 0x000568, "Member 'ATimeWatchGameState::CooldownTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, WeaponSelectionCollapseAnimStartTime) == 0x00056C, "Member 'ATimeWatchGameState::WeaponSelectionCollapseAnimStartTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LastLoopResult) == 0x000571, "Member 'ATimeWatchGameState::LastLoopResult' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, GameCooldown) == 0x000574, "Member 'ATimeWatchGameState::GameCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LoopCooldown) == 0x000578, "Member 'ATimeWatchGameState::LoopCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, CloneCooldown) == 0x00057C, "Member 'ATimeWatchGameState::CloneCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LastLoopPreviewCooldown) == 0x000580, "Member 'ATimeWatchGameState::LastLoopPreviewCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, ForwardEndCooldown) == 0x000584, "Member 'ATimeWatchGameState::ForwardEndCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, bAllowPlayerInputAfterScore) == 0x000588, "Member 'ATimeWatchGameState::bAllowPlayerInputAfterScore' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, bTimelinesShouldRecord) == 0x000589, "Member 'ATimeWatchGameState::bTimelinesShouldRecord' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, CustomTimeDilationRemainingTime) == 0x000590, "Member 'ATimeWatchGameState::CustomTimeDilationRemainingTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, Score) == 0x000598, "Member 'ATimeWatchGameState::Score' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, TWGameGlobals) == 0x0005B0, "Member 'ATimeWatchGameState::TWGameGlobals' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, TWGameObserver) == 0x0005B8, "Member 'ATimeWatchGameState::TWGameObserver' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, TWAbilitySystem) == 0x0005C0, "Member 'ATimeWatchGameState::TWAbilitySystem' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, ProjectileManagerClass) == 0x0005C8, "Member 'ATimeWatchGameState::ProjectileManagerClass' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, OnStateChanged) == 0x0005D0, "Member 'ATimeWatchGameState::OnStateChanged' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, PlayRate) == 0x0005E0, "Member 'ATimeWatchGameState::PlayRate' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, RewindOffset) == 0x0005E4, "Member 'ATimeWatchGameState::RewindOffset' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, RewindRate) == 0x0005E8, "Member 'ATimeWatchGameState::RewindRate' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LoopRewindRatio) == 0x0005EC, "Member 'ATimeWatchGameState::LoopRewindRatio' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LoopReplayRewindRate) == 0x0005F0, "Member 'ATimeWatchGameState::LoopReplayRewindRate' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, LoopReplayRewindStopAtRatio) == 0x0005F4, "Member 'ATimeWatchGameState::LoopReplayRewindStopAtRatio' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, FreezeTimeAfterScore) == 0x0005F8, "Member 'ATimeWatchGameState::FreezeTimeAfterScore' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, TimeDilationScalarCurve) == 0x000600, "Member 'ATimeWatchGameState::TimeDilationScalarCurve' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, TimeDilationScalarCurve_ForwardEnd) == 0x000608, "Member 'ATimeWatchGameState::TimeDilationScalarCurve_ForwardEnd' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, PreForwardCurlPlayRateScalar) == 0x000610, "Member 'ATimeWatchGameState::PreForwardCurlPlayRateScalar' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, ActorsCustomTimeDilationScalarCurves) == 0x000618, "Member 'ATimeWatchGameState::ActorsCustomTimeDilationScalarCurves' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, CurrentTime) == 0x000668, "Member 'ATimeWatchGameState::CurrentTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, CurrentTime_Server) == 0x00066C, "Member 'ATimeWatchGameState::CurrentTime_Server' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, CurrentClone) == 0x000674, "Member 'ATimeWatchGameState::CurrentClone' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, CurrentLoop) == 0x000678, "Member 'ATimeWatchGameState::CurrentLoop' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, CurrentState) == 0x00067C, "Member 'ATimeWatchGameState::CurrentState' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, PreviousState) == 0x00067D, "Member 'ATimeWatchGameState::PreviousState' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, FluxTimerPaused) == 0x00067E, "Member 'ATimeWatchGameState::FluxTimerPaused' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, GameRandomSeed) == 0x000680, "Member 'ATimeWatchGameState::GameRandomSeed' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, Timelines) == 0x000688, "Member 'ATimeWatchGameState::Timelines' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, PendingDurationSoundEvents) == 0x000698, "Member 'ATimeWatchGameState::PendingDurationSoundEvents' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, ReversableSoundEvents) == 0x0006E8, "Member 'ATimeWatchGameState::ReversableSoundEvents' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, AllClones) == 0x000700, "Member 'ATimeWatchGameState::AllClones' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, AllPlayerStates) == 0x000710, "Member 'ATimeWatchGameState::AllPlayerStates' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, ChallengeObserver) == 0x000720, "Member 'ATimeWatchGameState::ChallengeObserver' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, ServerAutoCloseTimer) == 0x000738, "Member 'ATimeWatchGameState::ServerAutoCloseTimer' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, DefaultTooltipManagerClass) == 0x000748, "Member 'ATimeWatchGameState::DefaultTooltipManagerClass' has a wrong offset!");
static_assert(offsetof(ATimeWatchGameState, SwitchInteractionAuditor) == 0x000778, "Member 'ATimeWatchGameState::SwitchInteractionAuditor' has a wrong offset!");

// Class TimeWatch.TWDominationGameState
// 0x0018 (0x07A0 - 0x0788)
class ATWDominationGameState final : public ATimeWatchGameState
{
public:
	uint8                                         Pad_788[0x18];                                     // 0x0788(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWDominationGameState">();
	}
	static class ATWDominationGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWDominationGameState>();
	}
};
static_assert(alignof(ATWDominationGameState) == 0x000008, "Wrong alignment on ATWDominationGameState");
static_assert(sizeof(ATWDominationGameState) == 0x0007A0, "Wrong size on ATWDominationGameState");

// Class TimeWatch.FluxExplodingBarrel
// 0x0078 (0x02A0 - 0x0228)
class AFluxExplodingBarrel : public AStaticMeshActor
{
public:
	class UFluxTimelineBarrel*                    Timeline;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       DamageOverlapComp;                                 // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ExplosionMesh;                                     // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageScale;                                       // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxImpulseForce;                                   // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFuseTime;                                       // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxExplosionTime;                                  // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Simulation_MaxExplosionTime;                       // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Simulation_TickTime;                               // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionScalar;                                   // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionScalar_Simulation;                        // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoneToApplyImpulse;                                // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Explosion_DamageOverTime;                          // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Explosion_RagdollImpulseScalar;                    // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Explosion_RelativeSize;                            // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ExplosionVisual_RelativeSize;                      // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            FuseVisualCurve;                                   // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRayCastCollisionCheck;                            // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             DamageBlockCollisionChannel;                       // 0x0291(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_292[0xE];                                      // 0x0292(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateFuse(class AActor* ExplosionCauser, float CustomGameTime);
	void Cosmetic_OnFuseTimestampChange(float NewFuseTimestamp);
	void Cosmetic_UpdateBarrelVisibility(bool IsVisible);
	void Cosmetic_UpdateExplosionFX(float VisualExplosionFactor);
	float GetExplosionSimulationRelativeSize(float ExplosionFactor);
	float GetExplosionVisualRelativeSize(float ExplosionFactor);
	float GetFuseFactorCurvedByVisual(float FuseFactor);
	bool IsBarrelMeshVisible();
	void MultiCast_ActivateFuse(class AActor* ExplosionCauser, float TriggerTimestamp);
	void Reset();

	EFluxBarrelState GetCurrentState() const;
	float GetExplosionFactor_Simulation() const;
	float GetExplosionFactor_Visual() const;
	float GetFuseFactor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxExplodingBarrel">();
	}
	static class AFluxExplodingBarrel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluxExplodingBarrel>();
	}
};
static_assert(alignof(AFluxExplodingBarrel) == 0x000008, "Wrong alignment on AFluxExplodingBarrel");
static_assert(sizeof(AFluxExplodingBarrel) == 0x0002A0, "Wrong size on AFluxExplodingBarrel");
static_assert(offsetof(AFluxExplodingBarrel, Timeline) == 0x000228, "Member 'AFluxExplodingBarrel::Timeline' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, DamageOverlapComp) == 0x000230, "Member 'AFluxExplodingBarrel::DamageOverlapComp' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, ExplosionMesh) == 0x000238, "Member 'AFluxExplodingBarrel::ExplosionMesh' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, DamageScale) == 0x000240, "Member 'AFluxExplodingBarrel::DamageScale' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, MaxImpulseForce) == 0x000244, "Member 'AFluxExplodingBarrel::MaxImpulseForce' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, MaxFuseTime) == 0x000248, "Member 'AFluxExplodingBarrel::MaxFuseTime' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, MaxExplosionTime) == 0x00024C, "Member 'AFluxExplodingBarrel::MaxExplosionTime' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, Simulation_MaxExplosionTime) == 0x000250, "Member 'AFluxExplodingBarrel::Simulation_MaxExplosionTime' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, Simulation_TickTime) == 0x000254, "Member 'AFluxExplodingBarrel::Simulation_TickTime' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, ExplosionScalar) == 0x000258, "Member 'AFluxExplodingBarrel::ExplosionScalar' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, ExplosionScalar_Simulation) == 0x00025C, "Member 'AFluxExplodingBarrel::ExplosionScalar_Simulation' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, BoneToApplyImpulse) == 0x000260, "Member 'AFluxExplodingBarrel::BoneToApplyImpulse' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, Explosion_DamageOverTime) == 0x000268, "Member 'AFluxExplodingBarrel::Explosion_DamageOverTime' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, Explosion_RagdollImpulseScalar) == 0x000270, "Member 'AFluxExplodingBarrel::Explosion_RagdollImpulseScalar' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, Explosion_RelativeSize) == 0x000278, "Member 'AFluxExplodingBarrel::Explosion_RelativeSize' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, ExplosionVisual_RelativeSize) == 0x000280, "Member 'AFluxExplodingBarrel::ExplosionVisual_RelativeSize' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, FuseVisualCurve) == 0x000288, "Member 'AFluxExplodingBarrel::FuseVisualCurve' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, bRayCastCollisionCheck) == 0x000290, "Member 'AFluxExplodingBarrel::bRayCastCollisionCheck' has a wrong offset!");
static_assert(offsetof(AFluxExplodingBarrel, DamageBlockCollisionChannel) == 0x000291, "Member 'AFluxExplodingBarrel::DamageBlockCollisionChannel' has a wrong offset!");

// Class TimeWatch.FluxPlayerController
// 0x0350 (0x09F8 - 0x06A8)
class AFluxPlayerController : public ANGDPlayerController
{
public:
	uint8                                         Pad_6A8[0x18];                                     // 0x06A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHUDInitialized;                                  // 0x06C0(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D0[0x30];                                     // 0x06D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATimeWatchCharacter* TWChar)> OnPossesedCharacter;           // 0x0700(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bWantsToSeePlaybook;                               // 0x0710(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_711[0x7];                                      // 0x0711(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bWantsToRematch)> OnRematchStateChanged;                      // 0x0718(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRematchVoided;                                   // 0x0728(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsReplayController;                               // 0x0738(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_739[0x3];                                      // 0x0739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerInfo                            PlayerInfo;                                        // 0x073C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnInflictDamage;                       // 0x0748(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnKilledEnemy;                         // 0x07A0(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnReceivedDamage;                      // 0x07F8(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnActiveCloneDied;                     // 0x0850(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        NGDAk_LocalSounds;                                 // 0x08A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPingMarkerEnabled;                                // 0x08B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B1[0x3];                                      // 0x08B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PingDetectionLenght;                               // 0x08B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PingOnObjectMaxVolume;                             // 0x08B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PingOnObjectMinSideLenght;                         // 0x08BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PingOnObjectMaxSideLenght;                         // 0x08C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             PingMarkerTraceChannel;                            // 0x08C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C5[0x3];                                      // 0x08C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldActionsTimeThreshold;                          // 0x08C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavigationThreshold;                               // 0x08CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           QuickChatTimerHandle;                              // 0x08D0(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D8[0x2];                                      // 0x08D8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPlayerInputEnabled;                             // 0x08DA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8DB[0x25];                                     // 0x08DB(0x0025)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNetworkReady;                                     // 0x0900(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_901[0x3];                                      // 0x0901(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APawn>                   LastControlledPawn;                                // 0x0904(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90C[0x4];                                      // 0x090C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SustainableActionNames;                            // 0x0910(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameStateSyncData                     ResyncData;                                        // 0x0920(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMatchResultDataResponse               MatchResultOldData;                                // 0x0930(0x0058)(Protected, NativeAccessSpecifierProtected)
	struct FMatchResultDataResponse               MatchResultNewData;                                // 0x0988(0x0058)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E0[0x17];                                     // 0x09E0(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayerWantsToRematch;                             // 0x09F7(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_DrawActorSample(class AActor* RewindableActor);
	void BP_DrawActorSampleAtTime(class AActor* RewindableActor, float GameTime);
	void BP_OnGameInitialized();
	void BP_OnStandaloneGamePause();
	void BP_OnStandaloneGameResume();
	void BP_ServerTestBacktrace();
	void CanDamageClones(bool bCanDamageClones);
	void CheatWeapons();
	void CheckRemoveReplayControllerListener();
	void Client_DrawActorSAmples(class AActor* RewindableActor, const struct FActorSample& ServerSample, const struct FLinearColor& DebugColor);
	void Client_OnPostLogin(const struct FPlayerInfo& NewPlayerInfo);
	void Client_ReceiveChatMessage(class APlayerState* Sender, const class FString& TextMessage, const EChatChannel Channel);
	void Client_ReceiveQuickChat(class APlayerState* PS, uint16 QuickChatID);
	void ClientOnMatchResultComplete(bool bWasSuccessful, const struct FMatchResultDataResponse& PlayerOldData, const struct FMatchResultDataResponse& PlayerNewData);
	void ClientOnPlayersReady();
	void ClientOnPossesed();
	void ClientOnRematchVoided();
	void ClientOnRivalRematchState(bool bRivalWantsToRematch);
	void ClientSetVelocity(class UTimeWatchMovementComponent* TWMovementComponent, float Velocity);
	void ClientShotEnemyEffect(bool IsHeadShot);
	void ClientSyncState(const struct FGameStateSyncData& InResyncData);
	void DetectCurrentInputDevice(const struct FKey& Key);
	void DetectMouseInput(float ammount);
	void ForceServerCrash();
	void Forfeit();
	float GetTurnMultiplier();
	void LoopLength(float Lenght);
	void Next();
	void OnConfirmPressed();
	void OnEscapePressed();
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnNavigationConfirm();
	void OnPlayerControllerInputChanged(class APlayerController* PlayerController);
	void OnPlayersReady();
	void OnShotEnemyEffect(bool IsHeadShot);
	void OnToggleHUDCheatPressed();
	void RefreshGamepadCvarValue(const class FString& CVarName, float InValue);
	void RefreshGamepadVariables();
	void RequestSkipPointReplay();
	void SelectQuickChat(int32 Index_0);
	void Server_AddPingMarker(const struct FPingMarker& NewPingMarker);
	void Server_ForceServerCrash();
	void Server_PostQuickChat(uint16 QuickChatID);
	void Server_PostTextChatMessage(const struct FTextChatMessage& Message, const EChatChannel Channel);
	void Server_RemovePingMarker(int32 PingMarkerID);
	void Server_RequestActorSamples(class AActor* RewindableActor, const float SynchronizedGameTime);
	void ServerAdvanceFluxState();
	void ServerConfirmPlayerGameStateCatchUp();
	void ServerForfeit();
	void ServerLoopLengthFluxTime(float Length);
	void ServerOnControllerReady();
	void ServerRequestCustomiztionUpdate(const struct FCustomizationEntry& CustomizationEntry);
	void ServerRequestPointReviewSkip();
	void ServerSetCanDamageClones(bool bCanDamageClones);
	void ServerSetNetworkReady();
	void ServerSetRematchState(bool bWantsToRematch);
	void ServerSetVelocity(float Velocity);
	void ServerShowAmmo();
	void ServerStartFluxTime();
	void ServerStopFluxTime();
	void ServerSwitchToSpectatorMode();
	void ServerTestBacktrace();
	void ServerWin();
	void SetActiveGhostVisibility(bool bNewVisibility);
	void SetAdsSensitivityMultiplier(float NewFocusingTurnMultiplier);
	void SetPauseState(bool bIsPaused);
	void SetTurnSensitivity(float NewTurnMultiplier);
	void SetVelocity(float Velocity);
	void ShowAmmo();
	void Start();
	void Stop();
	void ToggleHUDVisibility();
	void ToggleQuickChatCategory(EQuickChatCategory QuickChatCategory);
	void Win();

	class UNGDAkComponent* GetAkLocalSounds() const;
	int32 GetTeamId() const;
	bool IsSpectator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxPlayerController">();
	}
	static class AFluxPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluxPlayerController>();
	}
};
static_assert(alignof(AFluxPlayerController) == 0x000008, "Wrong alignment on AFluxPlayerController");
static_assert(sizeof(AFluxPlayerController) == 0x0009F8, "Wrong size on AFluxPlayerController");
static_assert(offsetof(AFluxPlayerController, OnHUDInitialized) == 0x0006C0, "Member 'AFluxPlayerController::OnHUDInitialized' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, OnPossesedCharacter) == 0x000700, "Member 'AFluxPlayerController::OnPossesedCharacter' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, bWantsToSeePlaybook) == 0x000710, "Member 'AFluxPlayerController::bWantsToSeePlaybook' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, OnRematchStateChanged) == 0x000718, "Member 'AFluxPlayerController::OnRematchStateChanged' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, OnRematchVoided) == 0x000728, "Member 'AFluxPlayerController::OnRematchVoided' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, bIsReplayController) == 0x000738, "Member 'AFluxPlayerController::bIsReplayController' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, PlayerInfo) == 0x00073C, "Member 'AFluxPlayerController::PlayerInfo' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, SoundConfig_OnInflictDamage) == 0x000748, "Member 'AFluxPlayerController::SoundConfig_OnInflictDamage' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, SoundConfig_OnKilledEnemy) == 0x0007A0, "Member 'AFluxPlayerController::SoundConfig_OnKilledEnemy' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, SoundConfig_OnReceivedDamage) == 0x0007F8, "Member 'AFluxPlayerController::SoundConfig_OnReceivedDamage' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, SoundConfig_OnActiveCloneDied) == 0x000850, "Member 'AFluxPlayerController::SoundConfig_OnActiveCloneDied' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, NGDAk_LocalSounds) == 0x0008A8, "Member 'AFluxPlayerController::NGDAk_LocalSounds' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, bPingMarkerEnabled) == 0x0008B0, "Member 'AFluxPlayerController::bPingMarkerEnabled' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, PingDetectionLenght) == 0x0008B4, "Member 'AFluxPlayerController::PingDetectionLenght' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, PingOnObjectMaxVolume) == 0x0008B8, "Member 'AFluxPlayerController::PingOnObjectMaxVolume' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, PingOnObjectMinSideLenght) == 0x0008BC, "Member 'AFluxPlayerController::PingOnObjectMinSideLenght' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, PingOnObjectMaxSideLenght) == 0x0008C0, "Member 'AFluxPlayerController::PingOnObjectMaxSideLenght' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, PingMarkerTraceChannel) == 0x0008C4, "Member 'AFluxPlayerController::PingMarkerTraceChannel' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, HoldActionsTimeThreshold) == 0x0008C8, "Member 'AFluxPlayerController::HoldActionsTimeThreshold' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, NavigationThreshold) == 0x0008CC, "Member 'AFluxPlayerController::NavigationThreshold' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, QuickChatTimerHandle) == 0x0008D0, "Member 'AFluxPlayerController::QuickChatTimerHandle' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, bIsPlayerInputEnabled) == 0x0008DA, "Member 'AFluxPlayerController::bIsPlayerInputEnabled' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, bNetworkReady) == 0x000900, "Member 'AFluxPlayerController::bNetworkReady' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, LastControlledPawn) == 0x000904, "Member 'AFluxPlayerController::LastControlledPawn' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, SustainableActionNames) == 0x000910, "Member 'AFluxPlayerController::SustainableActionNames' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, ResyncData) == 0x000920, "Member 'AFluxPlayerController::ResyncData' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, MatchResultOldData) == 0x000930, "Member 'AFluxPlayerController::MatchResultOldData' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, MatchResultNewData) == 0x000988, "Member 'AFluxPlayerController::MatchResultNewData' has a wrong offset!");
static_assert(offsetof(AFluxPlayerController, bPlayerWantsToRematch) == 0x0009F7, "Member 'AFluxPlayerController::bPlayerWantsToRematch' has a wrong offset!");

// Class TimeWatch.TWCheatManager
// 0x0000 (0x0078 - 0x0078)
class UTWCheatManager final : public UNGDCheatManager
{
public:
	void ChangeCulture(const class FString& Culture);
	void StartSpectate();
	void ToggleHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCheatManager">();
	}
	static class UTWCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWCheatManager>();
	}
};
static_assert(alignof(UTWCheatManager) == 0x000008, "Wrong alignment on UTWCheatManager");
static_assert(sizeof(UTWCheatManager) == 0x000078, "Wrong size on UTWCheatManager");

// Class TimeWatch.FluxPlayerStart
// 0x0010 (0x0258 - 0x0248)
class AFluxPlayerStart final : public APlayerStart
{
public:
	int32                                         TeamId;                                            // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamPlayerIndex;                                   // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CloneIndex;                                        // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlreadyAssigned;                                  // 0x0254(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetCharacterEyeLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxPlayerStart">();
	}
	static class AFluxPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluxPlayerStart>();
	}
};
static_assert(alignof(AFluxPlayerStart) == 0x000008, "Wrong alignment on AFluxPlayerStart");
static_assert(sizeof(AFluxPlayerStart) == 0x000258, "Wrong size on AFluxPlayerStart");
static_assert(offsetof(AFluxPlayerStart, TeamId) == 0x000248, "Member 'AFluxPlayerStart::TeamId' has a wrong offset!");
static_assert(offsetof(AFluxPlayerStart, TeamPlayerIndex) == 0x00024C, "Member 'AFluxPlayerStart::TeamPlayerIndex' has a wrong offset!");
static_assert(offsetof(AFluxPlayerStart, CloneIndex) == 0x000250, "Member 'AFluxPlayerStart::CloneIndex' has a wrong offset!");
static_assert(offsetof(AFluxPlayerStart, bAlreadyAssigned) == 0x000254, "Member 'AFluxPlayerStart::bAlreadyAssigned' has a wrong offset!");

// Class TimeWatch.FluxPlayerState
// 0x00B8 (0x0408 - 0x0350)
class AFluxPlayerState final : public ANGDPlayerState
{
public:
	uint8                                         Pad_350[0xD];                                      // 0x0350(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantsToSkipPointReview;                           // 0x035D(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35E[0x2];                                      // 0x035E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerLeagueBoardLevel;                            // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTasksComponent*                GameplayTaskComponent;                             // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCustomizationReplicated;                         // 0x0370(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FPlayerInfo                            PlayerInfo;                                        // 0x0380(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWAbilitiesComponent*                  AbilitiesComponent;                                // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoTeamID_Override;                               // 0x0398(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomizationEntry                    CustomizationProperties;                           // 0x03A0(0x0068)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_Customization();
	void OnRep_PlayerInfo();
	void ServerSendLocalData(const struct FPlayerLocalData& LocalData);
	void ServerValidateCustomization(const struct FCustomizationEntry& Customization);

	class UTWAbilitiesComponent* GetAbilitiesComponent() const;
	class FString GetCharacterIdentifier() const;
	class FString GetCharacterName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxPlayerState">();
	}
	static class AFluxPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluxPlayerState>();
	}
};
static_assert(alignof(AFluxPlayerState) == 0x000008, "Wrong alignment on AFluxPlayerState");
static_assert(sizeof(AFluxPlayerState) == 0x000408, "Wrong size on AFluxPlayerState");
static_assert(offsetof(AFluxPlayerState, bWantsToSkipPointReview) == 0x00035D, "Member 'AFluxPlayerState::bWantsToSkipPointReview' has a wrong offset!");
static_assert(offsetof(AFluxPlayerState, PlayerLeagueBoardLevel) == 0x000360, "Member 'AFluxPlayerState::PlayerLeagueBoardLevel' has a wrong offset!");
static_assert(offsetof(AFluxPlayerState, GameplayTaskComponent) == 0x000368, "Member 'AFluxPlayerState::GameplayTaskComponent' has a wrong offset!");
static_assert(offsetof(AFluxPlayerState, OnCustomizationReplicated) == 0x000370, "Member 'AFluxPlayerState::OnCustomizationReplicated' has a wrong offset!");
static_assert(offsetof(AFluxPlayerState, PlayerInfo) == 0x000380, "Member 'AFluxPlayerState::PlayerInfo' has a wrong offset!");
static_assert(offsetof(AFluxPlayerState, AbilitiesComponent) == 0x000390, "Member 'AFluxPlayerState::AbilitiesComponent' has a wrong offset!");
static_assert(offsetof(AFluxPlayerState, ExpoTeamID_Override) == 0x000398, "Member 'AFluxPlayerState::ExpoTeamID_Override' has a wrong offset!");
static_assert(offsetof(AFluxPlayerState, CustomizationProperties) == 0x0003A0, "Member 'AFluxPlayerState::CustomizationProperties' has a wrong offset!");

// Class TimeWatch.FluxTimeline
// 0x0018 (0x00C8 - 0x00B0)
class UFluxTimeline : public UActorComponent
{
public:
	bool                                          bRecordOnTick;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SampleTime;                                        // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x4];                                       // 0x00B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCustomTimeDilationIsAffectedByGlobal;             // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD[0xB];                                       // 0x00BD(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxTimeline">();
	}
	static class UFluxTimeline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxTimeline>();
	}
};
static_assert(alignof(UFluxTimeline) == 0x000008, "Wrong alignment on UFluxTimeline");
static_assert(sizeof(UFluxTimeline) == 0x0000C8, "Wrong size on UFluxTimeline");
static_assert(offsetof(UFluxTimeline, bRecordOnTick) == 0x0000B0, "Member 'UFluxTimeline::bRecordOnTick' has a wrong offset!");
static_assert(offsetof(UFluxTimeline, SampleTime) == 0x0000B4, "Member 'UFluxTimeline::SampleTime' has a wrong offset!");
static_assert(offsetof(UFluxTimeline, bCustomTimeDilationIsAffectedByGlobal) == 0x0000BC, "Member 'UFluxTimeline::bCustomTimeDilationIsAffectedByGlobal' has a wrong offset!");

// Class TimeWatch.FluxTimelineBarrel
// 0x0050 (0x0118 - 0x00C8)
class UFluxTimelineBarrel final : public UFluxTimeline
{
public:
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBarrelParadoxData>             ReplayParadoxes;                                   // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 HistoricTimelines;                                 // 0x00F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ATWExplosionGhost>          ReplayParadoxGhost;                                // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFluxExplodingBarrel*                   Barrel;                                            // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxTimelineBarrel">();
	}
	static class UFluxTimelineBarrel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxTimelineBarrel>();
	}
};
static_assert(alignof(UFluxTimelineBarrel) == 0x000008, "Wrong alignment on UFluxTimelineBarrel");
static_assert(sizeof(UFluxTimelineBarrel) == 0x000118, "Wrong size on UFluxTimelineBarrel");
static_assert(offsetof(UFluxTimelineBarrel, ReplayParadoxes) == 0x0000E8, "Member 'UFluxTimelineBarrel::ReplayParadoxes' has a wrong offset!");
static_assert(offsetof(UFluxTimelineBarrel, HistoricTimelines) == 0x0000F8, "Member 'UFluxTimelineBarrel::HistoricTimelines' has a wrong offset!");
static_assert(offsetof(UFluxTimelineBarrel, ReplayParadoxGhost) == 0x000108, "Member 'UFluxTimelineBarrel::ReplayParadoxGhost' has a wrong offset!");
static_assert(offsetof(UFluxTimelineBarrel, Barrel) == 0x000110, "Member 'UFluxTimelineBarrel::Barrel' has a wrong offset!");

// Class TimeWatch.TimeWatchEvent
// 0x0010 (0x0038 - 0x0028)
class UTimeWatchEvent : public UObject
{
public:
	int32                                         LoopCount;                                         // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundCount;                                        // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchEvent">();
	}
	static class UTimeWatchEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeWatchEvent>();
	}
};
static_assert(alignof(UTimeWatchEvent) == 0x000008, "Wrong alignment on UTimeWatchEvent");
static_assert(sizeof(UTimeWatchEvent) == 0x000038, "Wrong size on UTimeWatchEvent");
static_assert(offsetof(UTimeWatchEvent, LoopCount) == 0x000028, "Member 'UTimeWatchEvent::LoopCount' has a wrong offset!");
static_assert(offsetof(UTimeWatchEvent, RoundCount) == 0x00002C, "Member 'UTimeWatchEvent::RoundCount' has a wrong offset!");
static_assert(offsetof(UTimeWatchEvent, Timestamp) == 0x000030, "Member 'UTimeWatchEvent::Timestamp' has a wrong offset!");
static_assert(offsetof(UTimeWatchEvent, TeamId) == 0x000034, "Member 'UTimeWatchEvent::TeamId' has a wrong offset!");

// Class TimeWatch.TWKillEvent
// 0x0010 (0x0048 - 0x0038)
class UTWKillEvent : public UTimeWatchEvent
{
public:
	class AActor*                                 Instigator;                                        // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATimeWatchCharacter*                    Victim;                                            // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWKillEvent">();
	}
	static class UTWKillEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWKillEvent>();
	}
};
static_assert(alignof(UTWKillEvent) == 0x000008, "Wrong alignment on UTWKillEvent");
static_assert(sizeof(UTWKillEvent) == 0x000048, "Wrong size on UTWKillEvent");
static_assert(offsetof(UTWKillEvent, Instigator) == 0x000038, "Member 'UTWKillEvent::Instigator' has a wrong offset!");
static_assert(offsetof(UTWKillEvent, Victim) == 0x000040, "Member 'UTWKillEvent::Victim' has a wrong offset!");

// Class TimeWatch.TWHeadshotForKillfeedKill
// 0x0008 (0x0050 - 0x0048)
class UTWHeadshotForKillfeedKill final : public UTWKillEvent
{
public:
	bool                                          bWasPrefiredBoosted;                               // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWHeadshotForKillfeedKill">();
	}
	static class UTWHeadshotForKillfeedKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWHeadshotForKillfeedKill>();
	}
};
static_assert(alignof(UTWHeadshotForKillfeedKill) == 0x000008, "Wrong alignment on UTWHeadshotForKillfeedKill");
static_assert(sizeof(UTWHeadshotForKillfeedKill) == 0x000050, "Wrong size on UTWHeadshotForKillfeedKill");
static_assert(offsetof(UTWHeadshotForKillfeedKill, bWasPrefiredBoosted) == 0x000048, "Member 'UTWHeadshotForKillfeedKill::bWasPrefiredBoosted' has a wrong offset!");

// Class TimeWatch.FluxTimelineCaptureDomination
// 0x0020 (0x00E8 - 0x00C8)
class UFluxTimelineCaptureDomination final : public UFluxTimeline
{
public:
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxTimelineCaptureDomination">();
	}
	static class UFluxTimelineCaptureDomination* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxTimelineCaptureDomination>();
	}
};
static_assert(alignof(UFluxTimelineCaptureDomination) == 0x000008, "Wrong alignment on UFluxTimelineCaptureDomination");
static_assert(sizeof(UFluxTimelineCaptureDomination) == 0x0000E8, "Wrong size on UFluxTimelineCaptureDomination");

// Class TimeWatch.FluxTimelineCharacter
// 0x00D8 (0x01A0 - 0x00C8)
class UFluxTimelineCharacter final : public UFluxTimeline
{
public:
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 WeaponChangeSnapshot;                              // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ATimeWatchCharacter*                    PlayerCharacter;                                   // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATWCharacterGhost>          ReplayParadoxGhost;                                // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FParadoxData>              ReplayParadoxes;                                   // 0x0108(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x38];                                     // 0x0158(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ATWPlaybook*                            Playbook;                                          // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadTimeline();

	struct FPoseSnapshot GetLastSaved1PPose() const;
	struct FPoseSnapshot GetLastSaved3PPose() const;
	struct FVector GetLastSavedActorLocation() const;
	struct FRotator GetLastSavedControllerRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxTimelineCharacter">();
	}
	static class UFluxTimelineCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxTimelineCharacter>();
	}
};
static_assert(alignof(UFluxTimelineCharacter) == 0x000008, "Wrong alignment on UFluxTimelineCharacter");
static_assert(sizeof(UFluxTimelineCharacter) == 0x0001A0, "Wrong size on UFluxTimelineCharacter");
static_assert(offsetof(UFluxTimelineCharacter, WeaponChangeSnapshot) == 0x0000E8, "Member 'UFluxTimelineCharacter::WeaponChangeSnapshot' has a wrong offset!");
static_assert(offsetof(UFluxTimelineCharacter, PlayerCharacter) == 0x0000F8, "Member 'UFluxTimelineCharacter::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UFluxTimelineCharacter, ReplayParadoxGhost) == 0x000100, "Member 'UFluxTimelineCharacter::ReplayParadoxGhost' has a wrong offset!");
static_assert(offsetof(UFluxTimelineCharacter, ReplayParadoxes) == 0x000108, "Member 'UFluxTimelineCharacter::ReplayParadoxes' has a wrong offset!");
static_assert(offsetof(UFluxTimelineCharacter, Playbook) == 0x000190, "Member 'UFluxTimelineCharacter::Playbook' has a wrong offset!");

// Class TimeWatch.FluxTimelineFirstLoopRecorded
// 0x0040 (0x0108 - 0x00C8)
class UFluxTimelineFirstLoopRecorded final : public UFluxTimeline
{
public:
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          InterpolateKeyFrames;                              // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x1F];                                      // 0x00E9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxTimelineFirstLoopRecorded">();
	}
	static class UFluxTimelineFirstLoopRecorded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxTimelineFirstLoopRecorded>();
	}
};
static_assert(alignof(UFluxTimelineFirstLoopRecorded) == 0x000008, "Wrong alignment on UFluxTimelineFirstLoopRecorded");
static_assert(sizeof(UFluxTimelineFirstLoopRecorded) == 0x000108, "Wrong size on UFluxTimelineFirstLoopRecorded");
static_assert(offsetof(UFluxTimelineFirstLoopRecorded, InterpolateKeyFrames) == 0x0000E8, "Member 'UFluxTimelineFirstLoopRecorded::InterpolateKeyFrames' has a wrong offset!");

// Class TimeWatch.FluxTimelineProjectileManager
// 0x0020 (0x00E8 - 0x00C8)
class UFluxTimelineProjectileManager final : public UFluxTimeline
{
public:
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxTimelineProjectileManager">();
	}
	static class UFluxTimelineProjectileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxTimelineProjectileManager>();
	}
};
static_assert(alignof(UFluxTimelineProjectileManager) == 0x000008, "Wrong alignment on UFluxTimelineProjectileManager");
static_assert(sizeof(UFluxTimelineProjectileManager) == 0x0000E8, "Wrong size on UFluxTimelineProjectileManager");

// Class TimeWatch.FluxTimelineSpawner
// 0x0000 (0x00B0 - 0x00B0)
class UFluxTimelineSpawner final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxTimelineSpawner">();
	}
	static class UFluxTimelineSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxTimelineSpawner>();
	}
};
static_assert(alignof(UFluxTimelineSpawner) == 0x000008, "Wrong alignment on UFluxTimelineSpawner");
static_assert(sizeof(UFluxTimelineSpawner) == 0x0000B0, "Wrong size on UFluxTimelineSpawner");

// Class TimeWatch.FluxTimelineStaticActor
// 0x00D0 (0x0198 - 0x00C8)
class UFluxTimelineStaticActor final : public UFluxTimeline
{
public:
	uint8                                         Pad_C8[0x28];                                      // 0x00C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicEventRegistry                   PhysicsRegistry;                                   // 0x00F0(0x0018)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<uint32, class AActor*>                   ActorInteractionMap;                               // 0x0108(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(bool NewState)> OnLivePhysicsStateChange;                          // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bRewindablePhysics;                                // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugMode;                                        // 0x0169(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16A[0x1E];                                     // 0x016A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitData>                       PendingHandleImpactHitQueue;                       // 0x0188(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Multicast_SetLivePhysics(bool NewState);
	void Multicast_TrimTimeline(float InTime);
	void OnProjectileBounce(class AActor* Projectile, const struct FHitResult& InImpactResult, const struct FVector& InImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluxTimelineStaticActor">();
	}
	static class UFluxTimelineStaticActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluxTimelineStaticActor>();
	}
};
static_assert(alignof(UFluxTimelineStaticActor) == 0x000008, "Wrong alignment on UFluxTimelineStaticActor");
static_assert(sizeof(UFluxTimelineStaticActor) == 0x000198, "Wrong size on UFluxTimelineStaticActor");
static_assert(offsetof(UFluxTimelineStaticActor, PhysicsRegistry) == 0x0000F0, "Member 'UFluxTimelineStaticActor::PhysicsRegistry' has a wrong offset!");
static_assert(offsetof(UFluxTimelineStaticActor, ActorInteractionMap) == 0x000108, "Member 'UFluxTimelineStaticActor::ActorInteractionMap' has a wrong offset!");
static_assert(offsetof(UFluxTimelineStaticActor, OnLivePhysicsStateChange) == 0x000158, "Member 'UFluxTimelineStaticActor::OnLivePhysicsStateChange' has a wrong offset!");
static_assert(offsetof(UFluxTimelineStaticActor, bRewindablePhysics) == 0x000168, "Member 'UFluxTimelineStaticActor::bRewindablePhysics' has a wrong offset!");
static_assert(offsetof(UFluxTimelineStaticActor, bDebugMode) == 0x000169, "Member 'UFluxTimelineStaticActor::bDebugMode' has a wrong offset!");
static_assert(offsetof(UFluxTimelineStaticActor, PendingHandleImpactHitQueue) == 0x000188, "Member 'UFluxTimelineStaticActor::PendingHandleImpactHitQueue' has a wrong offset!");

// Class TimeWatch.FollowPoseableComponent
// 0x0030 (0x07A0 - 0x0770)
class UFollowPoseableComponent final : public UPoseableMeshComponent
{
public:
	struct FProjectionParameters                  CustomProjection;                                  // 0x0768(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ParentMesh;                                        // 0x0780(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelativeTransformSpace                       ParentCoordinateSpace;                             // 0x0788(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   PoseCoordinateSpace;                               // 0x0789(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78A[0x6];                                      // 0x078A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPoseBoneInfo>                  PoseBoneInfo;                                      // 0x0790(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void CleanBonesAndSetSkeletalMesh(class USkeletalMesh* NewMesh, bool bReinitPose);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FollowPoseableComponent">();
	}
	static class UFollowPoseableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFollowPoseableComponent>();
	}
};
static_assert(alignof(UFollowPoseableComponent) == 0x000010, "Wrong alignment on UFollowPoseableComponent");
static_assert(sizeof(UFollowPoseableComponent) == 0x0007A0, "Wrong size on UFollowPoseableComponent");
static_assert(offsetof(UFollowPoseableComponent, CustomProjection) == 0x000768, "Member 'UFollowPoseableComponent::CustomProjection' has a wrong offset!");
static_assert(offsetof(UFollowPoseableComponent, ParentMesh) == 0x000780, "Member 'UFollowPoseableComponent::ParentMesh' has a wrong offset!");
static_assert(offsetof(UFollowPoseableComponent, ParentCoordinateSpace) == 0x000788, "Member 'UFollowPoseableComponent::ParentCoordinateSpace' has a wrong offset!");
static_assert(offsetof(UFollowPoseableComponent, PoseCoordinateSpace) == 0x000789, "Member 'UFollowPoseableComponent::PoseCoordinateSpace' has a wrong offset!");
static_assert(offsetof(UFollowPoseableComponent, PoseBoneInfo) == 0x000790, "Member 'UFollowPoseableComponent::PoseBoneInfo' has a wrong offset!");

// Class TimeWatch.TWLastPointEvent
// 0x0000 (0x0038 - 0x0038)
class UTWLastPointEvent final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLastPointEvent">();
	}
	static class UTWLastPointEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLastPointEvent>();
	}
};
static_assert(alignof(UTWLastPointEvent) == 0x000008, "Wrong alignment on UTWLastPointEvent");
static_assert(sizeof(UTWLastPointEvent) == 0x000038, "Wrong size on UTWLastPointEvent");

// Class TimeWatch.FriendsListItemWidget
// 0x00B0 (0x0330 - 0x0280)
class UFriendsListItemWidget : public UNGDUserWidget
{
public:
	class UTextBlock*                             TextBlock_PlayerName;                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_Status;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Avatar;                                      // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Background;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Icon_Invited_Friend;                               // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Friends_avatar_gradient;                           // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_Action;                                     // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             OnlineBackground;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             OfflineBackground;                                 // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PartyBackground;                                   // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OfflineColor;                                      // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InviteButtonDisableTime;                           // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFriendData                            Friend;                                            // 0x02E8(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimeoutHandle;                                     // 0x0320(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnInviteTimeExpired();
	void NativeTick(const struct FGeometry& MyGeometry, float InDeltaTime);
	void OnFriendClicked();
	void OnInviteTimeExpired();
	void SetFriend(const struct FFriendData& InFriend);
	void SetInvited(bool bIsInvited);
	void SetLocked(bool bLocked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsListItemWidget">();
	}
	static class UFriendsListItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsListItemWidget>();
	}
};
static_assert(alignof(UFriendsListItemWidget) == 0x000008, "Wrong alignment on UFriendsListItemWidget");
static_assert(sizeof(UFriendsListItemWidget) == 0x000330, "Wrong size on UFriendsListItemWidget");
static_assert(offsetof(UFriendsListItemWidget, TextBlock_PlayerName) == 0x000280, "Member 'UFriendsListItemWidget::TextBlock_PlayerName' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, TextBlock_Status) == 0x000288, "Member 'UFriendsListItemWidget::TextBlock_Status' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, Image_Avatar) == 0x000290, "Member 'UFriendsListItemWidget::Image_Avatar' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, Image_Background) == 0x000298, "Member 'UFriendsListItemWidget::Image_Background' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, Icon_Invited_Friend) == 0x0002A0, "Member 'UFriendsListItemWidget::Icon_Invited_Friend' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, Friends_avatar_gradient) == 0x0002A8, "Member 'UFriendsListItemWidget::Friends_avatar_gradient' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, Button_Action) == 0x0002B0, "Member 'UFriendsListItemWidget::Button_Action' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, OnlineBackground) == 0x0002B8, "Member 'UFriendsListItemWidget::OnlineBackground' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, OfflineBackground) == 0x0002C0, "Member 'UFriendsListItemWidget::OfflineBackground' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, PartyBackground) == 0x0002C8, "Member 'UFriendsListItemWidget::PartyBackground' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, OfflineColor) == 0x0002D0, "Member 'UFriendsListItemWidget::OfflineColor' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, InviteButtonDisableTime) == 0x0002E0, "Member 'UFriendsListItemWidget::InviteButtonDisableTime' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, Friend) == 0x0002E8, "Member 'UFriendsListItemWidget::Friend' has a wrong offset!");
static_assert(offsetof(UFriendsListItemWidget, TimeoutHandle) == 0x000320, "Member 'UFriendsListItemWidget::TimeoutHandle' has a wrong offset!");

// Class TimeWatch.FriendsListSeparatorWidget
// 0x0008 (0x0288 - 0x0280)
class UFriendsListSeparatorWidget : public UNGDUserWidget
{
public:
	class UTextBlock*                             TextBlock_SectionName;                             // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetName(const class FText& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsListSeparatorWidget">();
	}
	static class UFriendsListSeparatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsListSeparatorWidget>();
	}
};
static_assert(alignof(UFriendsListSeparatorWidget) == 0x000008, "Wrong alignment on UFriendsListSeparatorWidget");
static_assert(sizeof(UFriendsListSeparatorWidget) == 0x000288, "Wrong size on UFriendsListSeparatorWidget");
static_assert(offsetof(UFriendsListSeparatorWidget, TextBlock_SectionName) == 0x000280, "Member 'UFriendsListSeparatorWidget::TextBlock_SectionName' has a wrong offset!");

// Class TimeWatch.TWSaveEvent
// 0x0008 (0x0040 - 0x0038)
class UTWSaveEvent : public UTimeWatchEvent
{
public:
	class ATimeWatchCharacter*                    SavedCharacter;                                    // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSaveEvent">();
	}
	static class UTWSaveEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWSaveEvent>();
	}
};
static_assert(alignof(UTWSaveEvent) == 0x000008, "Wrong alignment on UTWSaveEvent");
static_assert(sizeof(UTWSaveEvent) == 0x000040, "Wrong size on UTWSaveEvent");
static_assert(offsetof(UTWSaveEvent, SavedCharacter) == 0x000038, "Member 'UTWSaveEvent::SavedCharacter' has a wrong offset!");

// Class TimeWatch.TWSaveForKillfeedEvent
// 0x0008 (0x0048 - 0x0040)
class UTWSaveForKillfeedEvent final : public UTWSaveEvent
{
public:
	class AActor*                                 HealSourceActor;                                   // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSaveForKillfeedEvent">();
	}
	static class UTWSaveForKillfeedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWSaveForKillfeedEvent>();
	}
};
static_assert(alignof(UTWSaveForKillfeedEvent) == 0x000008, "Wrong alignment on UTWSaveForKillfeedEvent");
static_assert(sizeof(UTWSaveForKillfeedEvent) == 0x000048, "Wrong size on UTWSaveForKillfeedEvent");
static_assert(offsetof(UTWSaveForKillfeedEvent, HealSourceActor) == 0x000040, "Member 'UTWSaveForKillfeedEvent::HealSourceActor' has a wrong offset!");

// Class TimeWatch.FriendsListWidget
// 0x0088 (0x0308 - 0x0280)
class UFriendsListWidget : public UNGDUserWidget
{
public:
	class UVerticalBox*                           VerticalBox_List;                                  // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_NoFriends;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFriendsListItemWidget>     ItemClass;                                         // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFriendsListSeparatorWidget> SeparatorClass;                                   // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OfflineAlpha;                                      // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UFriendsListItemWidget*> WidgetMap;                                    // 0x02A8(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void FillList(const TArray<struct FFriendData>& FriendList);
	void OnFriendListUpdated();
	void OnPartyStatusUpdate(const bool bPartyStructureChanged);
	void Open();

	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsListWidget">();
	}
	static class UFriendsListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsListWidget>();
	}
};
static_assert(alignof(UFriendsListWidget) == 0x000008, "Wrong alignment on UFriendsListWidget");
static_assert(sizeof(UFriendsListWidget) == 0x000308, "Wrong size on UFriendsListWidget");
static_assert(offsetof(UFriendsListWidget, VerticalBox_List) == 0x000280, "Member 'UFriendsListWidget::VerticalBox_List' has a wrong offset!");
static_assert(offsetof(UFriendsListWidget, Text_NoFriends) == 0x000288, "Member 'UFriendsListWidget::Text_NoFriends' has a wrong offset!");
static_assert(offsetof(UFriendsListWidget, ItemClass) == 0x000290, "Member 'UFriendsListWidget::ItemClass' has a wrong offset!");
static_assert(offsetof(UFriendsListWidget, SeparatorClass) == 0x000298, "Member 'UFriendsListWidget::SeparatorClass' has a wrong offset!");
static_assert(offsetof(UFriendsListWidget, OfflineAlpha) == 0x0002A0, "Member 'UFriendsListWidget::OfflineAlpha' has a wrong offset!");
static_assert(offsetof(UFriendsListWidget, WidgetMap) == 0x0002A8, "Member 'UFriendsListWidget::WidgetMap' has a wrong offset!");

// Class TimeWatch.HUDStateBaseGameEnded
// 0x0000 (0x0268 - 0x0268)
class UHUDStateBaseGameEnded final : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateBaseGameEnded">();
	}
	static class UHUDStateBaseGameEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateBaseGameEnded>();
	}
};
static_assert(alignof(UHUDStateBaseGameEnded) == 0x000008, "Wrong alignment on UHUDStateBaseGameEnded");
static_assert(sizeof(UHUDStateBaseGameEnded) == 0x000268, "Wrong size on UHUDStateBaseGameEnded");

// Class TimeWatch.TWHeadshotKill
// 0x0000 (0x0048 - 0x0048)
class UTWHeadshotKill final : public UTWKillEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWHeadshotKill">();
	}
	static class UTWHeadshotKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWHeadshotKill>();
	}
};
static_assert(alignof(UTWHeadshotKill) == 0x000008, "Wrong alignment on UTWHeadshotKill");
static_assert(sizeof(UTWHeadshotKill) == 0x000048, "Wrong size on UTWHeadshotKill");

// Class TimeWatch.HUDStateBaseGamePlay
// 0x0000 (0x0268 - 0x0268)
class UHUDStateBaseGamePlay : public UNGDHUDState
{
public:
	void OnStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnTeamScoredPoint(int32 TeamId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateBaseGamePlay">();
	}
	static class UHUDStateBaseGamePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateBaseGamePlay>();
	}
};
static_assert(alignof(UHUDStateBaseGamePlay) == 0x000008, "Wrong alignment on UHUDStateBaseGamePlay");
static_assert(sizeof(UHUDStateBaseGamePlay) == 0x000268, "Wrong size on UHUDStateBaseGamePlay");

// Class TimeWatch.HUDStateBaseInGameMenu
// 0x0000 (0x0268 - 0x0268)
class UHUDStateBaseInGameMenu : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateBaseInGameMenu">();
	}
	static class UHUDStateBaseInGameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateBaseInGameMenu>();
	}
};
static_assert(alignof(UHUDStateBaseInGameMenu) == 0x000008, "Wrong alignment on UHUDStateBaseInGameMenu");
static_assert(sizeof(UHUDStateBaseInGameMenu) == 0x000268, "Wrong size on UHUDStateBaseInGameMenu");

// Class TimeWatch.TWTieEvent
// 0x0000 (0x0038 - 0x0038)
class UTWTieEvent final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTieEvent">();
	}
	static class UTWTieEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTieEvent>();
	}
};
static_assert(alignof(UTWTieEvent) == 0x000008, "Wrong alignment on UTWTieEvent");
static_assert(sizeof(UTWTieEvent) == 0x000038, "Wrong size on UTWTieEvent");

// Class TimeWatch.HUDStateBaseMatchResults
// 0x0000 (0x0268 - 0x0268)
class UHUDStateBaseMatchResults final : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateBaseMatchResults">();
	}
	static class UHUDStateBaseMatchResults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateBaseMatchResults>();
	}
};
static_assert(alignof(UHUDStateBaseMatchResults) == 0x000008, "Wrong alignment on UHUDStateBaseMatchResults");
static_assert(sizeof(UHUDStateBaseMatchResults) == 0x000268, "Wrong size on UHUDStateBaseMatchResults");

// Class TimeWatch.HUDStateBaseReplay
// 0x0008 (0x0270 - 0x0268)
class UHUDStateBaseReplay : public UNGDHUDState
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateBaseReplay">();
	}
	static class UHUDStateBaseReplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateBaseReplay>();
	}
};
static_assert(alignof(UHUDStateBaseReplay) == 0x000008, "Wrong alignment on UHUDStateBaseReplay");
static_assert(sizeof(UHUDStateBaseReplay) == 0x000270, "Wrong size on UHUDStateBaseReplay");

// Class TimeWatch.TWExplosionGhost
// 0x0020 (0x0238 - 0x0218)
class ATWExplosionGhost : public AActor
{
public:
	class UStaticMeshComponent*                   ExplosionMesh;                                     // 0x0218(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ExplosionCurve;                                    // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionTime;                                     // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionDuration;                                 // 0x022C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionSize;                                     // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_Setup(class ATimeWatchCharacter* ExplosionOwner);
	float GetExplosionFactor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWExplosionGhost">();
	}
	static class ATWExplosionGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWExplosionGhost>();
	}
};
static_assert(alignof(ATWExplosionGhost) == 0x000008, "Wrong alignment on ATWExplosionGhost");
static_assert(sizeof(ATWExplosionGhost) == 0x000238, "Wrong size on ATWExplosionGhost");
static_assert(offsetof(ATWExplosionGhost, ExplosionMesh) == 0x000218, "Member 'ATWExplosionGhost::ExplosionMesh' has a wrong offset!");
static_assert(offsetof(ATWExplosionGhost, ExplosionCurve) == 0x000220, "Member 'ATWExplosionGhost::ExplosionCurve' has a wrong offset!");
static_assert(offsetof(ATWExplosionGhost, ExplosionTime) == 0x000228, "Member 'ATWExplosionGhost::ExplosionTime' has a wrong offset!");
static_assert(offsetof(ATWExplosionGhost, ExplosionDuration) == 0x00022C, "Member 'ATWExplosionGhost::ExplosionDuration' has a wrong offset!");
static_assert(offsetof(ATWExplosionGhost, ExplosionSize) == 0x000230, "Member 'ATWExplosionGhost::ExplosionSize' has a wrong offset!");

// Class TimeWatch.HUDStateBaseSpectator
// 0x0008 (0x0270 - 0x0268)
class UHUDStateBaseSpectator : public UNGDHUDState
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateBaseSpectator">();
	}
	static class UHUDStateBaseSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateBaseSpectator>();
	}
};
static_assert(alignof(UHUDStateBaseSpectator) == 0x000008, "Wrong alignment on UHUDStateBaseSpectator");
static_assert(sizeof(UHUDStateBaseSpectator) == 0x000270, "Wrong size on UHUDStateBaseSpectator");

// Class TimeWatch.HUDStateCaptureGamePlay
// 0x0000 (0x0268 - 0x0268)
class UHUDStateCaptureGamePlay : public UNGDHUDState
{
public:
	void OnStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateCaptureGamePlay">();
	}
	static class UHUDStateCaptureGamePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateCaptureGamePlay>();
	}
};
static_assert(alignof(UHUDStateCaptureGamePlay) == 0x000008, "Wrong alignment on UHUDStateCaptureGamePlay");
static_assert(sizeof(UHUDStateCaptureGamePlay) == 0x000268, "Wrong size on UHUDStateCaptureGamePlay");

// Class TimeWatch.TWNewRound
// 0x0000 (0x0038 - 0x0038)
class UTWNewRound final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWNewRound">();
	}
	static class UTWNewRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWNewRound>();
	}
};
static_assert(alignof(UTWNewRound) == 0x000008, "Wrong alignment on UTWNewRound");
static_assert(sizeof(UTWNewRound) == 0x000038, "Wrong size on UTWNewRound");

// Class TimeWatch.WidgetContainerChat
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerChat final : public UNGDWidgetContainer
{
public:
	class UChatWidget*                            ChatWidget_Chat;                                   // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerChat">();
	}
	static class UWidgetContainerChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerChat>();
	}
};
static_assert(alignof(UWidgetContainerChat) == 0x000008, "Wrong alignment on UWidgetContainerChat");
static_assert(sizeof(UWidgetContainerChat) == 0x000250, "Wrong size on UWidgetContainerChat");
static_assert(offsetof(UWidgetContainerChat, ChatWidget_Chat) == 0x000248, "Member 'UWidgetContainerChat::ChatWidget_Chat' has a wrong offset!");

// Class TimeWatch.HUDStateChat
// 0x0000 (0x0268 - 0x0268)
class UHUDStateChat final : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateChat">();
	}
	static class UHUDStateChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateChat>();
	}
};
static_assert(alignof(UHUDStateChat) == 0x000008, "Wrong alignment on UHUDStateChat");
static_assert(sizeof(UHUDStateChat) == 0x000268, "Wrong size on UHUDStateChat");

// Class TimeWatch.TWMatchStarted
// 0x0000 (0x0038 - 0x0038)
class UTWMatchStarted final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWMatchStarted">();
	}
	static class UTWMatchStarted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWMatchStarted>();
	}
};
static_assert(alignof(UTWMatchStarted) == 0x000008, "Wrong alignment on UTWMatchStarted");
static_assert(sizeof(UTWMatchStarted) == 0x000038, "Wrong size on UTWMatchStarted");

// Class TimeWatch.HUDStateCredits
// 0x0000 (0x0268 - 0x0268)
class UHUDStateCredits : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateCredits">();
	}
	static class UHUDStateCredits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateCredits>();
	}
};
static_assert(alignof(UHUDStateCredits) == 0x000008, "Wrong alignment on UHUDStateCredits");
static_assert(sizeof(UHUDStateCredits) == 0x000268, "Wrong size on UHUDStateCredits");

// Class TimeWatch.HUDStateCustomization
// 0x0000 (0x0268 - 0x0268)
class UHUDStateCustomization : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateCustomization">();
	}
	static class UHUDStateCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateCustomization>();
	}
};
static_assert(alignof(UHUDStateCustomization) == 0x000008, "Wrong alignment on UHUDStateCustomization");
static_assert(sizeof(UHUDStateCustomization) == 0x000268, "Wrong size on UHUDStateCustomization");

// Class TimeWatch.TWScoringDeniedEvent
// 0x0000 (0x0038 - 0x0038)
class UTWScoringDeniedEvent final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWScoringDeniedEvent">();
	}
	static class UTWScoringDeniedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWScoringDeniedEvent>();
	}
};
static_assert(alignof(UTWScoringDeniedEvent) == 0x000008, "Wrong alignment on UTWScoringDeniedEvent");
static_assert(sizeof(UTWScoringDeniedEvent) == 0x000038, "Wrong size on UTWScoringDeniedEvent");

// Class TimeWatch.HUDStateCustomMatch
// 0x0000 (0x0268 - 0x0268)
class UHUDStateCustomMatch : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateCustomMatch">();
	}
	static class UHUDStateCustomMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateCustomMatch>();
	}
};
static_assert(alignof(UHUDStateCustomMatch) == 0x000008, "Wrong alignment on UHUDStateCustomMatch");
static_assert(sizeof(UHUDStateCustomMatch) == 0x000268, "Wrong size on UHUDStateCustomMatch");

// Class TimeWatch.HUDStateCustomMatchLobby
// 0x0010 (0x0278 - 0x0268)
class UHUDStateCustomMatchLobby : public UNGDHUDState
{
public:
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateCustomMatchLobby">();
	}
	static class UHUDStateCustomMatchLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateCustomMatchLobby>();
	}
};
static_assert(alignof(UHUDStateCustomMatchLobby) == 0x000008, "Wrong alignment on UHUDStateCustomMatchLobby");
static_assert(sizeof(UHUDStateCustomMatchLobby) == 0x000278, "Wrong size on UHUDStateCustomMatchLobby");

// Class TimeWatch.TWGameplayActorHandle
// 0x0048 (0x0260 - 0x0218)
class ATWGameplayActorHandle final : public AActor
{
public:
	TSubclassOf<class AActor>                     ChildActorClass;                                   // 0x0218(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0220(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x022C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         CreationTime;                                      // 0x0238(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x023C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActorComp;                                    // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTWGameplayActorReplicationData        SpawnData;                                         // 0x0248(0x0018)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayActorHandle">();
	}
	static class ATWGameplayActorHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWGameplayActorHandle>();
	}
};
static_assert(alignof(ATWGameplayActorHandle) == 0x000008, "Wrong alignment on ATWGameplayActorHandle");
static_assert(sizeof(ATWGameplayActorHandle) == 0x000260, "Wrong size on ATWGameplayActorHandle");
static_assert(offsetof(ATWGameplayActorHandle, ChildActorClass) == 0x000218, "Member 'ATWGameplayActorHandle::ChildActorClass' has a wrong offset!");
static_assert(offsetof(ATWGameplayActorHandle, SpawnLocation) == 0x000220, "Member 'ATWGameplayActorHandle::SpawnLocation' has a wrong offset!");
static_assert(offsetof(ATWGameplayActorHandle, SpawnRotation) == 0x00022C, "Member 'ATWGameplayActorHandle::SpawnRotation' has a wrong offset!");
static_assert(offsetof(ATWGameplayActorHandle, CreationTime) == 0x000238, "Member 'ATWGameplayActorHandle::CreationTime' has a wrong offset!");
static_assert(offsetof(ATWGameplayActorHandle, Duration) == 0x00023C, "Member 'ATWGameplayActorHandle::Duration' has a wrong offset!");
static_assert(offsetof(ATWGameplayActorHandle, ChildActorComp) == 0x000240, "Member 'ATWGameplayActorHandle::ChildActorComp' has a wrong offset!");
static_assert(offsetof(ATWGameplayActorHandle, SpawnData) == 0x000248, "Member 'ATWGameplayActorHandle::SpawnData' has a wrong offset!");

// Class TimeWatch.HUDStateDeathMatchGamePlay
// 0x0000 (0x0268 - 0x0268)
class UHUDStateDeathMatchGamePlay : public UNGDHUDState
{
public:
	void OnStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateDeathMatchGamePlay">();
	}
	static class UHUDStateDeathMatchGamePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateDeathMatchGamePlay>();
	}
};
static_assert(alignof(UHUDStateDeathMatchGamePlay) == 0x000008, "Wrong alignment on UHUDStateDeathMatchGamePlay");
static_assert(sizeof(UHUDStateDeathMatchGamePlay) == 0x000268, "Wrong size on UHUDStateDeathMatchGamePlay");

// Class TimeWatch.HUDStateDominationGamePlay
// 0x0000 (0x0268 - 0x0268)
class UHUDStateDominationGamePlay final : public UNGDHUDState
{
public:
	void OnStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateDominationGamePlay">();
	}
	static class UHUDStateDominationGamePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateDominationGamePlay>();
	}
};
static_assert(alignof(UHUDStateDominationGamePlay) == 0x000008, "Wrong alignment on UHUDStateDominationGamePlay");
static_assert(sizeof(UHUDStateDominationGamePlay) == 0x000268, "Wrong size on UHUDStateDominationGamePlay");

// Class TimeWatch.TWGameEventObserver
// 0x00A0 (0x0150 - 0x00B0)
class UTWGameEventObserver final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class UTimeWatchEvent* Event)> GenericEvent;                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTimeWatchEvent* Event)> OnSavedFromPastDead;                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class ATWAnnouncer*                           GameAnnouncer;                                     // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTimeWatchEvent*>                BroadcastedEvents;                                 // 0x00D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ATimeWatchCharacter*, float>       SaveConfirmationKillEventMap;                      // 0x00E8(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TWEventTimeThreshold;                              // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeadBoneName;                                      // 0x0144(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseDistanceKillthreshold;                        // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Multicast_BroadcastEvent(const struct FEventReplicationData& ReplicationData);
	void OnGameStateChange(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameEventObserver">();
	}
	static class UTWGameEventObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGameEventObserver>();
	}
};
static_assert(alignof(UTWGameEventObserver) == 0x000008, "Wrong alignment on UTWGameEventObserver");
static_assert(sizeof(UTWGameEventObserver) == 0x000150, "Wrong size on UTWGameEventObserver");
static_assert(offsetof(UTWGameEventObserver, GenericEvent) == 0x0000B0, "Member 'UTWGameEventObserver::GenericEvent' has a wrong offset!");
static_assert(offsetof(UTWGameEventObserver, OnSavedFromPastDead) == 0x0000C0, "Member 'UTWGameEventObserver::OnSavedFromPastDead' has a wrong offset!");
static_assert(offsetof(UTWGameEventObserver, GameAnnouncer) == 0x0000D0, "Member 'UTWGameEventObserver::GameAnnouncer' has a wrong offset!");
static_assert(offsetof(UTWGameEventObserver, BroadcastedEvents) == 0x0000D8, "Member 'UTWGameEventObserver::BroadcastedEvents' has a wrong offset!");
static_assert(offsetof(UTWGameEventObserver, SaveConfirmationKillEventMap) == 0x0000E8, "Member 'UTWGameEventObserver::SaveConfirmationKillEventMap' has a wrong offset!");
static_assert(offsetof(UTWGameEventObserver, TWEventTimeThreshold) == 0x000140, "Member 'UTWGameEventObserver::TWEventTimeThreshold' has a wrong offset!");
static_assert(offsetof(UTWGameEventObserver, HeadBoneName) == 0x000144, "Member 'UTWGameEventObserver::HeadBoneName' has a wrong offset!");
static_assert(offsetof(UTWGameEventObserver, CloseDistanceKillthreshold) == 0x00014C, "Member 'UTWGameEventObserver::CloseDistanceKillthreshold' has a wrong offset!");

// Class TimeWatch.HUDStateLobby
// 0x0000 (0x0268 - 0x0268)
class UHUDStateLobby final : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateLobby">();
	}
	static class UHUDStateLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateLobby>();
	}
};
static_assert(alignof(UHUDStateLobby) == 0x000008, "Wrong alignment on UHUDStateLobby");
static_assert(sizeof(UHUDStateLobby) == 0x000268, "Wrong size on UHUDStateLobby");

// Class TimeWatch.HUDStateMainMenu
// 0x0008 (0x0270 - 0x0268)
class UHUDStateMainMenu : public UNGDHUDState
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateMainMenu">();
	}
	static class UHUDStateMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateMainMenu>();
	}
};
static_assert(alignof(UHUDStateMainMenu) == 0x000008, "Wrong alignment on UHUDStateMainMenu");
static_assert(sizeof(UHUDStateMainMenu) == 0x000270, "Wrong size on UHUDStateMainMenu");

// Class TimeWatch.TWPlusThreeNonScoringRounds
// 0x0000 (0x0038 - 0x0038)
class UTWPlusThreeNonScoringRounds final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlusThreeNonScoringRounds">();
	}
	static class UTWPlusThreeNonScoringRounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPlusThreeNonScoringRounds>();
	}
};
static_assert(alignof(UTWPlusThreeNonScoringRounds) == 0x000008, "Wrong alignment on UTWPlusThreeNonScoringRounds");
static_assert(sizeof(UTWPlusThreeNonScoringRounds) == 0x000038, "Wrong size on UTWPlusThreeNonScoringRounds");

// Class TimeWatch.HUDStateMediaPlayer
// 0x0008 (0x0270 - 0x0268)
class UHUDStateMediaPlayer : public UNGDHUDState
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateMediaPlayer">();
	}
	static class UHUDStateMediaPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateMediaPlayer>();
	}
};
static_assert(alignof(UHUDStateMediaPlayer) == 0x000008, "Wrong alignment on UHUDStateMediaPlayer");
static_assert(sizeof(UHUDStateMediaPlayer) == 0x000270, "Wrong size on UHUDStateMediaPlayer");

// Class TimeWatch.HUDStateOptions
// 0x0000 (0x0268 - 0x0268)
class UHUDStateOptions : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateOptions">();
	}
	static class UHUDStateOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateOptions>();
	}
};
static_assert(alignof(UHUDStateOptions) == 0x000008, "Wrong alignment on UHUDStateOptions");
static_assert(sizeof(UHUDStateOptions) == 0x000268, "Wrong size on UHUDStateOptions");

// Class TimeWatch.TWPremiumPopupHUDState
// 0x0000 (0x0270 - 0x0270)
class UTWPremiumPopupHUDState : public UNGDPopupHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPremiumPopupHUDState">();
	}
	static class UTWPremiumPopupHUDState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPremiumPopupHUDState>();
	}
};
static_assert(alignof(UTWPremiumPopupHUDState) == 0x000008, "Wrong alignment on UTWPremiumPopupHUDState");
static_assert(sizeof(UTWPremiumPopupHUDState) == 0x000270, "Wrong size on UTWPremiumPopupHUDState");

// Class TimeWatch.HUDStateStore
// 0x0000 (0x0268 - 0x0268)
class UHUDStateStore : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateStore">();
	}
	static class UHUDStateStore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateStore>();
	}
};
static_assert(alignof(UHUDStateStore) == 0x000008, "Wrong alignment on UHUDStateStore");
static_assert(sizeof(UHUDStateStore) == 0x000268, "Wrong size on UHUDStateStore");

// Class TimeWatch.HUDStateTraining
// 0x0010 (0x0278 - 0x0268)
class UHUDStateTraining : public UNGDHUDState
{
public:
	float                                         BackendRewardWaitTimeout;                          // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0xC];                                      // 0x026C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateTraining">();
	}
	static class UHUDStateTraining* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateTraining>();
	}
};
static_assert(alignof(UHUDStateTraining) == 0x000008, "Wrong alignment on UHUDStateTraining");
static_assert(sizeof(UHUDStateTraining) == 0x000278, "Wrong size on UHUDStateTraining");
static_assert(offsetof(UHUDStateTraining, BackendRewardWaitTimeout) == 0x000268, "Member 'UHUDStateTraining::BackendRewardWaitTimeout' has a wrong offset!");

// Class TimeWatch.TWPlayerPreferences
// 0x0198 (0x01C0 - 0x0028)
class UTWPlayerPreferences final : public UObject
{
public:
	class FString                                 ActiveCharacterSKU;                                // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveLoadoutID;                                   // 0x0038(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerTitleSKU;                                    // 0x0040(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCharacterSelectionEntry> SavedCharactersCustomizations;              // 0x0050(0x0050)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<int32, struct FWeaponLoadoutEntry>       SavedLoadouts;                                     // 0x00A0(0x0050)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    LocalProgressData;                                 // 0x00F0(0x0050)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    SavedLeaderboardRanks;                             // 0x0140(0x0050)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FString                                 LastPlayedMap;                                     // 0x0190(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSelectedQueueType;                             // 0x01A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         FirstUserExpCompletedSteps;                        // 0x01A8(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	int32                                         PlayerPreferencesVersion;                          // 0x01B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InputVersion;                                      // 0x01BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlayerPreferences">();
	}
	static class UTWPlayerPreferences* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPlayerPreferences>();
	}
};
static_assert(alignof(UTWPlayerPreferences) == 0x000008, "Wrong alignment on UTWPlayerPreferences");
static_assert(sizeof(UTWPlayerPreferences) == 0x0001C0, "Wrong size on UTWPlayerPreferences");
static_assert(offsetof(UTWPlayerPreferences, ActiveCharacterSKU) == 0x000028, "Member 'UTWPlayerPreferences::ActiveCharacterSKU' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, ActiveLoadoutID) == 0x000038, "Member 'UTWPlayerPreferences::ActiveLoadoutID' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, PlayerTitleSKU) == 0x000040, "Member 'UTWPlayerPreferences::PlayerTitleSKU' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, SavedCharactersCustomizations) == 0x000050, "Member 'UTWPlayerPreferences::SavedCharactersCustomizations' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, SavedLoadouts) == 0x0000A0, "Member 'UTWPlayerPreferences::SavedLoadouts' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, LocalProgressData) == 0x0000F0, "Member 'UTWPlayerPreferences::LocalProgressData' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, SavedLeaderboardRanks) == 0x000140, "Member 'UTWPlayerPreferences::SavedLeaderboardRanks' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, LastPlayedMap) == 0x000190, "Member 'UTWPlayerPreferences::LastPlayedMap' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, LastSelectedQueueType) == 0x0001A0, "Member 'UTWPlayerPreferences::LastSelectedQueueType' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, FirstUserExpCompletedSteps) == 0x0001A8, "Member 'UTWPlayerPreferences::FirstUserExpCompletedSteps' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, PlayerPreferencesVersion) == 0x0001B8, "Member 'UTWPlayerPreferences::PlayerPreferencesVersion' has a wrong offset!");
static_assert(offsetof(UTWPlayerPreferences, InputVersion) == 0x0001BC, "Member 'UTWPlayerPreferences::InputVersion' has a wrong offset!");

// Class TimeWatch.HUDStateWeaponCustomization
// 0x0000 (0x0268 - 0x0268)
class UHUDStateWeaponCustomization : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateWeaponCustomization">();
	}
	static class UHUDStateWeaponCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateWeaponCustomization>();
	}
};
static_assert(alignof(UHUDStateWeaponCustomization) == 0x000008, "Wrong alignment on UHUDStateWeaponCustomization");
static_assert(sizeof(UHUDStateWeaponCustomization) == 0x000268, "Wrong size on UHUDStateWeaponCustomization");

// Class TimeWatch.HUDStateWeaponSelection
// 0x0000 (0x0268 - 0x0268)
class UHUDStateWeaponSelection : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateWeaponSelection">();
	}
	static class UHUDStateWeaponSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateWeaponSelection>();
	}
};
static_assert(alignof(UHUDStateWeaponSelection) == 0x000008, "Wrong alignment on UHUDStateWeaponSelection");
static_assert(sizeof(UHUDStateWeaponSelection) == 0x000268, "Wrong size on UHUDStateWeaponSelection");

// Class TimeWatch.TWGameplayTask
// 0x0010 (0x0078 - 0x0068)
class UTWGameplayTask : public UGameplayTask
{
public:
	class UTWAbility*                             Ability;                                           // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWAbilitiesComponent*                  AbilityCasterComp;                                 // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayTask">();
	}
	static class UTWGameplayTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGameplayTask>();
	}
};
static_assert(alignof(UTWGameplayTask) == 0x000008, "Wrong alignment on UTWGameplayTask");
static_assert(sizeof(UTWGameplayTask) == 0x000078, "Wrong size on UTWGameplayTask");
static_assert(offsetof(UTWGameplayTask, Ability) == 0x000068, "Member 'UTWGameplayTask::Ability' has a wrong offset!");
static_assert(offsetof(UTWGameplayTask, AbilityCasterComp) == 0x000070, "Member 'UTWGameplayTask::AbilityCasterComp' has a wrong offset!");

// Class TimeWatch.TWGameplayTask_VisualizeTargeting
// 0x0030 (0x00A8 - 0x0078)
class UTWGameplayTask_VisualizeTargeting final : public UTWGameplayTask
{
public:
	TMulticastInlineDelegate<void(const struct FTWAbilityCustomDataHandle& OutDataHandle)> OnConfirmed; // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancelled;                                       // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTWGameplayTask_VisualizeTargeting* WaitTargetData(class UTWAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class ATWGameplayAbilityTargetActor> Class_0);

	bool BeginSpawningActor(class UTWAbility* OwningAbility, TSubclassOf<class ATWGameplayAbilityTargetActor> Class_0, class ATWGameplayAbilityTargetActor** SpawnedActor);
	void FinishSpawningActor(class UTWAbility* OwningAbility, class ATWGameplayAbilityTargetActor* SpawnedActor);
	void OnTargetDataCancelledCallback(const struct FTWAbilityCustomDataHandle& CustomDataHandle);
	void OnTargetDataReadyCallback(const struct FTWAbilityCustomDataHandle& CustomDataHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayTask_VisualizeTargeting">();
	}
	static class UTWGameplayTask_VisualizeTargeting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGameplayTask_VisualizeTargeting>();
	}
};
static_assert(alignof(UTWGameplayTask_VisualizeTargeting) == 0x000008, "Wrong alignment on UTWGameplayTask_VisualizeTargeting");
static_assert(sizeof(UTWGameplayTask_VisualizeTargeting) == 0x0000A8, "Wrong size on UTWGameplayTask_VisualizeTargeting");
static_assert(offsetof(UTWGameplayTask_VisualizeTargeting, OnConfirmed) == 0x000078, "Member 'UTWGameplayTask_VisualizeTargeting::OnConfirmed' has a wrong offset!");
static_assert(offsetof(UTWGameplayTask_VisualizeTargeting, OnCancelled) == 0x000088, "Member 'UTWGameplayTask_VisualizeTargeting::OnCancelled' has a wrong offset!");

// Class TimeWatch.HUDStateWishlist
// 0x0000 (0x0268 - 0x0268)
class UHUDStateWishlist final : public UNGDHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDStateWishlist">();
	}
	static class UHUDStateWishlist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDStateWishlist>();
	}
};
static_assert(alignof(UHUDStateWishlist) == 0x000008, "Wrong alignment on UHUDStateWishlist");
static_assert(sizeof(UHUDStateWishlist) == 0x000268, "Wrong size on UHUDStateWishlist");

// Class TimeWatch.InviteRecievedWidget
// 0x0028 (0x02A8 - 0x0280)
class UInviteRecievedWidget final : public UNGDUserWidget
{
public:
	class UButton*                                Button_Accept;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Button_Decline;                                    // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_Message;                                 // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InviterId;                                         // 0x0298(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAcceptClicked();
	void OnDeclineClicked();
	void Open(const class FString& InInviterId, const class FString& InInviterName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InviteRecievedWidget">();
	}
	static class UInviteRecievedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInviteRecievedWidget>();
	}
};
static_assert(alignof(UInviteRecievedWidget) == 0x000008, "Wrong alignment on UInviteRecievedWidget");
static_assert(sizeof(UInviteRecievedWidget) == 0x0002A8, "Wrong size on UInviteRecievedWidget");
static_assert(offsetof(UInviteRecievedWidget, Button_Accept) == 0x000280, "Member 'UInviteRecievedWidget::Button_Accept' has a wrong offset!");
static_assert(offsetof(UInviteRecievedWidget, Button_Decline) == 0x000288, "Member 'UInviteRecievedWidget::Button_Decline' has a wrong offset!");
static_assert(offsetof(UInviteRecievedWidget, TextBlock_Message) == 0x000290, "Member 'UInviteRecievedWidget::TextBlock_Message' has a wrong offset!");
static_assert(offsetof(UInviteRecievedWidget, InviterId) == 0x000298, "Member 'UInviteRecievedWidget::InviterId' has a wrong offset!");

// Class TimeWatch.TWInteractable
// 0x0000 (0x0000 - 0x0000)
class ITWInteractable final
{
public:
	void OnInteraction_Internal(int32 ID, class AActor* Interactor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWInteractable">();
	}
	static class ITWInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITWInteractable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITWInteractable) == 0x000001, "Wrong alignment on ITWInteractable");
static_assert(sizeof(ITWInteractable) == 0x000001, "Wrong size on ITWInteractable");

// Class TimeWatch.TWInteractableRewindable
// 0x0000 (0x0000 - 0x0000)
class ITWInteractableRewindable final
{
public:
	void OnInteractionUndo_Internal(int32 ID, class AActor* Interactor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWInteractableRewindable">();
	}
	static class ITWInteractableRewindable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITWInteractableRewindable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITWInteractableRewindable) == 0x000001, "Wrong alignment on ITWInteractableRewindable");
static_assert(sizeof(ITWInteractableRewindable) == 0x000001, "Wrong size on ITWInteractableRewindable");

// Class TimeWatch.TWGlobals
// 0x0020 (0x0048 - 0x0028)
class UTWGlobals : public UObject
{
public:
	TSubclassOf<class UTWGameGlobals>             GameGlobalsType;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWStoreGlobals>            StoreGlobalsType;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWChromaColorSchemeDataAsset*          ActiveChromaColorScheme;                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWColorSchemeDataAsset*                ActiveColorScheme;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UTWChromaColorSchemeDataAsset* GetChromaColorScheme() const;
	class UTWColorSchemeDataAsset* GetColorScheme() const;
	class UTWGameGlobals* GetGameGlobals() const;
	class UTWStoreGlobals* GetStoreGlobals() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGlobals">();
	}
	static class UTWGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGlobals>();
	}
};
static_assert(alignof(UTWGlobals) == 0x000008, "Wrong alignment on UTWGlobals");
static_assert(sizeof(UTWGlobals) == 0x000048, "Wrong size on UTWGlobals");
static_assert(offsetof(UTWGlobals, GameGlobalsType) == 0x000028, "Member 'UTWGlobals::GameGlobalsType' has a wrong offset!");
static_assert(offsetof(UTWGlobals, StoreGlobalsType) == 0x000030, "Member 'UTWGlobals::StoreGlobalsType' has a wrong offset!");
static_assert(offsetof(UTWGlobals, ActiveChromaColorScheme) == 0x000038, "Member 'UTWGlobals::ActiveChromaColorScheme' has a wrong offset!");
static_assert(offsetof(UTWGlobals, ActiveColorScheme) == 0x000040, "Member 'UTWGlobals::ActiveColorScheme' has a wrong offset!");

// Class TimeWatch.LobbyHUD
// 0x0008 (0x03A8 - 0x03A0)
class ALobbyHUD final : public ANGDLayeredHUD
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStatePresented(class UNGDHUDState* PresentedState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyHUD">();
	}
	static class ALobbyHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyHUD>();
	}
};
static_assert(alignof(ALobbyHUD) == 0x000008, "Wrong alignment on ALobbyHUD");
static_assert(sizeof(ALobbyHUD) == 0x0003A8, "Wrong size on ALobbyHUD");

// Class TimeWatch.LobbyPlayerController
// 0x0008 (0x0570 - 0x0568)
class ALobbyPlayerController final : public APlayerController
{
public:
	int32                                         PlayerCount;                                       // 0x0568(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOnMatchStarted(ETWMatchType MatchType);
	void ClientPostLogin();
	void ClientShowMatchSettings();
	void ClientStartCustomMatchFail();
	void ServerExpoSetDoublesState(bool NewState);
	void ServerSendMatchInfo(bool IsCustomMatch, int32 ExpoTeamIdOverride, bool IsExpoSpectator);
	void ServerStartCustomMatch(const struct FMatchDescriptor& CustomMatchDescriptor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyPlayerController">();
	}
	static class ALobbyPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyPlayerController>();
	}
};
static_assert(alignof(ALobbyPlayerController) == 0x000008, "Wrong alignment on ALobbyPlayerController");
static_assert(sizeof(ALobbyPlayerController) == 0x000570, "Wrong size on ALobbyPlayerController");
static_assert(offsetof(ALobbyPlayerController, PlayerCount) == 0x000568, "Member 'ALobbyPlayerController::PlayerCount' has a wrong offset!");

// Class TimeWatch.TWGameplayTask_SpawnActor
// 0x0010 (0x0088 - 0x0078)
class UTWGameplayTask_SpawnActor final : public UTWGameplayTask
{
public:
	TMulticastInlineDelegate<void(class AActor* SpawnedActor)> Success;                              // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UTWGameplayTask_SpawnActor* SpawnActor(class UTWAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class ATWGameplayActorHandle> Class_0);

	bool BeginSpawningActor(class UTWAbility* OwningAbility, TSubclassOf<class ATWGameplayActorHandle> Class_0, class ATWGameplayActorHandle** SpawnedActor);
	void FinishSpawningActor(class UTWAbility* OwningAbility, class ATWGameplayActorHandle* SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayTask_SpawnActor">();
	}
	static class UTWGameplayTask_SpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGameplayTask_SpawnActor>();
	}
};
static_assert(alignof(UTWGameplayTask_SpawnActor) == 0x000008, "Wrong alignment on UTWGameplayTask_SpawnActor");
static_assert(sizeof(UTWGameplayTask_SpawnActor) == 0x000088, "Wrong size on UTWGameplayTask_SpawnActor");
static_assert(offsetof(UTWGameplayTask_SpawnActor, Success) == 0x000078, "Member 'UTWGameplayTask_SpawnActor::Success' has a wrong offset!");

// Class TimeWatch.MainMenuHUD
// 0x01A0 (0x0540 - 0x03A0)
class AMainMenuHUD : public ANGDLayeredHUD
{
public:
	uint8                                         Pad_3A0[0x18];                                     // 0x03A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GlobalRangeStart;                                  // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GlobalRangeEnd;                                    // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AroundUserRangeStart;                              // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AroundUserRangeEnd;                                // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        MatchFoundSoundConfig;                             // 0x03C8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        InviteRecivedSoundConfig;                          // 0x0420(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ServerMaintenanceMessage;                          // 0x0478(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        NGDAk_MainMenu;                                    // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0xA8];                                     // 0x0498(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ShowFirstPerson();
	void BP_ShowVersusPictures();
	void ConnectToLocalServer();
	void ExpoModeResetConfigs();
	void ExpoUpdateChromaTeamColor();
	void Host_StartCustomMatch(const struct FMatchDescriptor& HostCustomMatchDescriptor);
	bool IsOnParty();
	void OnFlexmatchMatchmakingStartComplete(bool bWasSuccessful, const class FString& ErrorString, ETWMatchmakingType MatchmakingType);
	void OnFriendInviteAccepted(const struct FOnlineSessionSearchResultContainer& InviteResult);
	void OnFriendInviteReceived(const class FString& UserId, const struct FOnlineSessionSearchResultContainer& InviteResult);
	void OnGameStart();
	void OnLobbyMatchmakingComplete(const class FString& Ticket, ETWMatchmakingType MatchmakingType);
	void OnLobbyMatchmakingFailed(const class FString& Reason, ETWMatchmakingType MatchmakingType);
	void OnLoginComplete(bool bWasSuccessful, const class FString& ErrorString);
	void OnMatchmakingPollComplete(bool bWasSuccessful, const class FString& Status, const class FString& PlayerSessionId, const class FString& IpAddress, int32 Port, const class FString& ErrorString);
	void OnMatchmakingPollTimeOut(bool bWasSuccessful, const class FString& Status, const class FString& PlayerSessionId, const class FString& IpAddress, int32 Port, const class FString& ErrorString);
	void OnNewsComplete(bool bWasSuccessful, const class FString& ErrorString, const TArray<struct FNGDBackendNewsEntry>& NewsEntries);
	void OnPlayerDataUpdateComplete(bool bWasSuccessful, const class FString& ErrorString);
	void OnPlayerInventoryRequestComplete(bool bWasSuccessful, const class FString& ErrorString);
	void OnServerErrorResponse(ENGDBackendServerErrorResponse ErrorResponse, const class FString& ErrorCode);
	void OnStatePresented(class UNGDHUDState* PresentedState);
	void OnTournamentLeaderboardComplete(bool bWasSuccessful, const class FString& ErrorString, bool bLeaderboardFound, const TArray<struct FNGDBackendTournamentBoardEntry>& NewTournamentEntries);
	void PartyMatchmakingCancel();
	void PartyMatchmakingStart(ETWMatchQueueType MatchQueueType, const class FString& LobbyID);
	void PlayTransitionSequence_ArrowsToNames(bool bInReverse);
	void PlayTransitionSequence_CustomizationToStyleSelection(bool bInReverse);
	void PlayTransitionSequence_MenuToCustomization(bool bInReverse);
	void RequestLeaderboardUpdate();
	void RequestNewsUpdate();
	void RequestPlayerInventory();
	void RequestPlayerStatsUpdate();
	void ShowFirstPerson();
	void ShowVersusPictures();
	void StartListenServer();
	void StartMainMenu();
	void StopCustomMatchMatchmaking();
	void StopFlexmatchMatchmaking();
	void StopGameSessionPoll();
	void StopLobbyMatchmaking();
	void StopMatchMakingPoll();
	void ToggleCustomMatchLobby(bool bEnable);
	void TryInitMainMenu();
	void UpdatePartyData(const bool bPartyStructureChanged);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuHUD">();
	}
	static class AMainMenuHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainMenuHUD>();
	}
};
static_assert(alignof(AMainMenuHUD) == 0x000008, "Wrong alignment on AMainMenuHUD");
static_assert(sizeof(AMainMenuHUD) == 0x000540, "Wrong size on AMainMenuHUD");
static_assert(offsetof(AMainMenuHUD, GlobalRangeStart) == 0x0003B8, "Member 'AMainMenuHUD::GlobalRangeStart' has a wrong offset!");
static_assert(offsetof(AMainMenuHUD, GlobalRangeEnd) == 0x0003BC, "Member 'AMainMenuHUD::GlobalRangeEnd' has a wrong offset!");
static_assert(offsetof(AMainMenuHUD, AroundUserRangeStart) == 0x0003C0, "Member 'AMainMenuHUD::AroundUserRangeStart' has a wrong offset!");
static_assert(offsetof(AMainMenuHUD, AroundUserRangeEnd) == 0x0003C4, "Member 'AMainMenuHUD::AroundUserRangeEnd' has a wrong offset!");
static_assert(offsetof(AMainMenuHUD, MatchFoundSoundConfig) == 0x0003C8, "Member 'AMainMenuHUD::MatchFoundSoundConfig' has a wrong offset!");
static_assert(offsetof(AMainMenuHUD, InviteRecivedSoundConfig) == 0x000420, "Member 'AMainMenuHUD::InviteRecivedSoundConfig' has a wrong offset!");
static_assert(offsetof(AMainMenuHUD, ServerMaintenanceMessage) == 0x000478, "Member 'AMainMenuHUD::ServerMaintenanceMessage' has a wrong offset!");
static_assert(offsetof(AMainMenuHUD, NGDAk_MainMenu) == 0x000490, "Member 'AMainMenuHUD::NGDAk_MainMenu' has a wrong offset!");

// Class TimeWatch.MainMenuPlayerController
// 0x0020 (0x0588 - 0x0568)
class AMainMenuPlayerController : public APlayerController
{
public:
	class UNGDAkListener*                         ListenerComponent;                                 // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnScrollInputReceived;                             // 0x0570(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UMediaSoundComponent*                   SoundMediaComp;                                    // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeCulture(const class FString& Culture);
	void Escape();
	void OnVideoEnded();
	void OnVideoStarted(const class FString& OpenedUrl);
	void PrintXP();
	void Scroll(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuPlayerController">();
	}
	static class AMainMenuPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainMenuPlayerController>();
	}
};
static_assert(alignof(AMainMenuPlayerController) == 0x000008, "Wrong alignment on AMainMenuPlayerController");
static_assert(sizeof(AMainMenuPlayerController) == 0x000588, "Wrong size on AMainMenuPlayerController");
static_assert(offsetof(AMainMenuPlayerController, ListenerComponent) == 0x000568, "Member 'AMainMenuPlayerController::ListenerComponent' has a wrong offset!");
static_assert(offsetof(AMainMenuPlayerController, OnScrollInputReceived) == 0x000570, "Member 'AMainMenuPlayerController::OnScrollInputReceived' has a wrong offset!");
static_assert(offsetof(AMainMenuPlayerController, SoundMediaComp) == 0x000580, "Member 'AMainMenuPlayerController::SoundMediaComp' has a wrong offset!");

// Class TimeWatch.TWImagePopup
// 0x0010 (0x07D8 - 0x07C8)
class UTWImagePopup : public UTWGenericPopup
{
public:
	class UTextBlock*                             TextBlock_Description;                             // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PopupImage;                                  // 0x07D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWImagePopup">();
	}
	static class UTWImagePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWImagePopup>();
	}
};
static_assert(alignof(UTWImagePopup) == 0x000008, "Wrong alignment on UTWImagePopup");
static_assert(sizeof(UTWImagePopup) == 0x0007D8, "Wrong size on UTWImagePopup");
static_assert(offsetof(UTWImagePopup, TextBlock_Description) == 0x0007C8, "Member 'UTWImagePopup::TextBlock_Description' has a wrong offset!");
static_assert(offsetof(UTWImagePopup, Image_PopupImage) == 0x0007D0, "Member 'UTWImagePopup::Image_PopupImage' has a wrong offset!");

// Class TimeWatch.MatchEventLog
// 0x0060 (0x0278 - 0x0218)
class AMatchEventLog final : public AActor
{
public:
	TArray<struct FMatchEvent>                    Events;                                            // 0x0218(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnNewRecord;                                       // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRecordsCleared;                                  // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Index)>   OnConfirmedRecord;                                 // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Index)>   OnDiscardRecord;                                   // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastAddMatchLog(const struct FMatchEvent& MatcthEvent);
	void MulticastClearMatchLogs();
	void MulticastConfirmMatchLog(int32 Index_0);
	void MulticastDiscardMatchLog(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchEventLog">();
	}
	static class AMatchEventLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchEventLog>();
	}
};
static_assert(alignof(AMatchEventLog) == 0x000008, "Wrong alignment on AMatchEventLog");
static_assert(sizeof(AMatchEventLog) == 0x000278, "Wrong size on AMatchEventLog");
static_assert(offsetof(AMatchEventLog, Events) == 0x000218, "Member 'AMatchEventLog::Events' has a wrong offset!");
static_assert(offsetof(AMatchEventLog, OnNewRecord) == 0x000228, "Member 'AMatchEventLog::OnNewRecord' has a wrong offset!");
static_assert(offsetof(AMatchEventLog, OnRecordsCleared) == 0x000238, "Member 'AMatchEventLog::OnRecordsCleared' has a wrong offset!");
static_assert(offsetof(AMatchEventLog, OnConfirmedRecord) == 0x000248, "Member 'AMatchEventLog::OnConfirmedRecord' has a wrong offset!");
static_assert(offsetof(AMatchEventLog, OnDiscardRecord) == 0x000258, "Member 'AMatchEventLog::OnDiscardRecord' has a wrong offset!");

// Class TimeWatch.TWBaseMatchIntroActor
// 0x0010 (0x0228 - 0x0218)
class ATWBaseMatchIntroActor : public AActor
{
public:
	float                                         RequiredTime;                                      // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequiredIntroTimePerPlayer;                        // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

	class ATWPlayerCameraManager* GetPlayerCameraManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWBaseMatchIntroActor">();
	}
	static class ATWBaseMatchIntroActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWBaseMatchIntroActor>();
	}
};
static_assert(alignof(ATWBaseMatchIntroActor) == 0x000008, "Wrong alignment on ATWBaseMatchIntroActor");
static_assert(sizeof(ATWBaseMatchIntroActor) == 0x000228, "Wrong size on ATWBaseMatchIntroActor");
static_assert(offsetof(ATWBaseMatchIntroActor, RequiredTime) == 0x000218, "Member 'ATWBaseMatchIntroActor::RequiredTime' has a wrong offset!");
static_assert(offsetof(ATWBaseMatchIntroActor, RequiredIntroTimePerPlayer) == 0x00021C, "Member 'ATWBaseMatchIntroActor::RequiredIntroTimePerPlayer' has a wrong offset!");

// Class TimeWatch.TemporalWeapon
// 0x0290 (0x0B00 - 0x0870)
class ATemporalWeapon : public AFirearm
{
public:
	uint8                                         Pad_870[0x58];                                     // 0x0870(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitImpulseMultiplier;                              // 0x08C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeDamageDelayOffset;                            // 0x08CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATemporalParticle>          ImpactParticleClass;                               // 0x08D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* ActorImpacted, class FName BoneHitted)> OnCharacterHit; // 0x08D8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x08E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E9[0x3];                                      // 0x08E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           WeaponSpawnColor;                                  // 0x08EC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8FC[0x4];                                      // 0x08FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoxedUTexture                         BoxedWeaponTexture;                                // 0x0900(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             WeaponIcon;                                        // 0x0908(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             WeaponSmallIcon;                                   // 0x0910(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             KillfeedIcon;                                      // 0x0918(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              CrossHairMaterial;                                 // 0x0920(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            PickupMesh;                                        // 0x0928(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowSightTime;                                     // 0x0930(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSightTime;                                     // 0x0934(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponDrawDurationMultiplier;                      // 0x0938(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToFutureClonesMultiplier;                    // 0x093C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetADSOnShoot;                                  // 0x0940(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanFocusWithNoAmmo;                               // 0x0941(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_942[0x2];                                      // 0x0942(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ADSAnimTime;                                       // 0x0944(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FOVScalarAnim;                                     // 0x0948(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeMeshProjectionWhenFocusing;                 // 0x0950(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_951[0x3];                                      // 0x0951(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstPersonFOV;                                    // 0x0954(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrosshairOpacityWhileSprinting;                    // 0x0958(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95C[0x4];                                      // 0x095C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTWMeleeConfig                         MeleeConfig;                                       // 0x0960(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AbilityProjectileCurve;                            // 0x0988(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ATemporalParticle>, struct FTWParticleCollection> ImpactParticlesPoolMap; // 0x0990(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class ATemporalParticle*>              ActiveInstances;                                   // 0x09E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<uint8>                                 WeaponState;                                       // 0x09F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ATemporalParticle>          MuzzleFlashParticleClass;                          // 0x0A00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATemporalParticle>          BoostedMuzzleFlashParticleClass;                   // 0x0A08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMuzzleFlashPool                       MuzzleFlashPool;                                   // 0x0A10(0x0020)(NativeAccessSpecifierPublic)
	struct FMuzzleFlashPool                       BoostedMuzzleFlashPool;                            // 0x0A30(0x0020)(NativeAccessSpecifierPublic)
	int32                                         MaxAllowedActiveMuzzleFlash;                       // 0x0A50(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A54[0xC];                                      // 0x0A54(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class ATimeWatchProjectile*                   LastProjectileFired;                               // 0x0A60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             ProjectileCollisionChannel;                        // 0x0A68(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A69[0x3];                                      // 0x0A69(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValidationReplayThreshold;                         // 0x0A6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A70[0x8];                                      // 0x0A70(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDSoundConfig                        CharacterHittedSoundConfig;                        // 0x0A78(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ATWProjectileGhost>         ReplayParadoxProjectile;                           // 0x0AD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FWeaponParadoxData>             HistoricWeaponParadoxData;                         // 0x0AD8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UFollowPoseableComponent*               PoseableMeshTP;                                    // 0x0AE8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF0[0x10];                                     // 0x0AF0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CosmeticOnCharacterHitted(class AActor* CharacterHitted, class FName BoneHitted);
	void FillMuzzleFlashPool(struct FMuzzleFlashPool* PoolToFill, TSubclassOf<class ATemporalParticle>* TemporalParticleClass);
	void Multicast_ForceSnapshot(const struct FTemporalWeaponSnapshot& AuthorativeSnapshot);
	void Native_CosmeticsOnProjectileImpact(const struct FHitResult& Hit);
	void SetDrawDuration(float InDrawDuration);
	void SetFireRate(float InFireRate);
	void SetHolsterDuration(float InHolsterDuration);
	void SetMuzzleSpeed(float InMuzzleSpeed);
	void SetReloadTime(float InReloadTime);
	void SpawnMuzzleFlash(float NewCreationTime);

	TSubclassOf<class ATemporalParticle> GetCurrentMuzzleFlashParticleClass() const;
	struct FMuzzleFlashPool GetCurrentMuzzleFlashPool() const;
	class ATimeWatchCharacter* GetHolder() const;
	class ATimeWatchHUD* GetHUD() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TemporalWeapon">();
	}
	static class ATemporalWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATemporalWeapon>();
	}
};
static_assert(alignof(ATemporalWeapon) == 0x000010, "Wrong alignment on ATemporalWeapon");
static_assert(sizeof(ATemporalWeapon) == 0x000B00, "Wrong size on ATemporalWeapon");
static_assert(offsetof(ATemporalWeapon, HitImpulseMultiplier) == 0x0008C8, "Member 'ATemporalWeapon::HitImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, MeleeDamageDelayOffset) == 0x0008CC, "Member 'ATemporalWeapon::MeleeDamageDelayOffset' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, ImpactParticleClass) == 0x0008D0, "Member 'ATemporalWeapon::ImpactParticleClass' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, OnCharacterHit) == 0x0008D8, "Member 'ATemporalWeapon::OnCharacterHit' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, WeaponType) == 0x0008E8, "Member 'ATemporalWeapon::WeaponType' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, WeaponSpawnColor) == 0x0008EC, "Member 'ATemporalWeapon::WeaponSpawnColor' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, BoxedWeaponTexture) == 0x000900, "Member 'ATemporalWeapon::BoxedWeaponTexture' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, WeaponIcon) == 0x000908, "Member 'ATemporalWeapon::WeaponIcon' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, WeaponSmallIcon) == 0x000910, "Member 'ATemporalWeapon::WeaponSmallIcon' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, KillfeedIcon) == 0x000918, "Member 'ATemporalWeapon::KillfeedIcon' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, CrossHairMaterial) == 0x000920, "Member 'ATemporalWeapon::CrossHairMaterial' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, PickupMesh) == 0x000928, "Member 'ATemporalWeapon::PickupMesh' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, ShowSightTime) == 0x000930, "Member 'ATemporalWeapon::ShowSightTime' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, HideSightTime) == 0x000934, "Member 'ATemporalWeapon::HideSightTime' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, WeaponDrawDurationMultiplier) == 0x000938, "Member 'ATemporalWeapon::WeaponDrawDurationMultiplier' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, DamageToFutureClonesMultiplier) == 0x00093C, "Member 'ATemporalWeapon::DamageToFutureClonesMultiplier' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, bResetADSOnShoot) == 0x000940, "Member 'ATemporalWeapon::bResetADSOnShoot' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, bCanFocusWithNoAmmo) == 0x000941, "Member 'ATemporalWeapon::bCanFocusWithNoAmmo' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, ADSAnimTime) == 0x000944, "Member 'ATemporalWeapon::ADSAnimTime' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, FOVScalarAnim) == 0x000948, "Member 'ATemporalWeapon::FOVScalarAnim' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, bChangeMeshProjectionWhenFocusing) == 0x000950, "Member 'ATemporalWeapon::bChangeMeshProjectionWhenFocusing' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, FirstPersonFOV) == 0x000954, "Member 'ATemporalWeapon::FirstPersonFOV' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, CrosshairOpacityWhileSprinting) == 0x000958, "Member 'ATemporalWeapon::CrosshairOpacityWhileSprinting' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, MeleeConfig) == 0x000960, "Member 'ATemporalWeapon::MeleeConfig' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, AbilityProjectileCurve) == 0x000988, "Member 'ATemporalWeapon::AbilityProjectileCurve' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, ImpactParticlesPoolMap) == 0x000990, "Member 'ATemporalWeapon::ImpactParticlesPoolMap' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, ActiveInstances) == 0x0009E0, "Member 'ATemporalWeapon::ActiveInstances' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, WeaponState) == 0x0009F0, "Member 'ATemporalWeapon::WeaponState' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, MuzzleFlashParticleClass) == 0x000A00, "Member 'ATemporalWeapon::MuzzleFlashParticleClass' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, BoostedMuzzleFlashParticleClass) == 0x000A08, "Member 'ATemporalWeapon::BoostedMuzzleFlashParticleClass' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, MuzzleFlashPool) == 0x000A10, "Member 'ATemporalWeapon::MuzzleFlashPool' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, BoostedMuzzleFlashPool) == 0x000A30, "Member 'ATemporalWeapon::BoostedMuzzleFlashPool' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, MaxAllowedActiveMuzzleFlash) == 0x000A50, "Member 'ATemporalWeapon::MaxAllowedActiveMuzzleFlash' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, LastProjectileFired) == 0x000A60, "Member 'ATemporalWeapon::LastProjectileFired' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, ProjectileCollisionChannel) == 0x000A68, "Member 'ATemporalWeapon::ProjectileCollisionChannel' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, ValidationReplayThreshold) == 0x000A6C, "Member 'ATemporalWeapon::ValidationReplayThreshold' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, CharacterHittedSoundConfig) == 0x000A78, "Member 'ATemporalWeapon::CharacterHittedSoundConfig' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, ReplayParadoxProjectile) == 0x000AD0, "Member 'ATemporalWeapon::ReplayParadoxProjectile' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, HistoricWeaponParadoxData) == 0x000AD8, "Member 'ATemporalWeapon::HistoricWeaponParadoxData' has a wrong offset!");
static_assert(offsetof(ATemporalWeapon, PoseableMeshTP) == 0x000AE8, "Member 'ATemporalWeapon::PoseableMeshTP' has a wrong offset!");

// Class TimeWatch.TWLaserWeapon
// 0x0230 (0x0D30 - 0x0B00)
class ATWLaserWeapon : public ATemporalWeapon
{
public:
	class UChildActorComponent*                   FP_MuzzleFlash;                                    // 0x0B00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   TP_MuzzleFlash;                                    // 0x0B08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   LaserImpact;                                       // 0x0B10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FP_LaserRoot;                                      // 0x0B18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               FP_LaserBeamPS;                                    // 0x0B20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        TP_LaserRoot;                                      // 0x0B28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               TP_LaserBeamPS;                                    // 0x0B30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     MuzzleFlashClass;                                  // 0x0B38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     Focusing_MuzzleFlashClass;                         // 0x0B40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     Boosted_MuzzleFlashClass;                          // 0x0B48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     LaserImpactClass;                                  // 0x0B50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     Focusing_LaserImpactClass;                         // 0x0B58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        LaserBeamClass;                                    // 0x0B60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        Focusing_LaserBeamClass;                           // 0x0B68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BeamColor;                                         // 0x0B70(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FocusingBeamColor;                                 // 0x0B80(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WarmupTime;                                        // 0x0B90(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusingWarmUpTime;                                // 0x0B94(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParticleSysSocketName;                             // 0x0B98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x0BA0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA1[0x7];                                      // 0x0BA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseProjectile>            SecondaryProjectileClass;                          // 0x0BA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryProjectileBaseDamageMultiplier;           // 0x0BB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLaserState_Sound                      State_Sound;                                       // 0x0BB4(0x0002)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB6[0x2];                                      // 0x0BB6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDSoundConfig                        Shot_StartCharge;                                  // 0x0BB8(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        Shot_Start;                                        // 0x0C10(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        Shot_End;                                          // 0x0C68(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        Stop_AllSounds;                                    // 0x0CC0(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D18[0x18];                                     // 0x0D18(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnImpactStateChange(bool NewState);
	void OnSoundEvent(ELaserSoundEventType Type, bool IsTimeGoingForward);
	void OnStateChanged(bool bIsFirstPerson, bool NewState);

	float GetLaserLength() const;
	bool IsActiveWeapon(bool bCosmeticOnly) const;
	bool IsBeingUsed() const;
	bool IsWarmingUp(bool bSkipWarmUpTimeCheck) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLaserWeapon">();
	}
	static class ATWLaserWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWLaserWeapon>();
	}
};
static_assert(alignof(ATWLaserWeapon) == 0x000010, "Wrong alignment on ATWLaserWeapon");
static_assert(sizeof(ATWLaserWeapon) == 0x000D30, "Wrong size on ATWLaserWeapon");
static_assert(offsetof(ATWLaserWeapon, FP_MuzzleFlash) == 0x000B00, "Member 'ATWLaserWeapon::FP_MuzzleFlash' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, TP_MuzzleFlash) == 0x000B08, "Member 'ATWLaserWeapon::TP_MuzzleFlash' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, LaserImpact) == 0x000B10, "Member 'ATWLaserWeapon::LaserImpact' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, FP_LaserRoot) == 0x000B18, "Member 'ATWLaserWeapon::FP_LaserRoot' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, FP_LaserBeamPS) == 0x000B20, "Member 'ATWLaserWeapon::FP_LaserBeamPS' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, TP_LaserRoot) == 0x000B28, "Member 'ATWLaserWeapon::TP_LaserRoot' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, TP_LaserBeamPS) == 0x000B30, "Member 'ATWLaserWeapon::TP_LaserBeamPS' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, MuzzleFlashClass) == 0x000B38, "Member 'ATWLaserWeapon::MuzzleFlashClass' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, Focusing_MuzzleFlashClass) == 0x000B40, "Member 'ATWLaserWeapon::Focusing_MuzzleFlashClass' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, Boosted_MuzzleFlashClass) == 0x000B48, "Member 'ATWLaserWeapon::Boosted_MuzzleFlashClass' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, LaserImpactClass) == 0x000B50, "Member 'ATWLaserWeapon::LaserImpactClass' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, Focusing_LaserImpactClass) == 0x000B58, "Member 'ATWLaserWeapon::Focusing_LaserImpactClass' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, LaserBeamClass) == 0x000B60, "Member 'ATWLaserWeapon::LaserBeamClass' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, Focusing_LaserBeamClass) == 0x000B68, "Member 'ATWLaserWeapon::Focusing_LaserBeamClass' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, BeamColor) == 0x000B70, "Member 'ATWLaserWeapon::BeamColor' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, FocusingBeamColor) == 0x000B80, "Member 'ATWLaserWeapon::FocusingBeamColor' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, WarmupTime) == 0x000B90, "Member 'ATWLaserWeapon::WarmupTime' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, FocusingWarmUpTime) == 0x000B94, "Member 'ATWLaserWeapon::FocusingWarmUpTime' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, ParticleSysSocketName) == 0x000B98, "Member 'ATWLaserWeapon::ParticleSysSocketName' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, TraceChannel) == 0x000BA0, "Member 'ATWLaserWeapon::TraceChannel' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, SecondaryProjectileClass) == 0x000BA8, "Member 'ATWLaserWeapon::SecondaryProjectileClass' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, SecondaryProjectileBaseDamageMultiplier) == 0x000BB0, "Member 'ATWLaserWeapon::SecondaryProjectileBaseDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, State_Sound) == 0x000BB4, "Member 'ATWLaserWeapon::State_Sound' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, Shot_StartCharge) == 0x000BB8, "Member 'ATWLaserWeapon::Shot_StartCharge' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, Shot_Start) == 0x000C10, "Member 'ATWLaserWeapon::Shot_Start' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, Shot_End) == 0x000C68, "Member 'ATWLaserWeapon::Shot_End' has a wrong offset!");
static_assert(offsetof(ATWLaserWeapon, Stop_AllSounds) == 0x000CC0, "Member 'ATWLaserWeapon::Stop_AllSounds' has a wrong offset!");

// Class TimeWatch.MatchIntroActor
// 0x0060 (0x0288 - 0x0228)
class AMatchIntroActor final : public ATWBaseMatchIntroActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVsCharacterInfor>              VSCharacterInfo;                                   // 0x0230(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Team0Clone0Mesh;                                   // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Team0Clone1Mesh;                                   // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Team0Clone2Mesh;                                   // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Team1Clone0Mesh;                                   // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Team1Clone1Mesh;                                   // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Team1Clone2Mesh;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVersusScreenDebug                     LeftCharacterDebug;                                // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVersusScreenDebug                     RightCharacterDebug;                               // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         DebugCloneCount;                                   // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_CosmeticOnVersusScreenStart();
	void BP_CosmeticPlayAnimation(int32 CloneIndex, int32 TeamIndex);
	void BP_CosmeticSetDynamicMaterialScalarParameter(int32 CloneIndex, int32 TeamIndex, class FName InMaterialParameterName, float InValue);
	void VersusScreenDebugSetup();

	class USkeletalMeshComponent* GetSkeletalMeshMesh(int32 CloneIndex, int32 TeamIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchIntroActor">();
	}
	static class AMatchIntroActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchIntroActor>();
	}
};
static_assert(alignof(AMatchIntroActor) == 0x000008, "Wrong alignment on AMatchIntroActor");
static_assert(sizeof(AMatchIntroActor) == 0x000288, "Wrong size on AMatchIntroActor");
static_assert(offsetof(AMatchIntroActor, Root) == 0x000228, "Member 'AMatchIntroActor::Root' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, VSCharacterInfo) == 0x000230, "Member 'AMatchIntroActor::VSCharacterInfo' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, Team0Clone0Mesh) == 0x000240, "Member 'AMatchIntroActor::Team0Clone0Mesh' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, Team0Clone1Mesh) == 0x000248, "Member 'AMatchIntroActor::Team0Clone1Mesh' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, Team0Clone2Mesh) == 0x000250, "Member 'AMatchIntroActor::Team0Clone2Mesh' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, Team1Clone0Mesh) == 0x000258, "Member 'AMatchIntroActor::Team1Clone0Mesh' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, Team1Clone1Mesh) == 0x000260, "Member 'AMatchIntroActor::Team1Clone1Mesh' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, Team1Clone2Mesh) == 0x000268, "Member 'AMatchIntroActor::Team1Clone2Mesh' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, LeftCharacterDebug) == 0x000270, "Member 'AMatchIntroActor::LeftCharacterDebug' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, RightCharacterDebug) == 0x000278, "Member 'AMatchIntroActor::RightCharacterDebug' has a wrong offset!");
static_assert(offsetof(AMatchIntroActor, DebugCloneCount) == 0x000280, "Member 'AMatchIntroActor::DebugCloneCount' has a wrong offset!");

// Class TimeWatch.MatchLobbyPlayerSlotWidget
// 0x0010 (0x0290 - 0x0280)
class UMatchLobbyPlayerSlotWidget : public UNGDUserWidget
{
public:
	class UImage*                                 Image_PlayerAvatar;                                // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPartyMember*                         CurrentPartyMember;                                // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_ClearPlayerInfo();
	void BP_FillPlayer(class UTWPartyMember* PartyMember);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchLobbyPlayerSlotWidget">();
	}
	static class UMatchLobbyPlayerSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchLobbyPlayerSlotWidget>();
	}
};
static_assert(alignof(UMatchLobbyPlayerSlotWidget) == 0x000008, "Wrong alignment on UMatchLobbyPlayerSlotWidget");
static_assert(sizeof(UMatchLobbyPlayerSlotWidget) == 0x000290, "Wrong size on UMatchLobbyPlayerSlotWidget");
static_assert(offsetof(UMatchLobbyPlayerSlotWidget, Image_PlayerAvatar) == 0x000280, "Member 'UMatchLobbyPlayerSlotWidget::Image_PlayerAvatar' has a wrong offset!");
static_assert(offsetof(UMatchLobbyPlayerSlotWidget, CurrentPartyMember) == 0x000288, "Member 'UMatchLobbyPlayerSlotWidget::CurrentPartyMember' has a wrong offset!");

// Class TimeWatch.TWInteractableComponent
// 0x0010 (0x0410 - 0x0400)
class UTWInteractableComponent : public UCapsuleComponent
{
public:
	bool                                          bHasInitialCooldown;                               // 0x03F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOneUseOnly;                                       // 0x03F9(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FA[0x2];                                      // 0x03FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialCooldown;                                   // 0x03FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoolDown;                                          // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemainingCooldown;                                 // 0x0404(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetOnNewRound;                                  // 0x0408(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasUsedOnce;                                      // 0x0409(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40A[0x6];                                      // 0x040A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanInteract();
	bool IsOnCooldown();

	float GetElapsedCooldownPercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWInteractableComponent">();
	}
	static class UTWInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWInteractableComponent>();
	}
};
static_assert(alignof(UTWInteractableComponent) == 0x000010, "Wrong alignment on UTWInteractableComponent");
static_assert(sizeof(UTWInteractableComponent) == 0x000410, "Wrong size on UTWInteractableComponent");
static_assert(offsetof(UTWInteractableComponent, bHasInitialCooldown) == 0x0003F8, "Member 'UTWInteractableComponent::bHasInitialCooldown' has a wrong offset!");
static_assert(offsetof(UTWInteractableComponent, bOneUseOnly) == 0x0003F9, "Member 'UTWInteractableComponent::bOneUseOnly' has a wrong offset!");
static_assert(offsetof(UTWInteractableComponent, InitialCooldown) == 0x0003FC, "Member 'UTWInteractableComponent::InitialCooldown' has a wrong offset!");
static_assert(offsetof(UTWInteractableComponent, CoolDown) == 0x000400, "Member 'UTWInteractableComponent::CoolDown' has a wrong offset!");
static_assert(offsetof(UTWInteractableComponent, RemainingCooldown) == 0x000404, "Member 'UTWInteractableComponent::RemainingCooldown' has a wrong offset!");
static_assert(offsetof(UTWInteractableComponent, bResetOnNewRound) == 0x000408, "Member 'UTWInteractableComponent::bResetOnNewRound' has a wrong offset!");
static_assert(offsetof(UTWInteractableComponent, bWasUsedOnce) == 0x000409, "Member 'UTWInteractableComponent::bWasUsedOnce' has a wrong offset!");

// Class TimeWatch.MissionsTelemetrySystem
// 0x0000 (0x0028 - 0x0028)
class UMissionsTelemetrySystem final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionsTelemetrySystem">();
	}
	static class UMissionsTelemetrySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionsTelemetrySystem>();
	}
};
static_assert(alignof(UMissionsTelemetrySystem) == 0x000008, "Wrong alignment on UMissionsTelemetrySystem");
static_assert(sizeof(UMissionsTelemetrySystem) == 0x000028, "Wrong size on UMissionsTelemetrySystem");

// Class TimeWatch.NewsItemWidget
// 0x0088 (0x0308 - 0x0280)
class UNewsItemWidget : public UNGDUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnHovered;                                         // 0x0280(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ButtonIndex)> OnClicked;                                     // 0x0290(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Outline;                                     // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Center;                                      // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_Select;                                     // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ImageTexture;                                      // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x48];                                     // 0x02C0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSelectButtonClicked();
	void OnSelectButtonHovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewsItemWidget">();
	}
	static class UNewsItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewsItemWidget>();
	}
};
static_assert(alignof(UNewsItemWidget) == 0x000008, "Wrong alignment on UNewsItemWidget");
static_assert(sizeof(UNewsItemWidget) == 0x000308, "Wrong size on UNewsItemWidget");
static_assert(offsetof(UNewsItemWidget, OnHovered) == 0x000280, "Member 'UNewsItemWidget::OnHovered' has a wrong offset!");
static_assert(offsetof(UNewsItemWidget, OnClicked) == 0x000290, "Member 'UNewsItemWidget::OnClicked' has a wrong offset!");
static_assert(offsetof(UNewsItemWidget, Image_Outline) == 0x0002A0, "Member 'UNewsItemWidget::Image_Outline' has a wrong offset!");
static_assert(offsetof(UNewsItemWidget, Image_Center) == 0x0002A8, "Member 'UNewsItemWidget::Image_Center' has a wrong offset!");
static_assert(offsetof(UNewsItemWidget, Button_Select) == 0x0002B0, "Member 'UNewsItemWidget::Button_Select' has a wrong offset!");
static_assert(offsetof(UNewsItemWidget, ImageTexture) == 0x0002B8, "Member 'UNewsItemWidget::ImageTexture' has a wrong offset!");

// Class TimeWatch.TWInteractableActor
// 0x0020 (0x0238 - 0x0218)
class ATWInteractableActor : public AActor
{
public:
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWInteractableRewindableComponent*     InteractableComp;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BP_Authority_OnInteraction(int32 ID, class AActor* Interactor);
	void BP_Authority_OnUndoInteraction(int32 ID, class AActor* Interactor);
	void BP_Cosmetic_OnInteraction(int32 ID, class AActor* Interactor);
	void BP_Cosmetic_OnUndoInteraction(int32 ID, class AActor* Interactor);
	void OnInteraction_Internal(int32 ID, class AActor* Interactor);
	void OnInteractionUndo_Internal(int32 ID, class AActor* Interactor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWInteractableActor">();
	}
	static class ATWInteractableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWInteractableActor>();
	}
};
static_assert(alignof(ATWInteractableActor) == 0x000008, "Wrong alignment on ATWInteractableActor");
static_assert(sizeof(ATWInteractableActor) == 0x000238, "Wrong size on ATWInteractableActor");
static_assert(offsetof(ATWInteractableActor, Root) == 0x000228, "Member 'ATWInteractableActor::Root' has a wrong offset!");
static_assert(offsetof(ATWInteractableActor, InteractableComp) == 0x000230, "Member 'ATWInteractableActor::InteractableComp' has a wrong offset!");

// Class TimeWatch.TWHealthPackActor
// 0x0020 (0x0258 - 0x0238)
class ATWHealthPackActor : public ATWInteractableActor
{
public:
	int32                                         HealthRecoveredPercent;                            // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   DetectionVolume;                                   // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHealOverTime;                               // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHealArea;                                   // 0x0249(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A[0x2];                                      // 0x024A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealAreaTime;                                      // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_TriggerHealOverTime(class ATimeWatchCharacter* Character, bool bWasReSynced);
	void EndHealArea();
	void OnStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnVolumeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void TriggerHealOverTime(class ATimeWatchCharacter* Character, bool bWasReSynced);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWHealthPackActor">();
	}
	static class ATWHealthPackActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWHealthPackActor>();
	}
};
static_assert(alignof(ATWHealthPackActor) == 0x000008, "Wrong alignment on ATWHealthPackActor");
static_assert(sizeof(ATWHealthPackActor) == 0x000258, "Wrong size on ATWHealthPackActor");
static_assert(offsetof(ATWHealthPackActor, HealthRecoveredPercent) == 0x000238, "Member 'ATWHealthPackActor::HealthRecoveredPercent' has a wrong offset!");
static_assert(offsetof(ATWHealthPackActor, DetectionVolume) == 0x000240, "Member 'ATWHealthPackActor::DetectionVolume' has a wrong offset!");
static_assert(offsetof(ATWHealthPackActor, bEnableHealOverTime) == 0x000248, "Member 'ATWHealthPackActor::bEnableHealOverTime' has a wrong offset!");
static_assert(offsetof(ATWHealthPackActor, bEnableHealArea) == 0x000249, "Member 'ATWHealthPackActor::bEnableHealArea' has a wrong offset!");
static_assert(offsetof(ATWHealthPackActor, HealAreaTime) == 0x00024C, "Member 'ATWHealthPackActor::HealAreaTime' has a wrong offset!");

// Class TimeWatch.NotificationWidget
// 0x0010 (0x0290 - 0x0280)
class UNotificationWidget final : public UNGDUserWidget
{
public:
	class UTextBlock*                             TextBlock_DisplayText;                             // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationWidget">();
	}
	static class UNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationWidget>();
	}
};
static_assert(alignof(UNotificationWidget) == 0x000008, "Wrong alignment on UNotificationWidget");
static_assert(sizeof(UNotificationWidget) == 0x000290, "Wrong size on UNotificationWidget");
static_assert(offsetof(UNotificationWidget, TextBlock_DisplayText) == 0x000280, "Member 'UNotificationWidget::TextBlock_DisplayText' has a wrong offset!");

// Class TimeWatch.PartyMemberItemWidget
// 0x0040 (0x02C0 - 0x0280)
class UPartyMemberItemWidget : public UNGDUserWidget
{
public:
	class UImage*                                 Image_Avatar;                                      // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Button_Leave;                                      // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasPanel_LoadingPlayer;                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PersonaName;                                       // 0x0298(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 PartyHostIcon;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnLeaveClicked();
	void SetPartyMemberAvatar(class UTexture2D* avatar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyMemberItemWidget">();
	}
	static class UPartyMemberItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyMemberItemWidget>();
	}
};
static_assert(alignof(UPartyMemberItemWidget) == 0x000008, "Wrong alignment on UPartyMemberItemWidget");
static_assert(sizeof(UPartyMemberItemWidget) == 0x0002C0, "Wrong size on UPartyMemberItemWidget");
static_assert(offsetof(UPartyMemberItemWidget, Image_Avatar) == 0x000280, "Member 'UPartyMemberItemWidget::Image_Avatar' has a wrong offset!");
static_assert(offsetof(UPartyMemberItemWidget, Button_Leave) == 0x000288, "Member 'UPartyMemberItemWidget::Button_Leave' has a wrong offset!");
static_assert(offsetof(UPartyMemberItemWidget, CanvasPanel_LoadingPlayer) == 0x000290, "Member 'UPartyMemberItemWidget::CanvasPanel_LoadingPlayer' has a wrong offset!");
static_assert(offsetof(UPartyMemberItemWidget, PersonaName) == 0x000298, "Member 'UPartyMemberItemWidget::PersonaName' has a wrong offset!");
static_assert(offsetof(UPartyMemberItemWidget, PartyHostIcon) == 0x0002B8, "Member 'UPartyMemberItemWidget::PartyHostIcon' has a wrong offset!");

// Class TimeWatch.TWActivableActor
// 0x0008 (0x0220 - 0x0218)
class ATWActivableActor : public AActor
{
public:
	bool                                          bIsStatusActive;                                   // 0x0218(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBeginActive;                                      // 0x0219(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_Update_Behavior(bool bNewValue);
	void BP_Update_Cosmetic(bool bNewValue);
	void OnRep_bIsStatusActive();
	void SetActiveStatus(bool bNewValue);

	bool GetActiveStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWActivableActor">();
	}
	static class ATWActivableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWActivableActor>();
	}
};
static_assert(alignof(ATWActivableActor) == 0x000008, "Wrong alignment on ATWActivableActor");
static_assert(sizeof(ATWActivableActor) == 0x000220, "Wrong size on ATWActivableActor");
static_assert(offsetof(ATWActivableActor, bIsStatusActive) == 0x000218, "Member 'ATWActivableActor::bIsStatusActive' has a wrong offset!");
static_assert(offsetof(ATWActivableActor, bBeginActive) == 0x000219, "Member 'ATWActivableActor::bBeginActive' has a wrong offset!");

// Class TimeWatch.TWInteractiveSwitch
// 0x0018 (0x0238 - 0x0220)
class ATWInteractiveSwitch final : public ATWActivableActor
{
public:
	TArray<class ATWActivableActor*>              ActivablesActors;                                  // 0x0220(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSetOppositeStatus;                                // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWInteractiveSwitch">();
	}
	static class ATWInteractiveSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWInteractiveSwitch>();
	}
};
static_assert(alignof(ATWInteractiveSwitch) == 0x000008, "Wrong alignment on ATWInteractiveSwitch");
static_assert(sizeof(ATWInteractiveSwitch) == 0x000238, "Wrong size on ATWInteractiveSwitch");
static_assert(offsetof(ATWInteractiveSwitch, ActivablesActors) == 0x000220, "Member 'ATWInteractiveSwitch::ActivablesActors' has a wrong offset!");
static_assert(offsetof(ATWInteractiveSwitch, bSetOppositeStatus) == 0x000230, "Member 'ATWInteractiveSwitch::bSetOppositeStatus' has a wrong offset!");

// Class TimeWatch.PartyWidget
// 0x0020 (0x02A0 - 0x0280)
class UPartyWidget : public UNGDUserWidget
{
public:
	TSubclassOf<class UPartyMemberItemWidget>     ItemClass;                                         // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                ItemMargin;                                        // 0x0288(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         HorizontalBox_Party;                               // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdatePartyData(const bool bPartyStructureChanged);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyWidget">();
	}
	static class UPartyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyWidget>();
	}
};
static_assert(alignof(UPartyWidget) == 0x000008, "Wrong alignment on UPartyWidget");
static_assert(sizeof(UPartyWidget) == 0x0002A0, "Wrong size on UPartyWidget");
static_assert(offsetof(UPartyWidget, ItemClass) == 0x000280, "Member 'UPartyWidget::ItemClass' has a wrong offset!");
static_assert(offsetof(UPartyWidget, ItemMargin) == 0x000288, "Member 'UPartyWidget::ItemMargin' has a wrong offset!");
static_assert(offsetof(UPartyWidget, HorizontalBox_Party) == 0x000298, "Member 'UPartyWidget::HorizontalBox_Party' has a wrong offset!");

// Class TimeWatch.PeripheralDamageWidget
// 0x00D8 (0x0358 - 0x0280)
class UPeripheralDamageWidget : public UNGDUserWidget
{
public:
	class UImage*                                 Image_Feedback;                                    // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorCriticalHit;                                  // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorHit;                                          // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0xA8];                                     // 0x02A8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            IntensityCurve;                                    // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PeripheralDamageWidget">();
	}
	static class UPeripheralDamageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPeripheralDamageWidget>();
	}
};
static_assert(alignof(UPeripheralDamageWidget) == 0x000008, "Wrong alignment on UPeripheralDamageWidget");
static_assert(sizeof(UPeripheralDamageWidget) == 0x000358, "Wrong size on UPeripheralDamageWidget");
static_assert(offsetof(UPeripheralDamageWidget, Image_Feedback) == 0x000280, "Member 'UPeripheralDamageWidget::Image_Feedback' has a wrong offset!");
static_assert(offsetof(UPeripheralDamageWidget, ColorCriticalHit) == 0x000288, "Member 'UPeripheralDamageWidget::ColorCriticalHit' has a wrong offset!");
static_assert(offsetof(UPeripheralDamageWidget, ColorHit) == 0x000298, "Member 'UPeripheralDamageWidget::ColorHit' has a wrong offset!");
static_assert(offsetof(UPeripheralDamageWidget, IntensityCurve) == 0x000350, "Member 'UPeripheralDamageWidget::IntensityCurve' has a wrong offset!");

// Class TimeWatch.TWLobbyChallengeWidget
// 0x00F8 (0x0378 - 0x0280)
class UTWLobbyChallengeWidget final : public UNGDUserWidget
{
public:
	class UNGDBackendLobby*                       Lobby;                                             // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLobbyPlayerInfo>               TestLobbyPlayerInfo;                               // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 EuropeServerName;                                  // 0x0298(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 NorthAmericaServerName;                            // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SouthAmericaServerName;                            // 0x02B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TestServerName;                                    // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UUserWidget*>       PlayersMap;                                        // 0x02D8(0x0050)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWLobbyGridPanelWidget>    GridWidgetClass;                                   // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWLobbyPlayerRowWidget>    PlayerRowWidgetClass;                              // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_GridsContainer;                            // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_QuickMatch;                                 // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWLobbyGridPanelWidget*>        LobbyGridArray;                                    // 0x0348(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentGridPanelIndex;                             // 0x0358(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRowsPerGrid;                                    // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRowsPerColumn;                                  // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x14];                                     // 0x0364(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNewLobbyGrid();
	class UTWLobbyPlayerRowWidget* AddNewLobbyPlayerRow(const struct FLobbyPlayerInfo& InLobbyPlayerInfo);
	int32 ChangeGridPanel(int32 PanelIndex);
	void ClearGridsContainer();
	void OnLobbyCreated();
	void OnUpdateReceivedEvent();
	void SelectServer(const class FString& ServerName);
	void SetPlayerStats_BP(const struct FNGDBackendAccountPlayerStats& PlayerStats);
	void ShowQuickMatchButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLobbyChallengeWidget">();
	}
	static class UTWLobbyChallengeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLobbyChallengeWidget>();
	}
};
static_assert(alignof(UTWLobbyChallengeWidget) == 0x000008, "Wrong alignment on UTWLobbyChallengeWidget");
static_assert(sizeof(UTWLobbyChallengeWidget) == 0x000378, "Wrong size on UTWLobbyChallengeWidget");
static_assert(offsetof(UTWLobbyChallengeWidget, Lobby) == 0x000280, "Member 'UTWLobbyChallengeWidget::Lobby' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, TestLobbyPlayerInfo) == 0x000288, "Member 'UTWLobbyChallengeWidget::TestLobbyPlayerInfo' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, EuropeServerName) == 0x000298, "Member 'UTWLobbyChallengeWidget::EuropeServerName' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, NorthAmericaServerName) == 0x0002A8, "Member 'UTWLobbyChallengeWidget::NorthAmericaServerName' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, SouthAmericaServerName) == 0x0002B8, "Member 'UTWLobbyChallengeWidget::SouthAmericaServerName' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, TestServerName) == 0x0002C8, "Member 'UTWLobbyChallengeWidget::TestServerName' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, PlayersMap) == 0x0002D8, "Member 'UTWLobbyChallengeWidget::PlayersMap' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, GridWidgetClass) == 0x000328, "Member 'UTWLobbyChallengeWidget::GridWidgetClass' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, PlayerRowWidgetClass) == 0x000330, "Member 'UTWLobbyChallengeWidget::PlayerRowWidgetClass' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, Overlay_GridsContainer) == 0x000338, "Member 'UTWLobbyChallengeWidget::Overlay_GridsContainer' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, Button_QuickMatch) == 0x000340, "Member 'UTWLobbyChallengeWidget::Button_QuickMatch' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, LobbyGridArray) == 0x000348, "Member 'UTWLobbyChallengeWidget::LobbyGridArray' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, CurrentGridPanelIndex) == 0x000358, "Member 'UTWLobbyChallengeWidget::CurrentGridPanelIndex' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, MaxRowsPerGrid) == 0x00035C, "Member 'UTWLobbyChallengeWidget::MaxRowsPerGrid' has a wrong offset!");
static_assert(offsetof(UTWLobbyChallengeWidget, MaxRowsPerColumn) == 0x000360, "Member 'UTWLobbyChallengeWidget::MaxRowsPerColumn' has a wrong offset!");

// Class TimeWatch.PhysicsRewindableActor
// 0x0048 (0x0260 - 0x0218)
class APhysicsRewindableActor final : public AActor
{
public:
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleModifierOverride;                             // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFluxTimelineStaticActor*               Timeline;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      RewindCollider;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HitRegistrationCollider;                           // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDRewindComponent*                    RewindComponent;                                   // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDPostUpdateWorkComponent*            NGDPostUpdateWorkComponent;                        // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPostUpdateWorkTick();

	class UCapsuleComponent* GetHitRegistrationCollider() const;
	class UMeshComponent* GetRewindableMeshComponent() const;
	class UCapsuleComponent* GetRewindCollider() const;
	class UNGDRewindComponent* GetRewindComponent() const;
	bool IsRewindRelevant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsRewindableActor">();
	}
	static class APhysicsRewindableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsRewindableActor>();
	}
};
static_assert(alignof(APhysicsRewindableActor) == 0x000008, "Wrong alignment on APhysicsRewindableActor");
static_assert(sizeof(APhysicsRewindableActor) == 0x000260, "Wrong size on APhysicsRewindableActor");
static_assert(offsetof(APhysicsRewindableActor, SkeletalMeshComponent) == 0x000228, "Member 'APhysicsRewindableActor::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(APhysicsRewindableActor, ScaleModifierOverride) == 0x000230, "Member 'APhysicsRewindableActor::ScaleModifierOverride' has a wrong offset!");
static_assert(offsetof(APhysicsRewindableActor, Timeline) == 0x000238, "Member 'APhysicsRewindableActor::Timeline' has a wrong offset!");
static_assert(offsetof(APhysicsRewindableActor, RewindCollider) == 0x000240, "Member 'APhysicsRewindableActor::RewindCollider' has a wrong offset!");
static_assert(offsetof(APhysicsRewindableActor, HitRegistrationCollider) == 0x000248, "Member 'APhysicsRewindableActor::HitRegistrationCollider' has a wrong offset!");
static_assert(offsetof(APhysicsRewindableActor, RewindComponent) == 0x000250, "Member 'APhysicsRewindableActor::RewindComponent' has a wrong offset!");
static_assert(offsetof(APhysicsRewindableActor, NGDPostUpdateWorkComponent) == 0x000258, "Member 'APhysicsRewindableActor::NGDPostUpdateWorkComponent' has a wrong offset!");

// Class TimeWatch.TWLeagueDataAsset
// 0x0050 (0x0080 - 0x0030)
class UTWLeagueDataAsset final : public UDataAsset
{
public:
	TMap<ENGDBackendLeaderboardLevel, struct FTWLeagueInfo> Levels;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLeagueDataAsset">();
	}
	static class UTWLeagueDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLeagueDataAsset>();
	}
};
static_assert(alignof(UTWLeagueDataAsset) == 0x000008, "Wrong alignment on UTWLeagueDataAsset");
static_assert(sizeof(UTWLeagueDataAsset) == 0x000080, "Wrong size on UTWLeagueDataAsset");
static_assert(offsetof(UTWLeagueDataAsset, Levels) == 0x000030, "Member 'UTWLeagueDataAsset::Levels' has a wrong offset!");

// Class TimeWatch.PingCompassWidget
// 0x0098 (0x0358 - 0x02C0)
class UPingCompassWidget : public UTW2DCompass
{
public:
	struct FPingMarker                            CurrentPing;                                       // 0x02C0(0x0040)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnPingPlaced;                          // 0x0300(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void CosmeticOnPingPlaced();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingCompassWidget">();
	}
	static class UPingCompassWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingCompassWidget>();
	}
};
static_assert(alignof(UPingCompassWidget) == 0x000008, "Wrong alignment on UPingCompassWidget");
static_assert(sizeof(UPingCompassWidget) == 0x000358, "Wrong size on UPingCompassWidget");
static_assert(offsetof(UPingCompassWidget, CurrentPing) == 0x0002C0, "Member 'UPingCompassWidget::CurrentPing' has a wrong offset!");
static_assert(offsetof(UPingCompassWidget, SoundConfig_OnPingPlaced) == 0x000300, "Member 'UPingCompassWidget::SoundConfig_OnPingPlaced' has a wrong offset!");

// Class TimeWatch.SelfHealthBarStatus
// 0x0050 (0x02D0 - 0x0280)
class USelfHealthBarStatus : public UNGDUserWidget
{
public:
	TSubclassOf<class USelfHealthBarStatusItem>   PastClonesHealthBarItemClass;                      // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USelfHealthBarStatusItem>   NextClonesHealthBarItemClass;                      // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_PastClones;                            // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_FutureClones;                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_AbilityIcon;                                 // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USelfHealthBarStatusItem*               SelfHealthBarStatusItem_Current;                   // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USelfHealthBarStatusItem*>       PastClonesWidgetItems;                             // 0x02B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USelfHealthBarStatusItem*>       FutureClonesWidgetItems;                           // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelfHealthBarStatus">();
	}
	static class USelfHealthBarStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelfHealthBarStatus>();
	}
};
static_assert(alignof(USelfHealthBarStatus) == 0x000008, "Wrong alignment on USelfHealthBarStatus");
static_assert(sizeof(USelfHealthBarStatus) == 0x0002D0, "Wrong size on USelfHealthBarStatus");
static_assert(offsetof(USelfHealthBarStatus, PastClonesHealthBarItemClass) == 0x000280, "Member 'USelfHealthBarStatus::PastClonesHealthBarItemClass' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatus, NextClonesHealthBarItemClass) == 0x000288, "Member 'USelfHealthBarStatus::NextClonesHealthBarItemClass' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatus, VerticalBox_PastClones) == 0x000290, "Member 'USelfHealthBarStatus::VerticalBox_PastClones' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatus, HorizontalBox_FutureClones) == 0x000298, "Member 'USelfHealthBarStatus::HorizontalBox_FutureClones' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatus, Image_AbilityIcon) == 0x0002A0, "Member 'USelfHealthBarStatus::Image_AbilityIcon' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatus, SelfHealthBarStatusItem_Current) == 0x0002A8, "Member 'USelfHealthBarStatus::SelfHealthBarStatusItem_Current' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatus, PastClonesWidgetItems) == 0x0002B0, "Member 'USelfHealthBarStatus::PastClonesWidgetItems' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatus, FutureClonesWidgetItems) == 0x0002C0, "Member 'USelfHealthBarStatus::FutureClonesWidgetItems' has a wrong offset!");

// Class TimeWatch.TWInteractableTimeline
// 0x0028 (0x00F0 - 0x00C8)
class UTWInteractableTimeline final : public UFluxTimeline
{
public:
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWInteractableRewindableComponent*     InteractableRewindableComp;                        // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWInteractableTimeline">();
	}
	static class UTWInteractableTimeline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWInteractableTimeline>();
	}
};
static_assert(alignof(UTWInteractableTimeline) == 0x000008, "Wrong alignment on UTWInteractableTimeline");
static_assert(sizeof(UTWInteractableTimeline) == 0x0000F0, "Wrong size on UTWInteractableTimeline");
static_assert(offsetof(UTWInteractableTimeline, InteractableRewindableComp) == 0x0000E8, "Member 'UTWInteractableTimeline::InteractableRewindableComp' has a wrong offset!");

// Class TimeWatch.SelfHealthBarStatusItem
// 0x00A0 (0x0320 - 0x0280)
class USelfHealthBarStatusItem : public UNGDUserWidget
{
public:
	float                                         HealthBarWidth;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarHeight;                                   // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialInfoWidth;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialInfoHeight;                                  // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NextClonesColor;                                   // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWRadialCloneInfo*                     RadialCloneInfo_Clone;                             // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_DeactivatedBar;                              // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWLinearHealthBar*                     LinearHealthBar_Clone;                             // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_Desync;                                       // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_Resyncing;                                    // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_CurrentHealth;                                // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_DamageReductionGroup;                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_CurrentDamageReduction;                       // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Armoricon;                                   // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAFutureClone;                                   // 0x02E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAPastClone;                                     // 0x02E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ATimeWatchCharacter*                    OwnerCharacter;                                    // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x28];                                     // 0x02F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelfHealthBarStatusItem">();
	}
	static class USelfHealthBarStatusItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelfHealthBarStatusItem>();
	}
};
static_assert(alignof(USelfHealthBarStatusItem) == 0x000008, "Wrong alignment on USelfHealthBarStatusItem");
static_assert(sizeof(USelfHealthBarStatusItem) == 0x000320, "Wrong size on USelfHealthBarStatusItem");
static_assert(offsetof(USelfHealthBarStatusItem, HealthBarWidth) == 0x000280, "Member 'USelfHealthBarStatusItem::HealthBarWidth' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, HealthBarHeight) == 0x000284, "Member 'USelfHealthBarStatusItem::HealthBarHeight' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, RadialInfoWidth) == 0x000288, "Member 'USelfHealthBarStatusItem::RadialInfoWidth' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, RadialInfoHeight) == 0x00028C, "Member 'USelfHealthBarStatusItem::RadialInfoHeight' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, NextClonesColor) == 0x000290, "Member 'USelfHealthBarStatusItem::NextClonesColor' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, RadialCloneInfo_Clone) == 0x0002A0, "Member 'USelfHealthBarStatusItem::RadialCloneInfo_Clone' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, Image_DeactivatedBar) == 0x0002A8, "Member 'USelfHealthBarStatusItem::Image_DeactivatedBar' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, LinearHealthBar_Clone) == 0x0002B0, "Member 'USelfHealthBarStatusItem::LinearHealthBar_Clone' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, Text_Desync) == 0x0002B8, "Member 'USelfHealthBarStatusItem::Text_Desync' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, Text_Resyncing) == 0x0002C0, "Member 'USelfHealthBarStatusItem::Text_Resyncing' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, Text_CurrentHealth) == 0x0002C8, "Member 'USelfHealthBarStatusItem::Text_CurrentHealth' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, Overlay_DamageReductionGroup) == 0x0002D0, "Member 'USelfHealthBarStatusItem::Overlay_DamageReductionGroup' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, Text_CurrentDamageReduction) == 0x0002D8, "Member 'USelfHealthBarStatusItem::Text_CurrentDamageReduction' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, Image_Armoricon) == 0x0002E0, "Member 'USelfHealthBarStatusItem::Image_Armoricon' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, bIsAFutureClone) == 0x0002E8, "Member 'USelfHealthBarStatusItem::bIsAFutureClone' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, bIsAPastClone) == 0x0002E9, "Member 'USelfHealthBarStatusItem::bIsAPastClone' has a wrong offset!");
static_assert(offsetof(USelfHealthBarStatusItem, OwnerCharacter) == 0x0002F0, "Member 'USelfHealthBarStatusItem::OwnerCharacter' has a wrong offset!");

// Class TimeWatch.ServerIdleGameMode
// 0x0000 (0x03B0 - 0x03B0)
class AServerIdleGameMode final : public ANGDGameMode
{
public:
	void OnImpostorData(const class FString& ImpostorData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerIdleGameMode">();
	}
	static class AServerIdleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AServerIdleGameMode>();
	}
};
static_assert(alignof(AServerIdleGameMode) == 0x000008, "Wrong alignment on AServerIdleGameMode");
static_assert(sizeof(AServerIdleGameMode) == 0x0003B0, "Wrong size on AServerIdleGameMode");

// Class TimeWatch.TWDeathMatchKillsWidget
// 0x0090 (0x0310 - 0x0280)
class UTWDeathMatchKillsWidget : public UNGDUserWidget
{
public:
	class UHorizontalBox*                         HorizontalBox_LeftScoreBox;                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_RightScoreBox;                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftAdvantage;                               // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftDetail;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightAdvantage;                              // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightDetail;                                 // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWDeathMatchScoreWidget>   DeathMatchScoreWidgetTemplate;                     // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     AlliedGradientMaterial;                            // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     OpponentGradientMaterial;                          // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DetailGradientMaterial;                            // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreSlotSizeX;                                    // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreSlotSizeY;                                    // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreSlotPadding;                                  // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoLeadAlpha;                                       // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWDeathMatchScoreWidget*>       Left_DMScoreWidgets;                               // 0x02E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWDeathMatchScoreWidget*>       Right_DMScoreWidgets;                              // 0x02F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWDeathMatchKillsWidget">();
	}
	static class UTWDeathMatchKillsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWDeathMatchKillsWidget>();
	}
};
static_assert(alignof(UTWDeathMatchKillsWidget) == 0x000008, "Wrong alignment on UTWDeathMatchKillsWidget");
static_assert(sizeof(UTWDeathMatchKillsWidget) == 0x000310, "Wrong size on UTWDeathMatchKillsWidget");
static_assert(offsetof(UTWDeathMatchKillsWidget, HorizontalBox_LeftScoreBox) == 0x000280, "Member 'UTWDeathMatchKillsWidget::HorizontalBox_LeftScoreBox' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, HorizontalBox_RightScoreBox) == 0x000288, "Member 'UTWDeathMatchKillsWidget::HorizontalBox_RightScoreBox' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, Image_LeftAdvantage) == 0x000290, "Member 'UTWDeathMatchKillsWidget::Image_LeftAdvantage' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, Image_LeftDetail) == 0x000298, "Member 'UTWDeathMatchKillsWidget::Image_LeftDetail' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, Image_RightAdvantage) == 0x0002A0, "Member 'UTWDeathMatchKillsWidget::Image_RightAdvantage' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, Image_RightDetail) == 0x0002A8, "Member 'UTWDeathMatchKillsWidget::Image_RightDetail' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, DeathMatchScoreWidgetTemplate) == 0x0002B0, "Member 'UTWDeathMatchKillsWidget::DeathMatchScoreWidgetTemplate' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, AlliedGradientMaterial) == 0x0002B8, "Member 'UTWDeathMatchKillsWidget::AlliedGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, OpponentGradientMaterial) == 0x0002C0, "Member 'UTWDeathMatchKillsWidget::OpponentGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, DetailGradientMaterial) == 0x0002C8, "Member 'UTWDeathMatchKillsWidget::DetailGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, ScoreSlotSizeX) == 0x0002D0, "Member 'UTWDeathMatchKillsWidget::ScoreSlotSizeX' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, ScoreSlotSizeY) == 0x0002D4, "Member 'UTWDeathMatchKillsWidget::ScoreSlotSizeY' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, ScoreSlotPadding) == 0x0002D8, "Member 'UTWDeathMatchKillsWidget::ScoreSlotPadding' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, NoLeadAlpha) == 0x0002DC, "Member 'UTWDeathMatchKillsWidget::NoLeadAlpha' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, Left_DMScoreWidgets) == 0x0002E0, "Member 'UTWDeathMatchKillsWidget::Left_DMScoreWidgets' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchKillsWidget, Right_DMScoreWidgets) == 0x0002F0, "Member 'UTWDeathMatchKillsWidget::Right_DMScoreWidgets' has a wrong offset!");

// Class TimeWatch.ServerLobbyGameMode
// 0x0020 (0x03D0 - 0x03B0)
class AServerLobbyGameMode final : public ANGDGameMode
{
public:
	TMulticastInlineDelegate<void()>              OnValidationSuccesful;                             // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchDescriptorReceived();
	void TryStartMatch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerLobbyGameMode">();
	}
	static class AServerLobbyGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AServerLobbyGameMode>();
	}
};
static_assert(alignof(AServerLobbyGameMode) == 0x000008, "Wrong alignment on AServerLobbyGameMode");
static_assert(sizeof(AServerLobbyGameMode) == 0x0003D0, "Wrong size on AServerLobbyGameMode");
static_assert(offsetof(AServerLobbyGameMode, OnValidationSuccesful) == 0x0003B0, "Member 'AServerLobbyGameMode::OnValidationSuccesful' has a wrong offset!");

// Class TimeWatch.ShootTarget
// 0x0008 (0x0220 - 0x0218)
class AShootTarget final : public AActor
{
public:
	float                                         MaxHitPoints;                                      // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitPoints;                                         // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTargetDestroyed();
	void OnTookDamage(float RelativeDamage);
	void TakeBulletDamage(float Damage);

	float GetNormalizedHitPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShootTarget">();
	}
	static class AShootTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShootTarget>();
	}
};
static_assert(alignof(AShootTarget) == 0x000008, "Wrong alignment on AShootTarget");
static_assert(sizeof(AShootTarget) == 0x000220, "Wrong size on AShootTarget");
static_assert(offsetof(AShootTarget, MaxHitPoints) == 0x000218, "Member 'AShootTarget::MaxHitPoints' has a wrong offset!");
static_assert(offsetof(AShootTarget, HitPoints) == 0x00021C, "Member 'AShootTarget::HitPoints' has a wrong offset!");

// Class TimeWatch.TWMatchIntroActor
// 0x0108 (0x0330 - 0x0228)
class ATWMatchIntroActor : public ATWBaseMatchIntroActor
{
public:
	class USceneComponent*                        MatchIntroRoot;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root_TeamA;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        Arrow_TeamA;                                       // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root_TeamB;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        Arrow_TeamB;                                       // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATWPlayerIntroActor*>            IntroActors;                                       // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        AssetsCache;                                       // 0x0268(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        NGDAk_MatchIntroMusic;                             // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_IntroMusicStart;                       // 0x0280(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_IntroMusicLastPlayerIntroStart;        // 0x02D8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void Blueprint_Start();
	void OnIntroEnded();

	class ATWPlayerIntroActor* GetPlayerIntroActor(int32 PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWMatchIntroActor">();
	}
	static class ATWMatchIntroActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWMatchIntroActor>();
	}
};
static_assert(alignof(ATWMatchIntroActor) == 0x000008, "Wrong alignment on ATWMatchIntroActor");
static_assert(sizeof(ATWMatchIntroActor) == 0x000330, "Wrong size on ATWMatchIntroActor");
static_assert(offsetof(ATWMatchIntroActor, MatchIntroRoot) == 0x000228, "Member 'ATWMatchIntroActor::MatchIntroRoot' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, Root_TeamA) == 0x000230, "Member 'ATWMatchIntroActor::Root_TeamA' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, Arrow_TeamA) == 0x000238, "Member 'ATWMatchIntroActor::Arrow_TeamA' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, Root_TeamB) == 0x000240, "Member 'ATWMatchIntroActor::Root_TeamB' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, Arrow_TeamB) == 0x000248, "Member 'ATWMatchIntroActor::Arrow_TeamB' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, IntroActors) == 0x000250, "Member 'ATWMatchIntroActor::IntroActors' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, AssetsCache) == 0x000268, "Member 'ATWMatchIntroActor::AssetsCache' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, NGDAk_MatchIntroMusic) == 0x000278, "Member 'ATWMatchIntroActor::NGDAk_MatchIntroMusic' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, SoundConfig_IntroMusicStart) == 0x000280, "Member 'ATWMatchIntroActor::SoundConfig_IntroMusicStart' has a wrong offset!");
static_assert(offsetof(ATWMatchIntroActor, SoundConfig_IntroMusicLastPlayerIntroStart) == 0x0002D8, "Member 'ATWMatchIntroActor::SoundConfig_IntroMusicLastPlayerIntroStart' has a wrong offset!");

// Class TimeWatch.SocialNotificationWidget
// 0x0008 (0x0288 - 0x0280)
class USocialNotificationWidget final : public UNGDUserWidget
{
public:
	class UTextBlock*                             TextBlock_Message;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialNotificationWidget">();
	}
	static class USocialNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialNotificationWidget>();
	}
};
static_assert(alignof(USocialNotificationWidget) == 0x000008, "Wrong alignment on USocialNotificationWidget");
static_assert(sizeof(USocialNotificationWidget) == 0x000288, "Wrong size on USocialNotificationWidget");
static_assert(offsetof(USocialNotificationWidget, TextBlock_Message) == 0x000280, "Member 'USocialNotificationWidget::TextBlock_Message' has a wrong offset!");

// Class TimeWatch.TeammateHealthBarStatus
// 0x00A0 (0x0320 - 0x0280)
class UTeammateHealthBarStatus : public UNGDUserWidget
{
public:
	class UTWLinearHealthBar*                     LinearHealthBar;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWRadialCloneInfo>         RadialCloneInfoClass;                              // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NextClonesColor;                                   // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_ClonesRadialInfo;                    // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Desync;                                       // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATimeWatchCharacter*                    ActiveCharacter;                                   // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextClonesWidth;                                   // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextClonesHeight;                                  // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ATimeWatchCharacter*, class UTWRadialCloneInfo*> ClonesRadialWidgets;                 // 0x02D0(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeammateHealthBarStatus">();
	}
	static class UTeammateHealthBarStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeammateHealthBarStatus>();
	}
};
static_assert(alignof(UTeammateHealthBarStatus) == 0x000008, "Wrong alignment on UTeammateHealthBarStatus");
static_assert(sizeof(UTeammateHealthBarStatus) == 0x000320, "Wrong size on UTeammateHealthBarStatus");
static_assert(offsetof(UTeammateHealthBarStatus, LinearHealthBar) == 0x000280, "Member 'UTeammateHealthBarStatus::LinearHealthBar' has a wrong offset!");
static_assert(offsetof(UTeammateHealthBarStatus, RadialCloneInfoClass) == 0x000288, "Member 'UTeammateHealthBarStatus::RadialCloneInfoClass' has a wrong offset!");
static_assert(offsetof(UTeammateHealthBarStatus, NextClonesColor) == 0x000290, "Member 'UTeammateHealthBarStatus::NextClonesColor' has a wrong offset!");
static_assert(offsetof(UTeammateHealthBarStatus, HorizontalBox_ClonesRadialInfo) == 0x0002A0, "Member 'UTeammateHealthBarStatus::HorizontalBox_ClonesRadialInfo' has a wrong offset!");
static_assert(offsetof(UTeammateHealthBarStatus, Text_Desync) == 0x0002A8, "Member 'UTeammateHealthBarStatus::Text_Desync' has a wrong offset!");
static_assert(offsetof(UTeammateHealthBarStatus, ActiveCharacter) == 0x0002B0, "Member 'UTeammateHealthBarStatus::ActiveCharacter' has a wrong offset!");
static_assert(offsetof(UTeammateHealthBarStatus, NextClonesWidth) == 0x0002B8, "Member 'UTeammateHealthBarStatus::NextClonesWidth' has a wrong offset!");
static_assert(offsetof(UTeammateHealthBarStatus, NextClonesHeight) == 0x0002BC, "Member 'UTeammateHealthBarStatus::NextClonesHeight' has a wrong offset!");
static_assert(offsetof(UTeammateHealthBarStatus, ClonesRadialWidgets) == 0x0002D0, "Member 'UTeammateHealthBarStatus::ClonesRadialWidgets' has a wrong offset!");

// Class TimeWatch.TemporalParticle
// 0x0020 (0x0238 - 0x0218)
class ATemporalParticle : public AActor
{
public:
	float                                         AnimationLength;                                   // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CreationTime;                                      // 0x021C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipDestruction;                                  // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOwnerSee;                                         // 0x0221(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyOwnerSee;                                     // 0x0222(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFirstPersonParticle;                            // 0x0223(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpawnerActor;                                      // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Disable();
	void OnParticleEnabled(bool NewState);
	void ParticleTick(float LifeCylcle);
	void SetOnlyOwnerSee(bool NewState);
	void SetOwnerSee(bool NewState);
	void Setup(class AActor* InSpawnerActor, float NewCreationTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TemporalParticle">();
	}
	static class ATemporalParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATemporalParticle>();
	}
};
static_assert(alignof(ATemporalParticle) == 0x000008, "Wrong alignment on ATemporalParticle");
static_assert(sizeof(ATemporalParticle) == 0x000238, "Wrong size on ATemporalParticle");
static_assert(offsetof(ATemporalParticle, AnimationLength) == 0x000218, "Member 'ATemporalParticle::AnimationLength' has a wrong offset!");
static_assert(offsetof(ATemporalParticle, CreationTime) == 0x00021C, "Member 'ATemporalParticle::CreationTime' has a wrong offset!");
static_assert(offsetof(ATemporalParticle, bSkipDestruction) == 0x000220, "Member 'ATemporalParticle::bSkipDestruction' has a wrong offset!");
static_assert(offsetof(ATemporalParticle, bOwnerSee) == 0x000221, "Member 'ATemporalParticle::bOwnerSee' has a wrong offset!");
static_assert(offsetof(ATemporalParticle, bOnlyOwnerSee) == 0x000222, "Member 'ATemporalParticle::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(ATemporalParticle, bIsFirstPersonParticle) == 0x000223, "Member 'ATemporalParticle::bIsFirstPersonParticle' has a wrong offset!");
static_assert(offsetof(ATemporalParticle, SpawnerActor) == 0x000228, "Member 'ATemporalParticle::SpawnerActor' has a wrong offset!");

// Class TimeWatch.TemporalProjectileBase
// 0x0020 (0x0238 - 0x0218)
class ATemporalProjectileBase final : public AActor
{
public:
	class ATimeWatchCharacter*                    ShootedBy;                                         // 0x0218(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WeaponTexture;                                     // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EWeaponType                                   WeaponType;                                        // 0x0230(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ShootedBy();
	void OnSetShooter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TemporalProjectileBase">();
	}
	static class ATemporalProjectileBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATemporalProjectileBase>();
	}
};
static_assert(alignof(ATemporalProjectileBase) == 0x000008, "Wrong alignment on ATemporalProjectileBase");
static_assert(sizeof(ATemporalProjectileBase) == 0x000238, "Wrong size on ATemporalProjectileBase");
static_assert(offsetof(ATemporalProjectileBase, ShootedBy) == 0x000218, "Member 'ATemporalProjectileBase::ShootedBy' has a wrong offset!");
static_assert(offsetof(ATemporalProjectileBase, WeaponTexture) == 0x000220, "Member 'ATemporalProjectileBase::WeaponTexture' has a wrong offset!");
static_assert(offsetof(ATemporalProjectileBase, WeaponType) == 0x000230, "Member 'ATemporalProjectileBase::WeaponType' has a wrong offset!");

// Class TimeWatch.TWDeathFeedRow
// 0x0088 (0x02B8 - 0x0230)
class UTWDeathFeedRow : public UUserWidget
{
public:
	class UHorizontalBox*                         HorizontalBox_KillEventBox;                        // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_PrimaryContainer;                            // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_SecondaryContainer;                          // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_InstigatorWeapon;                            // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_HeadshotFeedback;                            // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_KillPrefireBoostedFeedback;                  // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         HorizontalBox_ResyncBox;                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         HorizontalBox_ExplosionBox;                        // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_ExplosionBG;                                 // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_BaseContainer;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_HealthpackUsed;                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWRadialCloneInfo*                     Instigator_CloneInfoWidget;                        // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWRadialCloneInfo*                     Victim_CloneInfoWidget;                            // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_ActionTimestamp;                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Anim_ShowRow;                                      // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Anim_HideRow;                                      // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDisplayTime;                                    // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWDeathFeedRow">();
	}
	static class UTWDeathFeedRow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWDeathFeedRow>();
	}
};
static_assert(alignof(UTWDeathFeedRow) == 0x000008, "Wrong alignment on UTWDeathFeedRow");
static_assert(sizeof(UTWDeathFeedRow) == 0x0002B8, "Wrong size on UTWDeathFeedRow");
static_assert(offsetof(UTWDeathFeedRow, HorizontalBox_KillEventBox) == 0x000230, "Member 'UTWDeathFeedRow::HorizontalBox_KillEventBox' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Image_PrimaryContainer) == 0x000238, "Member 'UTWDeathFeedRow::Image_PrimaryContainer' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Image_SecondaryContainer) == 0x000240, "Member 'UTWDeathFeedRow::Image_SecondaryContainer' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Image_InstigatorWeapon) == 0x000248, "Member 'UTWDeathFeedRow::Image_InstigatorWeapon' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Image_HeadshotFeedback) == 0x000250, "Member 'UTWDeathFeedRow::Image_HeadshotFeedback' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Image_KillPrefireBoostedFeedback) == 0x000258, "Member 'UTWDeathFeedRow::Image_KillPrefireBoostedFeedback' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, HorizontalBox_ResyncBox) == 0x000260, "Member 'UTWDeathFeedRow::HorizontalBox_ResyncBox' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, HorizontalBox_ExplosionBox) == 0x000268, "Member 'UTWDeathFeedRow::HorizontalBox_ExplosionBox' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Image_ExplosionBG) == 0x000270, "Member 'UTWDeathFeedRow::Image_ExplosionBG' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Image_BaseContainer) == 0x000278, "Member 'UTWDeathFeedRow::Image_BaseContainer' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Image_HealthpackUsed) == 0x000280, "Member 'UTWDeathFeedRow::Image_HealthpackUsed' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Instigator_CloneInfoWidget) == 0x000288, "Member 'UTWDeathFeedRow::Instigator_CloneInfoWidget' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Victim_CloneInfoWidget) == 0x000290, "Member 'UTWDeathFeedRow::Victim_CloneInfoWidget' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, TextBlock_ActionTimestamp) == 0x000298, "Member 'UTWDeathFeedRow::TextBlock_ActionTimestamp' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Anim_ShowRow) == 0x0002A0, "Member 'UTWDeathFeedRow::Anim_ShowRow' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, Anim_HideRow) == 0x0002A8, "Member 'UTWDeathFeedRow::Anim_HideRow' has a wrong offset!");
static_assert(offsetof(UTWDeathFeedRow, MaxDisplayTime) == 0x0002B0, "Member 'UTWDeathFeedRow::MaxDisplayTime' has a wrong offset!");

// Class TimeWatch.TemporalWeaponSwitcher
// 0x0038 (0x0250 - 0x0218)
class ATemporalWeaponSwitcher final : public AActor
{
public:
	class UBoxComponent*                          PickUpArea;                                        // 0x0218(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WeaponIndex;                                       // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamId;                                            // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   WeaponName;                                        // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextRenderComponent*                   TextRenderComponent;                               // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void MakeAllVisible(class UObject* Context, bool bVisible);

	void MakeVisible(bool bVisible);
	void OnPickUpOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

	class USkeletalMeshComponent* GetWeaponMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TemporalWeaponSwitcher">();
	}
	static class ATemporalWeaponSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATemporalWeaponSwitcher>();
	}
};
static_assert(alignof(ATemporalWeaponSwitcher) == 0x000008, "Wrong alignment on ATemporalWeaponSwitcher");
static_assert(sizeof(ATemporalWeaponSwitcher) == 0x000250, "Wrong size on ATemporalWeaponSwitcher");
static_assert(offsetof(ATemporalWeaponSwitcher, PickUpArea) == 0x000218, "Member 'ATemporalWeaponSwitcher::PickUpArea' has a wrong offset!");
static_assert(offsetof(ATemporalWeaponSwitcher, WeaponMesh) == 0x000220, "Member 'ATemporalWeaponSwitcher::WeaponMesh' has a wrong offset!");
static_assert(offsetof(ATemporalWeaponSwitcher, WeaponIndex) == 0x000228, "Member 'ATemporalWeaponSwitcher::WeaponIndex' has a wrong offset!");
static_assert(offsetof(ATemporalWeaponSwitcher, TeamId) == 0x00022C, "Member 'ATemporalWeaponSwitcher::TeamId' has a wrong offset!");
static_assert(offsetof(ATemporalWeaponSwitcher, WeaponName) == 0x000230, "Member 'ATemporalWeaponSwitcher::WeaponName' has a wrong offset!");
static_assert(offsetof(ATemporalWeaponSwitcher, TextRenderComponent) == 0x000248, "Member 'ATemporalWeaponSwitcher::TextRenderComponent' has a wrong offset!");

// Class TimeWatch.TWMatchClockWidget
// 0x0050 (0x02D0 - 0x0280)
class UTWMatchClockWidget : public UNGDUserWidget
{
public:
	float                                         LowTimeSecondsThreshold;                           // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Image_TimeProgress;                                // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_LoopTime;                                // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_LoopTimeDecimals;                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CurrentClone;                            // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OutOfTimeColor;                                    // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWMatchClockWidget">();
	}
	static class UTWMatchClockWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWMatchClockWidget>();
	}
};
static_assert(alignof(UTWMatchClockWidget) == 0x000008, "Wrong alignment on UTWMatchClockWidget");
static_assert(sizeof(UTWMatchClockWidget) == 0x0002D0, "Wrong size on UTWMatchClockWidget");
static_assert(offsetof(UTWMatchClockWidget, LowTimeSecondsThreshold) == 0x000280, "Member 'UTWMatchClockWidget::LowTimeSecondsThreshold' has a wrong offset!");
static_assert(offsetof(UTWMatchClockWidget, Image_TimeProgress) == 0x000288, "Member 'UTWMatchClockWidget::Image_TimeProgress' has a wrong offset!");
static_assert(offsetof(UTWMatchClockWidget, TextBlock_LoopTime) == 0x000290, "Member 'UTWMatchClockWidget::TextBlock_LoopTime' has a wrong offset!");
static_assert(offsetof(UTWMatchClockWidget, TextBlock_LoopTimeDecimals) == 0x000298, "Member 'UTWMatchClockWidget::TextBlock_LoopTimeDecimals' has a wrong offset!");
static_assert(offsetof(UTWMatchClockWidget, TextBlock_CurrentClone) == 0x0002A0, "Member 'UTWMatchClockWidget::TextBlock_CurrentClone' has a wrong offset!");
static_assert(offsetof(UTWMatchClockWidget, OutOfTimeColor) == 0x0002A8, "Member 'UTWMatchClockWidget::OutOfTimeColor' has a wrong offset!");

// Class TimeWatch.TextChatChannel
// 0x0058 (0x0080 - 0x0028)
class UTextChatChannel final : public UObject
{
public:
	struct FTextChatChannelPostPolicyConfig       ChannelConfig;                                     // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class APlayerState*, struct FTextChatPlayerMessageHistory> MesagesHistory;                  // 0x0030(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextChatChannel">();
	}
	static class UTextChatChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextChatChannel>();
	}
};
static_assert(alignof(UTextChatChannel) == 0x000008, "Wrong alignment on UTextChatChannel");
static_assert(sizeof(UTextChatChannel) == 0x000080, "Wrong size on UTextChatChannel");
static_assert(offsetof(UTextChatChannel, ChannelConfig) == 0x000028, "Member 'UTextChatChannel::ChannelConfig' has a wrong offset!");
static_assert(offsetof(UTextChatChannel, MesagesHistory) == 0x000030, "Member 'UTextChatChannel::MesagesHistory' has a wrong offset!");

// Class TimeWatch.TextChat
// 0x0068 (0x0090 - 0x0028)
class UTextChat final : public UObject
{
public:
	struct FTextChatChannelPostPolicyConfig       AllChannelConfig;                                  // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTextChatChannelPostPolicyConfig       TeamChannelConfig;                                 // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<EChatChannel, class UTextChatChannel*>   Channels;                                          // 0x0038(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextChat">();
	}
	static class UTextChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextChat>();
	}
};
static_assert(alignof(UTextChat) == 0x000008, "Wrong alignment on UTextChat");
static_assert(sizeof(UTextChat) == 0x000090, "Wrong size on UTextChat");
static_assert(offsetof(UTextChat, AllChannelConfig) == 0x000028, "Member 'UTextChat::AllChannelConfig' has a wrong offset!");
static_assert(offsetof(UTextChat, TeamChannelConfig) == 0x000030, "Member 'UTextChat::TeamChannelConfig' has a wrong offset!");
static_assert(offsetof(UTextChat, Channels) == 0x000038, "Member 'UTextChat::Channels' has a wrong offset!");

// Class TimeWatch.TWOverheadHealthBarWidget
// 0x0100 (0x0380 - 0x0280)
class UTWOverheadHealthBarWidget : public UNGDUserWidget
{
public:
	struct FWidgetColorStructure                  HealthBarColors;                                   // 0x0280(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_CeldedTopBar;                          // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_CeldedFeedbackBar;                     // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CeldedBarBackground;                         // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_LinearTopBar;                          // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_LinearFeedbackBar;                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LinearBarBackground;                         // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CeldedHealthBarBaseMaterial;                       // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     LinearHealthBarBaseMaterial;                       // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeWidget(const struct FWidgetColorStructure& NewHealthBarColors);
	void SetActiveHealthBar(bool bIsPlayer);
	void SetHealthBarPercentValue(float Value);
	void SetHitFeedbackPercentValue(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWOverheadHealthBarWidget">();
	}
	static class UTWOverheadHealthBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWOverheadHealthBarWidget>();
	}
};
static_assert(alignof(UTWOverheadHealthBarWidget) == 0x000008, "Wrong alignment on UTWOverheadHealthBarWidget");
static_assert(sizeof(UTWOverheadHealthBarWidget) == 0x000380, "Wrong size on UTWOverheadHealthBarWidget");
static_assert(offsetof(UTWOverheadHealthBarWidget, HealthBarColors) == 0x000280, "Member 'UTWOverheadHealthBarWidget::HealthBarColors' has a wrong offset!");
static_assert(offsetof(UTWOverheadHealthBarWidget, ProgressBar_CeldedTopBar) == 0x000340, "Member 'UTWOverheadHealthBarWidget::ProgressBar_CeldedTopBar' has a wrong offset!");
static_assert(offsetof(UTWOverheadHealthBarWidget, ProgressBar_CeldedFeedbackBar) == 0x000348, "Member 'UTWOverheadHealthBarWidget::ProgressBar_CeldedFeedbackBar' has a wrong offset!");
static_assert(offsetof(UTWOverheadHealthBarWidget, Image_CeldedBarBackground) == 0x000350, "Member 'UTWOverheadHealthBarWidget::Image_CeldedBarBackground' has a wrong offset!");
static_assert(offsetof(UTWOverheadHealthBarWidget, ProgressBar_LinearTopBar) == 0x000358, "Member 'UTWOverheadHealthBarWidget::ProgressBar_LinearTopBar' has a wrong offset!");
static_assert(offsetof(UTWOverheadHealthBarWidget, ProgressBar_LinearFeedbackBar) == 0x000360, "Member 'UTWOverheadHealthBarWidget::ProgressBar_LinearFeedbackBar' has a wrong offset!");
static_assert(offsetof(UTWOverheadHealthBarWidget, Image_LinearBarBackground) == 0x000368, "Member 'UTWOverheadHealthBarWidget::Image_LinearBarBackground' has a wrong offset!");
static_assert(offsetof(UTWOverheadHealthBarWidget, CeldedHealthBarBaseMaterial) == 0x000370, "Member 'UTWOverheadHealthBarWidget::CeldedHealthBarBaseMaterial' has a wrong offset!");
static_assert(offsetof(UTWOverheadHealthBarWidget, LinearHealthBarBaseMaterial) == 0x000378, "Member 'UTWOverheadHealthBarWidget::LinearHealthBarBaseMaterial' has a wrong offset!");

// Class TimeWatch.TimeWatchCameraComponent
// 0x0000 (0x07F0 - 0x07F0)
class UTimeWatchCameraComponent final : public UNGDCameraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchCameraComponent">();
	}
	static class UTimeWatchCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeWatchCameraComponent>();
	}
};
static_assert(alignof(UTimeWatchCameraComponent) == 0x000010, "Wrong alignment on UTimeWatchCameraComponent");
static_assert(sizeof(UTimeWatchCameraComponent) == 0x0007F0, "Wrong size on UTimeWatchCameraComponent");

// Class TimeWatch.TimeWatchCharacter
// 0x06C0 (0x0FD0 - 0x0910)
class ATimeWatchCharacter : public ANGDCharacter
{
public:
	class UTWSkeletalMeshComponent*               Mesh1P;                                            // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MeshRagdoll;                                       // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWCharacterCustomizationComponent*     CustomizationComponent;                            // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWInteractionComponent*                TWInteractionComponent;                            // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFollowPoseableComponent*               ThirdPersonCosmeticWeapon;                         // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 WeaponMeshRagdoll;                                 // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWAbilitiesComponent*                  AbilitiesComponent;                                // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_948[0x10];                                     // 0x0948(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerInfo                            OwningPlayerInfo;                                  // 0x0958(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_964[0x4];                                      // 0x0964(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 ProjectileIndex, const struct FHitResult& ImpactData)> OnReceivedImpact; // 0x0968(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_978[0x8];                                      // 0x0978(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponSelectionComponent*              PlayerWeaponSelection;                             // 0x0980(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWPlayerInfoWidgetComponent*           PlayerInfoWidgetComponent;                         // 0x0988(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFiringContinously;                              // 0x0990(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWarmingUpWeapon;                                // 0x0991(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_992[0xE];                                      // 0x0992(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCompletedLoopAlive;                               // 0x09A0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EADSStates                                    ADSStatus;                                         // 0x09A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A2[0x2];                                      // 0x09A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                interpolatedVelocity;                              // 0x09A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloneControlled;                                  // 0x09B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B1[0x7];                                      // 0x09B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GamepadTurnRateCurve;                              // 0x09B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C0[0xC];                                      // 0x09C0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseTurnRate;                                      // 0x09CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x09D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D4[0x4];                                      // 0x09D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TeamCollisionProfiles;                             // 0x09D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   CollisionPresetNameCapsuleAlive;                   // 0x09E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionPresetNameCapsuleDead;                    // 0x09F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionPresetNameTPMeshAlive;                    // 0x09F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionPresetNameTPMeshDead;                     // 0x0A00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimeFrozen;                                       // 0x0A08(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A09[0x3];                                      // 0x0A09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LockedJumpCount;                                   // 0x0A0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CloneId;                                           // 0x0A10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathTime;                                         // 0x0A14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousLoopDeathTime;                             // 0x0A18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1C[0x4];                                      // 0x0A1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CurrentDeathTimes;                                 // 0x0A20(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 PreviousDeathTimes;                                // 0x0A30(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOverTimeDamageData>            OverTimeDamageReceived;                            // 0x0A40(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsResyncing;                                      // 0x0A50(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A51[0x7];                                      // 0x0A51(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastReloadTimestamp;                               // 0x0A58(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastWeaponSwapTimestamp;                           // 0x0A5C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnProtectionDuration;                           // 0x0A60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A64[0x4];                                      // 0x0A64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDSoundConfig                        SoundConfig_OnReceivedImpact;                      // 0x0A68(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnRespawn;                             // 0x0AC0(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnJump;                                // 0x0B18(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnDoubleJump;                          // 0x0B70(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnWeaponSwapStart;                     // 0x0BC8(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnWeaponSwapInterrupt;                 // 0x0C20(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_OnWeaponSwapEnd;                       // 0x0C78(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_ADSBegin;                              // 0x0CD0(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_ADSEnd;                                // 0x0D28(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        SoundConfig_ADSFull;                               // 0x0D80(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        NGDAk_PlayerMotion;                                // 0x0DD8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        NGDAk_PlayerGrunts;                                // 0x0DE0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        NGDAk_ADSChange;                                   // 0x0DE8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFluxTimelineCharacter*                 TimelineCharacter;                                 // 0x0DF0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF8[0x48];                                     // 0x0DF8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponChangeData                      WeaponChangeData;                                  // 0x0E40(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E58[0x20];                                     // 0x0E58(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATimeWatchCharacter* TWChar, class AFirearm* Firearm)> OnFirearmUsed; // 0x0E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ATimeWatchCharacter* DamageReceiver, class AActor* DamageInstigator)> OnDamageReceived; // 0x0E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ATimeWatchCharacter* Character, float NewHealth)> OnHealthRestored; // 0x0E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ATimeWatchCharacter* TWChar, class AFirearm* Firearm, float Progress)> SetAdsShowSightProgress; // 0x0EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ATimeWatchCharacter* TWChar, class AFirearm* Firearm, float Progress)> SetAdsHideSightProgress; // 0x0EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ATimeWatchCharacter* TWChar, class AFirearm* Firearm, bool ResetMesh)> OnAdsReset; // 0x0EC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         SprintMinVelocity;                                 // 0x0ED8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EDC[0x4];                                      // 0x0EDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATimeWatchCharacter* TWChar)> OnCloneStateChanged;           // 0x0EE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_EF0[0x15];                                     // 0x0EF0(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLockLocalWeaponInteraction;                       // 0x0F05(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockWeaponChange;                                 // 0x0F06(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExtraDamageToFutureClones;                        // 0x0F07(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoubleJumpCooldown;                                // 0x0F08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageReducedWhileSprinting;                      // 0x0F0C(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0D[0x3];                                      // 0x0F0D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageReductionWhileSprintingProgress;             // 0x0F10(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F14[0x4];                                      // 0x0F14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DamageReducedWhileSprintingMultiplierCurve;        // 0x0F18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSprintVelocityToReduceDamage;                   // 0x0F20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToFullDamageReductionWhileSprinting;           // 0x0F24(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToZeroDamageReductionWhileSprinting;           // 0x0F28(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPrimaryWeaponChange;                         // 0x0F2C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeMaxSpeedOnDesync;                           // 0x0F2D(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2E[0x2];                                      // 0x0F2E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesyncSpeedCosmeticIntensity;                      // 0x0F30(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F34[0x28];                                     // 0x0F34(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesyncMaxStandSpeed;                               // 0x0F5C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesyncMaxFastStandSpeed;                           // 0x0F60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesyncMaxCrouchSpeed;                              // 0x0F64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesyncMaxFastCrouchSpeed;                          // 0x0F68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesyncMaxSlideSpeed;                               // 0x0F6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesyncMaxStandAcceleration;                        // 0x0F70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesyncMaxCrouchAcceleration;                       // 0x0F74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesyncMaxSlideAcceleration;                        // 0x0F78(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesyncMaxHorizontalSpeed;                          // 0x0F7C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DesyncSlideLaunchVelocityScalar;                   // 0x0F80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSelectSecondaryWeapon;                       // 0x0F88(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F89[0x3];                                      // 0x0F89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SecondaryWeaponSlotIndex;                          // 0x0F8C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CrouchLerpCurve;                                   // 0x0F90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Standing_EyeHeigth;                                // 0x0F98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Crouching_EyeHeigth;                               // 0x0F9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA0[0x4];                                      // 0x0FA0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReviveTimeStamp;                                   // 0x0FA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathTimeStamp;                                    // 0x0FA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchOffsetZ;                                     // 0x0FAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchDuration;                                    // 0x0FB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeedbackBetweenOverTimeDamage;                     // 0x0FB4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB8[0x18];                                     // 0x0FB8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString ToPointer(class ATimeWatchCharacter* This);

	void ActivateAbility(TSubclassOf<class UTWAbility> Ability);
	void BP_ModifyHealth(class AActor* InteractedActor, float Value, bool bSet);
	void BP_OnCharacterDoubleJumpEvent();
	void BP_OnRespawnEnd();
	void BP_SetFiring(bool bNewState);
	void CheckADSEvents(const float& DeltaTime);
	void CheckAndSetWeaponGhostMaterial();
	void ClientOnDoubleJump();
	float GetLastDeathTime();
	class ATimeWatchCharacter* GetNextClone();
	void Multicast_OnTakeDamage(const struct FNGDDamageEvent& DamageEvent, class ANGDCharacter* EventInstigator, class AActor* DamageCauser);
	void Multicast_SetWeaponChangeData(const struct FWeaponChangeData& NewWeaponChangeData, bool bForceChangeData);
	void Multicast_WeaponChangeForwardEndSnapshot(const TArray<uint8>& WeaponChangeSnapshot);
	void OnAnimationBlueprintSet();
	void OnCharacterGrounded(float VerticalSpeed);
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnRespawn();
	void OnSavedFromPastDead(class UTimeWatchEvent* Event);
	void OnSprintEnabled(bool NewState);
	void OnTeamAssigned(int32 TeamId);
	void OnWeaponChanged(class ATemporalWeapon* NewWeapon);
	void OnWeaponChanged_Multicast();
	void OnWeaponDrawedCosmetics(class AWeapon* WeaponDrawed);
	void OnWeaponHolsteredCosmetics(class AWeapon* WeaponHolstered);
	void RagdollAttachment(bool bNewState, bool bSimulatePhysics);
	void ResetADS(bool bResetMesh);
	void SelectWeaponSlot(int32 WeaponSlotIndex, bool bForce);
	void Server_SetupWeaponChange(int32 PreviousWeaponSlotIndex);
	void SetCloneName();
	void SetCollisionResponseOnDeath(bool IsDead);
	void SetCrosshairClass(TSubclassOf<class UNGDCrosshairWidget> CrosshairWidgetClass);
	void SetHitDeathData(const struct FVector& Impuse, class FName BoneName);
	void SetIsResyncing(bool Val);
	void SetOverheadHUDOcclusion(bool bShouldBeOccluded);
	void SetOverheadVisibilityWhileDead(bool shouldBeVisible);
	bool ShouldShowCloneInfo();

	float BP_GetHealth() const;
	struct FVector GetActorPositionAtTime(float DesiredTimestamp, bool bShouldUseServerSamples) const;
	struct FRotator GetAimOffsets() const;
	class UNGDAkComponent* GetAkPlayerMotion() const;
	class UCameraComponent* GetCameraComponent() const;
	struct FVector GetCameraLocation() const;
	struct FVector GetCameraOffset() const;
	const class FString GetCharacterSKU() const;
	int32 GetCloneIndex() const;
	class UFollowPoseableComponent* GetCosmeticWeaponMesh() const;
	class ATemporalWeapon* GetCurrentlyVisibleCosmeticWeapon() const;
	class ATemporalWeapon* GetCurrentWeapon() const;
	class ATemporalWeapon* GetLastActiveWeapon() const;
	class USkeletalMeshComponent* GetMesh1P() const;
	class USkeletalMeshComponent* GetMeshRagdoll() const;
	struct FVector GetSavedVelocity() const;
	int32 GetTeamId() const;
	class UPrimitiveComponent* GetTPMeshOccluder() const;
	class USkeletalMeshComponent* GetWeaponMeshRagdoll() const;
	bool HasSpawnProtection() const;
	bool IsAlly() const;
	bool IsBlue() const;
	bool IsClone() const;
	bool IsDead() const;
	bool IsLocalTeam() const;
	bool IsPlayer() const;
	bool IsRespawning() const;
	bool IsResyncing() const;
	bool IsUnderResetConditions() const;
	bool UsedInLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchCharacter">();
	}
	static class ATimeWatchCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeWatchCharacter>();
	}
};
static_assert(alignof(ATimeWatchCharacter) == 0x000010, "Wrong alignment on ATimeWatchCharacter");
static_assert(sizeof(ATimeWatchCharacter) == 0x000FD0, "Wrong size on ATimeWatchCharacter");
static_assert(offsetof(ATimeWatchCharacter, Mesh1P) == 0x000910, "Member 'ATimeWatchCharacter::Mesh1P' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, MeshRagdoll) == 0x000918, "Member 'ATimeWatchCharacter::MeshRagdoll' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CustomizationComponent) == 0x000920, "Member 'ATimeWatchCharacter::CustomizationComponent' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, TWInteractionComponent) == 0x000928, "Member 'ATimeWatchCharacter::TWInteractionComponent' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, ThirdPersonCosmeticWeapon) == 0x000930, "Member 'ATimeWatchCharacter::ThirdPersonCosmeticWeapon' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, WeaponMeshRagdoll) == 0x000938, "Member 'ATimeWatchCharacter::WeaponMeshRagdoll' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, AbilitiesComponent) == 0x000940, "Member 'ATimeWatchCharacter::AbilitiesComponent' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, OwningPlayerInfo) == 0x000958, "Member 'ATimeWatchCharacter::OwningPlayerInfo' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, OnReceivedImpact) == 0x000968, "Member 'ATimeWatchCharacter::OnReceivedImpact' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, PlayerWeaponSelection) == 0x000980, "Member 'ATimeWatchCharacter::PlayerWeaponSelection' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, PlayerInfoWidgetComponent) == 0x000988, "Member 'ATimeWatchCharacter::PlayerInfoWidgetComponent' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bIsFiringContinously) == 0x000990, "Member 'ATimeWatchCharacter::bIsFiringContinously' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bIsWarmingUpWeapon) == 0x000991, "Member 'ATimeWatchCharacter::bIsWarmingUpWeapon' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bCompletedLoopAlive) == 0x0009A0, "Member 'ATimeWatchCharacter::bCompletedLoopAlive' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, ADSStatus) == 0x0009A1, "Member 'ATimeWatchCharacter::ADSStatus' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, interpolatedVelocity) == 0x0009A4, "Member 'ATimeWatchCharacter::interpolatedVelocity' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bCloneControlled) == 0x0009B0, "Member 'ATimeWatchCharacter::bCloneControlled' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, GamepadTurnRateCurve) == 0x0009B8, "Member 'ATimeWatchCharacter::GamepadTurnRateCurve' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, BaseTurnRate) == 0x0009CC, "Member 'ATimeWatchCharacter::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, BaseLookUpRate) == 0x0009D0, "Member 'ATimeWatchCharacter::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, TeamCollisionProfiles) == 0x0009D8, "Member 'ATimeWatchCharacter::TeamCollisionProfiles' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CollisionPresetNameCapsuleAlive) == 0x0009E8, "Member 'ATimeWatchCharacter::CollisionPresetNameCapsuleAlive' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CollisionPresetNameCapsuleDead) == 0x0009F0, "Member 'ATimeWatchCharacter::CollisionPresetNameCapsuleDead' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CollisionPresetNameTPMeshAlive) == 0x0009F8, "Member 'ATimeWatchCharacter::CollisionPresetNameTPMeshAlive' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CollisionPresetNameTPMeshDead) == 0x000A00, "Member 'ATimeWatchCharacter::CollisionPresetNameTPMeshDead' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bTimeFrozen) == 0x000A08, "Member 'ATimeWatchCharacter::bTimeFrozen' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, LockedJumpCount) == 0x000A0C, "Member 'ATimeWatchCharacter::LockedJumpCount' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CloneId) == 0x000A10, "Member 'ATimeWatchCharacter::CloneId' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DeathTime) == 0x000A14, "Member 'ATimeWatchCharacter::DeathTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, PreviousLoopDeathTime) == 0x000A18, "Member 'ATimeWatchCharacter::PreviousLoopDeathTime' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CurrentDeathTimes) == 0x000A20, "Member 'ATimeWatchCharacter::CurrentDeathTimes' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, PreviousDeathTimes) == 0x000A30, "Member 'ATimeWatchCharacter::PreviousDeathTimes' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, OverTimeDamageReceived) == 0x000A40, "Member 'ATimeWatchCharacter::OverTimeDamageReceived' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bIsResyncing) == 0x000A50, "Member 'ATimeWatchCharacter::bIsResyncing' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, LastReloadTimestamp) == 0x000A58, "Member 'ATimeWatchCharacter::LastReloadTimestamp' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, LastWeaponSwapTimestamp) == 0x000A5C, "Member 'ATimeWatchCharacter::LastWeaponSwapTimestamp' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SpawnProtectionDuration) == 0x000A60, "Member 'ATimeWatchCharacter::SpawnProtectionDuration' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_OnReceivedImpact) == 0x000A68, "Member 'ATimeWatchCharacter::SoundConfig_OnReceivedImpact' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_OnRespawn) == 0x000AC0, "Member 'ATimeWatchCharacter::SoundConfig_OnRespawn' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_OnJump) == 0x000B18, "Member 'ATimeWatchCharacter::SoundConfig_OnJump' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_OnDoubleJump) == 0x000B70, "Member 'ATimeWatchCharacter::SoundConfig_OnDoubleJump' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_OnWeaponSwapStart) == 0x000BC8, "Member 'ATimeWatchCharacter::SoundConfig_OnWeaponSwapStart' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_OnWeaponSwapInterrupt) == 0x000C20, "Member 'ATimeWatchCharacter::SoundConfig_OnWeaponSwapInterrupt' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_OnWeaponSwapEnd) == 0x000C78, "Member 'ATimeWatchCharacter::SoundConfig_OnWeaponSwapEnd' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_ADSBegin) == 0x000CD0, "Member 'ATimeWatchCharacter::SoundConfig_ADSBegin' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_ADSEnd) == 0x000D28, "Member 'ATimeWatchCharacter::SoundConfig_ADSEnd' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SoundConfig_ADSFull) == 0x000D80, "Member 'ATimeWatchCharacter::SoundConfig_ADSFull' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, NGDAk_PlayerMotion) == 0x000DD8, "Member 'ATimeWatchCharacter::NGDAk_PlayerMotion' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, NGDAk_PlayerGrunts) == 0x000DE0, "Member 'ATimeWatchCharacter::NGDAk_PlayerGrunts' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, NGDAk_ADSChange) == 0x000DE8, "Member 'ATimeWatchCharacter::NGDAk_ADSChange' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, TimelineCharacter) == 0x000DF0, "Member 'ATimeWatchCharacter::TimelineCharacter' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, WeaponChangeData) == 0x000E40, "Member 'ATimeWatchCharacter::WeaponChangeData' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, OnFirearmUsed) == 0x000E78, "Member 'ATimeWatchCharacter::OnFirearmUsed' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, OnDamageReceived) == 0x000E88, "Member 'ATimeWatchCharacter::OnDamageReceived' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, OnHealthRestored) == 0x000E98, "Member 'ATimeWatchCharacter::OnHealthRestored' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SetAdsShowSightProgress) == 0x000EA8, "Member 'ATimeWatchCharacter::SetAdsShowSightProgress' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SetAdsHideSightProgress) == 0x000EB8, "Member 'ATimeWatchCharacter::SetAdsHideSightProgress' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, OnAdsReset) == 0x000EC8, "Member 'ATimeWatchCharacter::OnAdsReset' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SprintMinVelocity) == 0x000ED8, "Member 'ATimeWatchCharacter::SprintMinVelocity' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, OnCloneStateChanged) == 0x000EE0, "Member 'ATimeWatchCharacter::OnCloneStateChanged' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bLockLocalWeaponInteraction) == 0x000F05, "Member 'ATimeWatchCharacter::bLockLocalWeaponInteraction' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bLockWeaponChange) == 0x000F06, "Member 'ATimeWatchCharacter::bLockWeaponChange' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bExtraDamageToFutureClones) == 0x000F07, "Member 'ATimeWatchCharacter::bExtraDamageToFutureClones' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DoubleJumpCooldown) == 0x000F08, "Member 'ATimeWatchCharacter::DoubleJumpCooldown' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bDamageReducedWhileSprinting) == 0x000F0C, "Member 'ATimeWatchCharacter::bDamageReducedWhileSprinting' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DamageReductionWhileSprintingProgress) == 0x000F10, "Member 'ATimeWatchCharacter::DamageReductionWhileSprintingProgress' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DamageReducedWhileSprintingMultiplierCurve) == 0x000F18, "Member 'ATimeWatchCharacter::DamageReducedWhileSprintingMultiplierCurve' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, MinSprintVelocityToReduceDamage) == 0x000F20, "Member 'ATimeWatchCharacter::MinSprintVelocityToReduceDamage' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, TimeToFullDamageReductionWhileSprinting) == 0x000F24, "Member 'ATimeWatchCharacter::TimeToFullDamageReductionWhileSprinting' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, TimeToZeroDamageReductionWhileSprinting) == 0x000F28, "Member 'ATimeWatchCharacter::TimeToZeroDamageReductionWhileSprinting' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bAllowPrimaryWeaponChange) == 0x000F2C, "Member 'ATimeWatchCharacter::bAllowPrimaryWeaponChange' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bChangeMaxSpeedOnDesync) == 0x000F2D, "Member 'ATimeWatchCharacter::bChangeMaxSpeedOnDesync' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncSpeedCosmeticIntensity) == 0x000F30, "Member 'ATimeWatchCharacter::DesyncSpeedCosmeticIntensity' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxStandSpeed) == 0x000F5C, "Member 'ATimeWatchCharacter::DesyncMaxStandSpeed' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxFastStandSpeed) == 0x000F60, "Member 'ATimeWatchCharacter::DesyncMaxFastStandSpeed' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxCrouchSpeed) == 0x000F64, "Member 'ATimeWatchCharacter::DesyncMaxCrouchSpeed' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxFastCrouchSpeed) == 0x000F68, "Member 'ATimeWatchCharacter::DesyncMaxFastCrouchSpeed' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxSlideSpeed) == 0x000F6C, "Member 'ATimeWatchCharacter::DesyncMaxSlideSpeed' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxStandAcceleration) == 0x000F70, "Member 'ATimeWatchCharacter::DesyncMaxStandAcceleration' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxCrouchAcceleration) == 0x000F74, "Member 'ATimeWatchCharacter::DesyncMaxCrouchAcceleration' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxSlideAcceleration) == 0x000F78, "Member 'ATimeWatchCharacter::DesyncMaxSlideAcceleration' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncMaxHorizontalSpeed) == 0x000F7C, "Member 'ATimeWatchCharacter::DesyncMaxHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DesyncSlideLaunchVelocityScalar) == 0x000F80, "Member 'ATimeWatchCharacter::DesyncSlideLaunchVelocityScalar' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, bAllowSelectSecondaryWeapon) == 0x000F88, "Member 'ATimeWatchCharacter::bAllowSelectSecondaryWeapon' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, SecondaryWeaponSlotIndex) == 0x000F8C, "Member 'ATimeWatchCharacter::SecondaryWeaponSlotIndex' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CrouchLerpCurve) == 0x000F90, "Member 'ATimeWatchCharacter::CrouchLerpCurve' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, Standing_EyeHeigth) == 0x000F98, "Member 'ATimeWatchCharacter::Standing_EyeHeigth' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, Crouching_EyeHeigth) == 0x000F9C, "Member 'ATimeWatchCharacter::Crouching_EyeHeigth' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, ReviveTimeStamp) == 0x000FA4, "Member 'ATimeWatchCharacter::ReviveTimeStamp' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, DeathTimeStamp) == 0x000FA8, "Member 'ATimeWatchCharacter::DeathTimeStamp' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CrouchOffsetZ) == 0x000FAC, "Member 'ATimeWatchCharacter::CrouchOffsetZ' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, CrouchDuration) == 0x000FB0, "Member 'ATimeWatchCharacter::CrouchDuration' has a wrong offset!");
static_assert(offsetof(ATimeWatchCharacter, FeedbackBetweenOverTimeDamage) == 0x000FB4, "Member 'ATimeWatchCharacter::FeedbackBetweenOverTimeDamage' has a wrong offset!");

// Class TimeWatch.TWModeSelectionSlot
// 0x01D0 (0x0450 - 0x0280)
class UTWModeSelectionSlot : public UNGDUserWidget
{
public:
	uint8                                         Pad_280[0x40];                                     // 0x0280(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasModeBackground;                                // 0x02C0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasModeTileImage;                                 // 0x02C1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasModeIcon;                                      // 0x02C2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplaysPrice;                                    // 0x02C3(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplaysCoinIconInTitle;                          // 0x02C4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C5[0x3];                                      // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TitleCoinIconScaleX;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TitleCoinIconScaleY;                               // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconScaleX;                                        // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconScaleY;                                        // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisabledButtonOpacity;                             // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Texture_HoveredModeBackground;                     // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Texture_UnhoveredModeBackground;                   // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Texture_DisabledModeBackground;                    // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BackgroundGradient;                                // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Texture_TileImage;                                 // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Texture_ModeIcon;                                  // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ModeTitle;                                         // 0x0310(0x0018)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class FText                                   ModeDescription;                                   // 0x0328(0x0018)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class FText                                   BonusDescription;                                  // 0x0340(0x0018)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         TitleFontSize;                                     // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DescriptionFontSize;                               // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PriceFontSize;                                     // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ValueText;                                         // 0x0368(0x0018)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          bDescriptionSpacersCollapsed;                      // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PriceSpacerSize;                                   // 0x0384(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Image_HoveredModeBackground;                       // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_UnhoveredModeBackground;                     // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_DisabledModeBackground;                      // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ModeTile;                                    // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ModeIcon;                                    // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_News;                                        // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_Info;                                // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_InfoIcon;                                    // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CoinIcon;                                    // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CoinIcon_InTitle;                            // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Title;                                        // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Quarks_Bonus_Description;                          // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_InfoDescription;                              // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                UpperDescriptionSpacer;                            // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                BottomDescriptionSpacer;                           // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                PriceSpacer;                                       // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_Selection;                                  // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox_Icon;                                      // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Expand;                                            // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Value;                                        // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTagWidget*                           Tag_F2PInfo;                                       // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StringID;                                          // 0x0440(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_AdjustItemTileImage(const bool bIsSmall, const bool bIsWeapon);
	class FString GetButtonID();
	void OnButtonClicked();
	void OnButtonHovered();
	void OnButtonRightClicked();
	void OnButtonUnhovered();

	class UButton* GetButton() const;
	class UTWStandardButtonWidget* GetStandardButton() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWModeSelectionSlot">();
	}
	static class UTWModeSelectionSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWModeSelectionSlot>();
	}
};
static_assert(alignof(UTWModeSelectionSlot) == 0x000008, "Wrong alignment on UTWModeSelectionSlot");
static_assert(sizeof(UTWModeSelectionSlot) == 0x000450, "Wrong size on UTWModeSelectionSlot");
static_assert(offsetof(UTWModeSelectionSlot, bHasModeBackground) == 0x0002C0, "Member 'UTWModeSelectionSlot::bHasModeBackground' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, bHasModeTileImage) == 0x0002C1, "Member 'UTWModeSelectionSlot::bHasModeTileImage' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, bHasModeIcon) == 0x0002C2, "Member 'UTWModeSelectionSlot::bHasModeIcon' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, bDisplaysPrice) == 0x0002C3, "Member 'UTWModeSelectionSlot::bDisplaysPrice' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, bDisplaysCoinIconInTitle) == 0x0002C4, "Member 'UTWModeSelectionSlot::bDisplaysCoinIconInTitle' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, TitleCoinIconScaleX) == 0x0002C8, "Member 'UTWModeSelectionSlot::TitleCoinIconScaleX' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, TitleCoinIconScaleY) == 0x0002CC, "Member 'UTWModeSelectionSlot::TitleCoinIconScaleY' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, IconScaleX) == 0x0002D0, "Member 'UTWModeSelectionSlot::IconScaleX' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, IconScaleY) == 0x0002D4, "Member 'UTWModeSelectionSlot::IconScaleY' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, DisabledButtonOpacity) == 0x0002D8, "Member 'UTWModeSelectionSlot::DisabledButtonOpacity' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Texture_HoveredModeBackground) == 0x0002E0, "Member 'UTWModeSelectionSlot::Texture_HoveredModeBackground' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Texture_UnhoveredModeBackground) == 0x0002E8, "Member 'UTWModeSelectionSlot::Texture_UnhoveredModeBackground' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Texture_DisabledModeBackground) == 0x0002F0, "Member 'UTWModeSelectionSlot::Texture_DisabledModeBackground' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, BackgroundGradient) == 0x0002F8, "Member 'UTWModeSelectionSlot::BackgroundGradient' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Texture_TileImage) == 0x000300, "Member 'UTWModeSelectionSlot::Texture_TileImage' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Texture_ModeIcon) == 0x000308, "Member 'UTWModeSelectionSlot::Texture_ModeIcon' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, ModeTitle) == 0x000310, "Member 'UTWModeSelectionSlot::ModeTitle' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, ModeDescription) == 0x000328, "Member 'UTWModeSelectionSlot::ModeDescription' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, BonusDescription) == 0x000340, "Member 'UTWModeSelectionSlot::BonusDescription' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, TitleFontSize) == 0x000358, "Member 'UTWModeSelectionSlot::TitleFontSize' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, DescriptionFontSize) == 0x00035C, "Member 'UTWModeSelectionSlot::DescriptionFontSize' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, PriceFontSize) == 0x000360, "Member 'UTWModeSelectionSlot::PriceFontSize' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, ValueText) == 0x000368, "Member 'UTWModeSelectionSlot::ValueText' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, bDescriptionSpacersCollapsed) == 0x000380, "Member 'UTWModeSelectionSlot::bDescriptionSpacersCollapsed' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, PriceSpacerSize) == 0x000384, "Member 'UTWModeSelectionSlot::PriceSpacerSize' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_HoveredModeBackground) == 0x000390, "Member 'UTWModeSelectionSlot::Image_HoveredModeBackground' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_UnhoveredModeBackground) == 0x000398, "Member 'UTWModeSelectionSlot::Image_UnhoveredModeBackground' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_DisabledModeBackground) == 0x0003A0, "Member 'UTWModeSelectionSlot::Image_DisabledModeBackground' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_ModeTile) == 0x0003A8, "Member 'UTWModeSelectionSlot::Image_ModeTile' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_ModeIcon) == 0x0003B0, "Member 'UTWModeSelectionSlot::Image_ModeIcon' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_News) == 0x0003B8, "Member 'UTWModeSelectionSlot::Image_News' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, HorizontalBox_Info) == 0x0003C0, "Member 'UTWModeSelectionSlot::HorizontalBox_Info' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_InfoIcon) == 0x0003C8, "Member 'UTWModeSelectionSlot::Image_InfoIcon' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_CoinIcon) == 0x0003D0, "Member 'UTWModeSelectionSlot::Image_CoinIcon' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Image_CoinIcon_InTitle) == 0x0003D8, "Member 'UTWModeSelectionSlot::Image_CoinIcon_InTitle' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Text_Title) == 0x0003E0, "Member 'UTWModeSelectionSlot::Text_Title' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Text_Description) == 0x0003E8, "Member 'UTWModeSelectionSlot::Text_Description' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Quarks_Bonus_Description) == 0x0003F0, "Member 'UTWModeSelectionSlot::Quarks_Bonus_Description' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Text_InfoDescription) == 0x0003F8, "Member 'UTWModeSelectionSlot::Text_InfoDescription' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, UpperDescriptionSpacer) == 0x000400, "Member 'UTWModeSelectionSlot::UpperDescriptionSpacer' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, BottomDescriptionSpacer) == 0x000408, "Member 'UTWModeSelectionSlot::BottomDescriptionSpacer' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, PriceSpacer) == 0x000410, "Member 'UTWModeSelectionSlot::PriceSpacer' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Button_Selection) == 0x000418, "Member 'UTWModeSelectionSlot::Button_Selection' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, SizeBox_Icon) == 0x000420, "Member 'UTWModeSelectionSlot::SizeBox_Icon' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Expand) == 0x000428, "Member 'UTWModeSelectionSlot::Expand' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Text_Value) == 0x000430, "Member 'UTWModeSelectionSlot::Text_Value' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, Tag_F2PInfo) == 0x000438, "Member 'UTWModeSelectionSlot::Tag_F2PInfo' has a wrong offset!");
static_assert(offsetof(UTWModeSelectionSlot, StringID) == 0x000440, "Member 'UTWModeSelectionSlot::StringID' has a wrong offset!");

// Class TimeWatch.TimeWatchFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTimeWatchFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BP_RerunConstructionScripts(class AActor* InActor);
	static void BP_TakeDamage(class AActor* ActorToDamage, float Damage, const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	static class FText GetActionKeyFriendlyName(class APlayerController* Player, const class FName& ActionName, int32 MappingGroup, const struct FGameplayTag& KeyGroup, bool bUsePlayerKeyGroup);
	static TSubclassOf<class AActor> GetActorClass(class UClass* Class_0);
	static struct FTransform GetActorTransformFromHitResult(const struct FHitResult& HitResult, const struct FVector& Offset, float DeltaYaw);
	static float GetAnimMontageLength(class UAnimMontage* AnimMontage, class FName SectionName);
	static float GetAnimMontagePosition(class UAnimInstance* AnimInstance, class UAnimMontage* AnimMontage, class FName SectionName);
	static class FText GetAxisKeyFriendlyName(class APlayerController* Player, const class FName& AxisName, float Scale, int32 MappingGroup, const struct FGameplayTag& KeyGroup, bool bUsePlayerKeyGroup);
	static struct FLinearColor GetColorForClone(const struct FTeamColorConfig& TeamColorRef, class ATimeWatchCharacter* TWCharAsContext);
	static struct FLinearColor GetColorForTeam(const struct FTeamColorConfig& TeamColorRef, class UObject* Context, int32 TeamIndex);
	static class FString GetControllerTypeName(class ACharacter* Character);
	static float GetCosmeticLoopRemainingTime(class UObject* InContext);
	static float GetCosmeticRemainingRelativeTime(class UObject* InContext);
	static struct FWidgetColorStructure GetCurrentColorSchemeFromCharacter(class ATimeWatchCharacter* InCharacter, class UObject* Context);
	static struct FWidgetColorStructure GetCurrentColorSchemeFromController(class AFluxPlayerController* InPlayerController, class UObject* Context);
	static struct FWidgetColorStructure GetCurrentColorSchemeFromID(int32 TeamId, class UObject* Context);
	static struct FGameModeData GetCurrentGameModeData(class UObject* Context);
	static EGameModeType GetCurrentGameModeType(class UObject* Context);
	static class ATimeWatchCharacter* GetCurrentViewTargetAsCharacter(class UObject* InContext);
	static void GetDebugPlayerIntros(class UObject* C, TArray<TSoftClassPtr<class UClass>>* Soft_IntroClasses, TArray<int32>* CharIndexes);
	static int32 GetDesiredColorIndexByIDs(class UObject* Context, int32 TeamIndex, int32 PlayerIndex);
	static class FText GetFloatAsTextWithPrecision(float FloatValue, int32 Precision, bool IncludeLeadingZero);
	static class UTimeWatchGameInstance* GetGameInstance(class UObject* InContext);
	static TArray<class FString> GetGameMaps();
	static class FString GetGameVersionString();
	static struct FLinearColor GetLocalColor(const struct FTeamColorConfig& TeamColorRef, class UObject* Context);
	static int32 GetLocalPlayerId(class UObject* Context);
	static int32 GetLocalTeamId(class UObject* Context);
	static TArray<class FString> GetMapsFromFolder(const class FString& FolderName);
	static void GetPlayerIntroBindings(class ULevelSequencePlayer* InPlayer, const class FString& TrackSubString, TArray<struct FMovieSceneObjectBindingID>* OutBinding);
	static float GetRandomValue(int32 Seed, int32 X, int32 Y, int32 Z);
	static struct FLinearColor GetRemoteColor(const struct FTeamColorConfig& TeamColorRef, class UObject* Context);
	static struct FRotator GetSnapRotationFromNormal(const struct FVector& Normal);
	static TArray<class FString> GetTutorialMaps();
	static bool HasAbility(class UObject* InContext, const class FString& CharacterSKU, const class FString& AbilityIdentifier);
	static bool HasPassiveAbility(class UObject* InContext, const class FString& CharacterSKU, const class FString& AbilityIdentifier);
	static bool IsExpoMode(class UObject* InContext);
	static bool IsPrimitiveOccluded(class UPrimitiveComponent* Prim);
	static bool IsUsingFixedTeamColors(const class UObject* InContext);
	static struct FTWGameplayTargetDataFilterHandle MakeFilterHandle(const struct FTWGameplayTargetDataFilter& Filter, class AActor* FilterActor);
	static void SetAnimMontagePosition(class UAnimInstance* AnimInstance, class UAnimMontage* AnimMontage, const float& NewPosition);
	static void SetLightingChannels(class UPrimitiveComponent* Prim, const struct FLightingChannels& NewLigthChannels);
	static class AActor* SpawnActor(class AActor* Owner, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, TSubclassOf<class AActor> Class_0);
	static void TraceToLog(class UObject* Context, const class FString& Text);
	static void UpdateUE4GlobalSoundVolume(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchFunctionLibrary">();
	}
	static class UTimeWatchFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeWatchFunctionLibrary>();
	}
};
static_assert(alignof(UTimeWatchFunctionLibrary) == 0x000008, "Wrong alignment on UTimeWatchFunctionLibrary");
static_assert(sizeof(UTimeWatchFunctionLibrary) == 0x000028, "Wrong size on UTimeWatchFunctionLibrary");

// Class TimeWatch.TimeWatchGameInstance
// 0x0260 (0x0480 - 0x0220)
class UTimeWatchGameInstance : public UNGDGameInstance
{
public:
	uint8                                         Pad_220[0xEA];                                     // 0x0220(0x00EA)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsOnReplay;                                       // 0x030A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B[0x1D];                                     // 0x030B(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextChat*                              ChatManager;                                       // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNGDPopupHUDState>          RewardPopupHUDStateClass;                          // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FNGDBackendReward>              PendingRewards;                                    // 0x0338(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTextChat>                  TextChatClass;                                     // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchDescriptor                       ServerMatchDescriptor;                             // 0x0350(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class FString                                 LocalServerURL;                                    // 0x03A0(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DoublesLocalServerURL;                             // 0x03B0(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExpoMode;                                       // 0x03C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExpoSpectator;                                  // 0x03C1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C2[0x2];                                      // 0x03C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExpoExpectedSpectators;                            // 0x03C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExpoResetSettingsAfterMatch;                      // 0x03C8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExpoQuickCustomization;                           // 0x03C9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExpoAllowSkipReview;                              // 0x03CA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CB[0x1];                                      // 0x03CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExpoLoopLength;                                    // 0x03CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoDoublesLoopLength;                             // 0x03D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExpoAutoCloseDelay;                                // 0x03D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoVideoVolume;                                   // 0x03D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoLevelIndex;                                    // 0x03DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoScoreLimit;                                    // 0x03E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoTeamID;                                        // 0x03E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoTeamIDForDoubles;                              // 0x03E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoShowWishlist;                                  // 0x03EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoGraphicOptionsLocked;                          // 0x03F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoShowNDA;                                       // 0x03F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExpoDoubles;                                      // 0x03F8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExpoTitle;                                         // 0x0400(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ExpoDoublesLevelName;                              // 0x0410(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingFixedTeamColor;                              // 0x0420(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExpoFixedTeamColorsOverride;                       // 0x0424(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWGlobals>                 GlobalsClass;                                      // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DoublesDefaultLevelName;                           // 0x0430(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTestEnvironment;                                  // 0x0440(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOfflineMode;                                      // 0x0441(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_442[0x2];                                      // 0x0442(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplayStartTimeSeconds;                            // 0x0444(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LastReplayMapName;                                 // 0x0448(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpoVideoPlaylistIndex;                            // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45C[0xC];                                      // 0x045C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDGoogleAnalyticsSession*             AnalyticsSession;                                  // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerPreferences*                   PlayerPreferences;                                 // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelMatchMaking();
	void ChromaRefreshKeysColors();
	void DiscordStatus_MainMenu();
	void DiscordStatus_PlayingGame(const class FString& MapName);
	void DumpLevelEntryData();
	void GameSessionPlacementTest(const class FString& PlacementId);
	class ATWOnlineBeaconClient* GetTWBeaconClient();
	void OnChallengeCompletedBackendResponse(bool bWasSuccessful, const class FString& Error, const struct FNGDBackendReceivedRewards& RewardData);
	void OnReplayStarted(class UDemoNetDriver* DemoNetDriver);
	void PlayLevel(TSubclassOf<class UTWLevelEntry> LevelEntry);
	void PushExpoDoublesCheatKey(const struct FKey& KeyPressed);
	void RequestGameConfigFromBackend();
	void ResetInputBindings();
	void ShowDoublesPopup();
	void TestCrashGame();
	void TestQueues();
	void UpdateDiscordStatus(const class FString& State, const class FString& details, bool StartTimer);
	void WipePlayerPreferences();

	bool ArePlayerTitlesEnabled() const;
	int32 GetExpoExpectedSpectators() const;
	bool GetExpoGraphicOptionsLocked() const;
	class FString GetExpoTitle() const;
	int32 GetExpoVideoVolume() const;
	class UTWGameGlobals* GetGameGlobals() const;
	class UTWGlobals* GetGlobals() const;
	class UTWStoreGlobals* GetStoreGlobals() const;
	bool IsCurrentLevelChallenge() const;
	bool IsExpoDoubles() const;
	bool IsExpoMode() const;
	bool IsExpoSpectator() const;
	bool IsGameHUDStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchGameInstance">();
	}
	static class UTimeWatchGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeWatchGameInstance>();
	}
};
static_assert(alignof(UTimeWatchGameInstance) == 0x000008, "Wrong alignment on UTimeWatchGameInstance");
static_assert(sizeof(UTimeWatchGameInstance) == 0x000480, "Wrong size on UTimeWatchGameInstance");
static_assert(offsetof(UTimeWatchGameInstance, bIsOnReplay) == 0x00030A, "Member 'UTimeWatchGameInstance::bIsOnReplay' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ChatManager) == 0x000328, "Member 'UTimeWatchGameInstance::ChatManager' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, RewardPopupHUDStateClass) == 0x000330, "Member 'UTimeWatchGameInstance::RewardPopupHUDStateClass' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, PendingRewards) == 0x000338, "Member 'UTimeWatchGameInstance::PendingRewards' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, TextChatClass) == 0x000348, "Member 'UTimeWatchGameInstance::TextChatClass' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ServerMatchDescriptor) == 0x000350, "Member 'UTimeWatchGameInstance::ServerMatchDescriptor' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, LocalServerURL) == 0x0003A0, "Member 'UTimeWatchGameInstance::LocalServerURL' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, DoublesLocalServerURL) == 0x0003B0, "Member 'UTimeWatchGameInstance::DoublesLocalServerURL' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bIsExpoMode) == 0x0003C0, "Member 'UTimeWatchGameInstance::bIsExpoMode' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bIsExpoSpectator) == 0x0003C1, "Member 'UTimeWatchGameInstance::bIsExpoSpectator' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoExpectedSpectators) == 0x0003C4, "Member 'UTimeWatchGameInstance::ExpoExpectedSpectators' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bExpoResetSettingsAfterMatch) == 0x0003C8, "Member 'UTimeWatchGameInstance::bExpoResetSettingsAfterMatch' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bExpoQuickCustomization) == 0x0003C9, "Member 'UTimeWatchGameInstance::bExpoQuickCustomization' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bExpoAllowSkipReview) == 0x0003CA, "Member 'UTimeWatchGameInstance::bExpoAllowSkipReview' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoLoopLength) == 0x0003CC, "Member 'UTimeWatchGameInstance::ExpoLoopLength' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoDoublesLoopLength) == 0x0003D0, "Member 'UTimeWatchGameInstance::ExpoDoublesLoopLength' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoAutoCloseDelay) == 0x0003D4, "Member 'UTimeWatchGameInstance::ExpoAutoCloseDelay' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoVideoVolume) == 0x0003D8, "Member 'UTimeWatchGameInstance::ExpoVideoVolume' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoLevelIndex) == 0x0003DC, "Member 'UTimeWatchGameInstance::ExpoLevelIndex' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoScoreLimit) == 0x0003E0, "Member 'UTimeWatchGameInstance::ExpoScoreLimit' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoTeamID) == 0x0003E4, "Member 'UTimeWatchGameInstance::ExpoTeamID' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoTeamIDForDoubles) == 0x0003E8, "Member 'UTimeWatchGameInstance::ExpoTeamIDForDoubles' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoShowWishlist) == 0x0003EC, "Member 'UTimeWatchGameInstance::ExpoShowWishlist' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoGraphicOptionsLocked) == 0x0003F0, "Member 'UTimeWatchGameInstance::ExpoGraphicOptionsLocked' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoShowNDA) == 0x0003F4, "Member 'UTimeWatchGameInstance::ExpoShowNDA' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bExpoDoubles) == 0x0003F8, "Member 'UTimeWatchGameInstance::bExpoDoubles' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoTitle) == 0x000400, "Member 'UTimeWatchGameInstance::ExpoTitle' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoDoublesLevelName) == 0x000410, "Member 'UTimeWatchGameInstance::ExpoDoublesLevelName' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bUsingFixedTeamColor) == 0x000420, "Member 'UTimeWatchGameInstance::bUsingFixedTeamColor' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoFixedTeamColorsOverride) == 0x000424, "Member 'UTimeWatchGameInstance::ExpoFixedTeamColorsOverride' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, GlobalsClass) == 0x000428, "Member 'UTimeWatchGameInstance::GlobalsClass' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, DoublesDefaultLevelName) == 0x000430, "Member 'UTimeWatchGameInstance::DoublesDefaultLevelName' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bTestEnvironment) == 0x000440, "Member 'UTimeWatchGameInstance::bTestEnvironment' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, bOfflineMode) == 0x000441, "Member 'UTimeWatchGameInstance::bOfflineMode' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ReplayStartTimeSeconds) == 0x000444, "Member 'UTimeWatchGameInstance::ReplayStartTimeSeconds' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, LastReplayMapName) == 0x000448, "Member 'UTimeWatchGameInstance::LastReplayMapName' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, ExpoVideoPlaylistIndex) == 0x000458, "Member 'UTimeWatchGameInstance::ExpoVideoPlaylistIndex' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, AnalyticsSession) == 0x000468, "Member 'UTimeWatchGameInstance::AnalyticsSession' has a wrong offset!");
static_assert(offsetof(UTimeWatchGameInstance, PlayerPreferences) == 0x000470, "Member 'UTimeWatchGameInstance::PlayerPreferences' has a wrong offset!");

// Class TimeWatch.TWLocalPlayer
// 0x0000 (0x0258 - 0x0258)
class UTWLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLocalPlayer">();
	}
	static class UTWLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLocalPlayer>();
	}
};
static_assert(alignof(UTWLocalPlayer) == 0x000008, "Wrong alignment on UTWLocalPlayer");
static_assert(sizeof(UTWLocalPlayer) == 0x000258, "Wrong size on UTWLocalPlayer");

// Class TimeWatch.TWPartyMember
// 0x0020 (0x0070 - 0x0050)
class UTWPartyMember final : public UNGDPartyMember
{
public:
	class FString                                 UserId;                                            // 0x0050(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIndex;                                         // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantToChangeTeam;                                 // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerUnlockedCasual;                             // 0x0069(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerUnlockedRanked;                             // 0x006A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPartyMember">();
	}
	static class UTWPartyMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPartyMember>();
	}
};
static_assert(alignof(UTWPartyMember) == 0x000008, "Wrong alignment on UTWPartyMember");
static_assert(sizeof(UTWPartyMember) == 0x000070, "Wrong size on UTWPartyMember");
static_assert(offsetof(UTWPartyMember, UserId) == 0x000050, "Member 'UTWPartyMember::UserId' has a wrong offset!");
static_assert(offsetof(UTWPartyMember, TeamIndex) == 0x000060, "Member 'UTWPartyMember::TeamIndex' has a wrong offset!");
static_assert(offsetof(UTWPartyMember, PlayerIndex) == 0x000064, "Member 'UTWPartyMember::PlayerIndex' has a wrong offset!");
static_assert(offsetof(UTWPartyMember, bWantToChangeTeam) == 0x000068, "Member 'UTWPartyMember::bWantToChangeTeam' has a wrong offset!");
static_assert(offsetof(UTWPartyMember, bPlayerUnlockedCasual) == 0x000069, "Member 'UTWPartyMember::bPlayerUnlockedCasual' has a wrong offset!");
static_assert(offsetof(UTWPartyMember, bPlayerUnlockedRanked) == 0x00006A, "Member 'UTWPartyMember::bPlayerUnlockedRanked' has a wrong offset!");

// Class TimeWatch.TimeWatchGameUserSettings
// 0x0010 (0x0130 - 0x0120)
class UTimeWatchGameUserSettings final : public UGameUserSettings
{
public:
	class FString                                 Region;                                            // 0x0120(0x0010)(BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchGameUserSettings">();
	}
	static class UTimeWatchGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeWatchGameUserSettings>();
	}
};
static_assert(alignof(UTimeWatchGameUserSettings) == 0x000008, "Wrong alignment on UTimeWatchGameUserSettings");
static_assert(sizeof(UTimeWatchGameUserSettings) == 0x000130, "Wrong size on UTimeWatchGameUserSettings");
static_assert(offsetof(UTimeWatchGameUserSettings, Region) == 0x000120, "Member 'UTimeWatchGameUserSettings::Region' has a wrong offset!");

// Class TimeWatch.TimeWatchMovementComponent
// 0x0010 (0x0820 - 0x0810)
class UTimeWatchMovementComponent final : public UNGDCharacterMovementComponent
{
public:
	float                                         DoubleJumpPenalizeMinVelocity;                     // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoubleJumpPenalizeVelocityModifier;                // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoubleJumpVelocityModifier;                        // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_814[0xC];                                      // 0x0814(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchMovementComponent">();
	}
	static class UTimeWatchMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeWatchMovementComponent>();
	}
};
static_assert(alignof(UTimeWatchMovementComponent) == 0x000010, "Wrong alignment on UTimeWatchMovementComponent");
static_assert(sizeof(UTimeWatchMovementComponent) == 0x000820, "Wrong size on UTimeWatchMovementComponent");
static_assert(offsetof(UTimeWatchMovementComponent, DoubleJumpPenalizeMinVelocity) == 0x000808, "Member 'UTimeWatchMovementComponent::DoubleJumpPenalizeMinVelocity' has a wrong offset!");
static_assert(offsetof(UTimeWatchMovementComponent, DoubleJumpPenalizeVelocityModifier) == 0x00080C, "Member 'UTimeWatchMovementComponent::DoubleJumpPenalizeVelocityModifier' has a wrong offset!");
static_assert(offsetof(UTimeWatchMovementComponent, DoubleJumpVelocityModifier) == 0x000810, "Member 'UTimeWatchMovementComponent::DoubleJumpVelocityModifier' has a wrong offset!");

// Class TimeWatch.TWPlayerInfoWidgetComponent
// 0x0040 (0x0560 - 0x0520)
class UTWPlayerInfoWidgetComponent final : public UWidgetComponent
{
public:
	class UCurveFloat*                            WidgetScaleByDistanceCurve;                        // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathTimeShowThreshold;                            // 0x0528(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToShowWidget;                                  // 0x052C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWCloneOverheadWidget*                 CloneOverheadWidget;                               // 0x0530(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x28];                                     // 0x0538(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize();
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void UpdateWidgetDeathTimer();
	void UpdateWidgetHealthBar(float DeltaTime);
	void UpdateWidgetScale();

	class UTWCloneOverheadWidget* GetCloneOverHeadWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlayerInfoWidgetComponent">();
	}
	static class UTWPlayerInfoWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPlayerInfoWidgetComponent>();
	}
};
static_assert(alignof(UTWPlayerInfoWidgetComponent) == 0x000010, "Wrong alignment on UTWPlayerInfoWidgetComponent");
static_assert(sizeof(UTWPlayerInfoWidgetComponent) == 0x000560, "Wrong size on UTWPlayerInfoWidgetComponent");
static_assert(offsetof(UTWPlayerInfoWidgetComponent, WidgetScaleByDistanceCurve) == 0x000520, "Member 'UTWPlayerInfoWidgetComponent::WidgetScaleByDistanceCurve' has a wrong offset!");
static_assert(offsetof(UTWPlayerInfoWidgetComponent, DeathTimeShowThreshold) == 0x000528, "Member 'UTWPlayerInfoWidgetComponent::DeathTimeShowThreshold' has a wrong offset!");
static_assert(offsetof(UTWPlayerInfoWidgetComponent, TimeToShowWidget) == 0x00052C, "Member 'UTWPlayerInfoWidgetComponent::TimeToShowWidget' has a wrong offset!");
static_assert(offsetof(UTWPlayerInfoWidgetComponent, CloneOverheadWidget) == 0x000530, "Member 'UTWPlayerInfoWidgetComponent::CloneOverheadWidget' has a wrong offset!");

// Class TimeWatch.TimeWatchProjectile
// 0x00F8 (0x0460 - 0x0368)
class ATimeWatchProjectile : public ABaseProjectile
{
public:
	class ATemporalParticle*                      ImpactTemporalParticle;                            // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0xC];                                      // 0x0370(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ProjectileHitResult;                               // 0x037C(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TrailLength_Time;                                  // 0x0404(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ProjectileMesh;                                    // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ProjectileMeshForObservers;                        // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimeScalarVsGlobalTimeDilation;                    // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x40];                                     // 0x0420(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_Initialize();
	void BP_UpdateCosmetics();

	bool BP_IsReadyToBeDestroyed() const;
	void BP_OnSetEnabled(bool NewState) const;
	struct FVector GetCosmeticCreationLocation() const;
	float GetCosmeticCreationTime() const;
	struct FVector GetCosmeticImpactLocation() const;
	float GetCosmeticImpactTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeWatchProjectile">();
	}
	static class ATimeWatchProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeWatchProjectile>();
	}
};
static_assert(alignof(ATimeWatchProjectile) == 0x000008, "Wrong alignment on ATimeWatchProjectile");
static_assert(sizeof(ATimeWatchProjectile) == 0x000460, "Wrong size on ATimeWatchProjectile");
static_assert(offsetof(ATimeWatchProjectile, ImpactTemporalParticle) == 0x000368, "Member 'ATimeWatchProjectile::ImpactTemporalParticle' has a wrong offset!");
static_assert(offsetof(ATimeWatchProjectile, ProjectileHitResult) == 0x00037C, "Member 'ATimeWatchProjectile::ProjectileHitResult' has a wrong offset!");
static_assert(offsetof(ATimeWatchProjectile, TrailLength_Time) == 0x000404, "Member 'ATimeWatchProjectile::TrailLength_Time' has a wrong offset!");
static_assert(offsetof(ATimeWatchProjectile, ProjectileMesh) == 0x000408, "Member 'ATimeWatchProjectile::ProjectileMesh' has a wrong offset!");
static_assert(offsetof(ATimeWatchProjectile, ProjectileMeshForObservers) == 0x000410, "Member 'ATimeWatchProjectile::ProjectileMeshForObservers' has a wrong offset!");
static_assert(offsetof(ATimeWatchProjectile, TimeScalarVsGlobalTimeDilation) == 0x000418, "Member 'ATimeWatchProjectile::TimeScalarVsGlobalTimeDilation' has a wrong offset!");

// Class TimeWatch.TimewatchSession
// 0x0010 (0x0240 - 0x0230)
class ATimewatchSession final : public ANGDGameSession
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimewatchSession">();
	}
	static class ATimewatchSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimewatchSession>();
	}
};
static_assert(alignof(ATimewatchSession) == 0x000008, "Wrong alignment on ATimewatchSession");
static_assert(sizeof(ATimewatchSession) == 0x000240, "Wrong size on ATimewatchSession");

// Class TimeWatch.TWPhysicalProjectile
// 0x00E0 (0x0540 - 0x0460)
class ATWPhysicalProjectile : public ATimeWatchProjectile
{
public:
	float                                         CreationTime;                                      // 0x0460(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSticky;                                         // 0x0464(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplodeOnImpact;                                  // 0x0465(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_466[0x2];                                      // 0x0466(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForcedHitTimestamp;                                // 0x0468(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   GrenadeMesh;                                       // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHitResult& HitResult)> OnProjectileHitDelegate;      // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FReplicationProjectileActivationData   ActivationData;                                    // 0x0488(0x0034)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FReplicationProjectileState            LastValidState;                                    // 0x04BC(0x002C)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FReplicationProjectileState            PreviousState;                                     // 0x04E8(0x002C)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReplicationProjectileState>    LocalStateBuffer;                                  // 0x0518(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         MaxTravelTime;                                     // 0x0528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitImpulseMultiplier;                              // 0x052C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TICK_TIME;                                         // 0x0530(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MAX_ALLOWED_DELTA;                                 // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MAX_FIXED_TICKS;                                   // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopTickingAfterMovement;                         // 0x053C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53D[0x3];                                      // 0x053D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceOnProjectileOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCreated();
	void OnExploded();
	void OnProjectileHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnProjectileOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRecycled();
	void OnRep_ActivationData();
	void OnRep_LastValidState();

	float GetRemainingTravelTime() const;
	bool HasHitCharacter() const;
	bool ShouldUpdateMovement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPhysicalProjectile">();
	}
	static class ATWPhysicalProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWPhysicalProjectile>();
	}
};
static_assert(alignof(ATWPhysicalProjectile) == 0x000008, "Wrong alignment on ATWPhysicalProjectile");
static_assert(sizeof(ATWPhysicalProjectile) == 0x000540, "Wrong size on ATWPhysicalProjectile");
static_assert(offsetof(ATWPhysicalProjectile, CreationTime) == 0x000460, "Member 'ATWPhysicalProjectile::CreationTime' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, bIsSticky) == 0x000464, "Member 'ATWPhysicalProjectile::bIsSticky' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, bExplodeOnImpact) == 0x000465, "Member 'ATWPhysicalProjectile::bExplodeOnImpact' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, ForcedHitTimestamp) == 0x000468, "Member 'ATWPhysicalProjectile::ForcedHitTimestamp' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, GrenadeMesh) == 0x000470, "Member 'ATWPhysicalProjectile::GrenadeMesh' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, OnProjectileHitDelegate) == 0x000478, "Member 'ATWPhysicalProjectile::OnProjectileHitDelegate' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, ActivationData) == 0x000488, "Member 'ATWPhysicalProjectile::ActivationData' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, LastValidState) == 0x0004BC, "Member 'ATWPhysicalProjectile::LastValidState' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, PreviousState) == 0x0004E8, "Member 'ATWPhysicalProjectile::PreviousState' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, LocalStateBuffer) == 0x000518, "Member 'ATWPhysicalProjectile::LocalStateBuffer' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, MaxTravelTime) == 0x000528, "Member 'ATWPhysicalProjectile::MaxTravelTime' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, HitImpulseMultiplier) == 0x00052C, "Member 'ATWPhysicalProjectile::HitImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, TICK_TIME) == 0x000530, "Member 'ATWPhysicalProjectile::TICK_TIME' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, MAX_ALLOWED_DELTA) == 0x000534, "Member 'ATWPhysicalProjectile::MAX_ALLOWED_DELTA' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, MAX_FIXED_TICKS) == 0x000538, "Member 'ATWPhysicalProjectile::MAX_FIXED_TICKS' has a wrong offset!");
static_assert(offsetof(ATWPhysicalProjectile, bStopTickingAfterMovement) == 0x00053C, "Member 'ATWPhysicalProjectile::bStopTickingAfterMovement' has a wrong offset!");

// Class TimeWatch.TWPhysicalExplodingProjectile
// 0x0038 (0x0578 - 0x0540)
class ATWPhysicalExplodingProjectile : public ATWPhysicalProjectile
{
public:
	class UStaticMeshComponent*                   ExplosionMesh;                                     // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       KillAreaCollision;                                 // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionTime;                                     // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxExplosionDiameter;                              // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionThresholdScalar;                          // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxImpulseForce;                                   // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DpsLifeTimeCuve;                                   // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RelativeSizeOverTime;                              // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRayCastCollisionCheck;                            // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             DamageBlockCollisionChannel;                       // 0x0571(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_572[0x6];                                      // 0x0572(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawDebugExplosion(const struct FVector& ExplosionLocation, float ExplosionRadius);
	void DrawDebugExplosionHit(const struct FVector& VictimLocation, float RadiusIntersection, bool bEnteringExplosion);
	float GetExplosionTime();

	float GetCosmeticExplosionRequiredTime() const;
	float GetExplosionMaxSize() const;
	float GetExplosionSize() const;
	float GetExplosionTimestamp() const;
	float GetRelativeExplosionTime() const;
	bool IsExploding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPhysicalExplodingProjectile">();
	}
	static class ATWPhysicalExplodingProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWPhysicalExplodingProjectile>();
	}
};
static_assert(alignof(ATWPhysicalExplodingProjectile) == 0x000008, "Wrong alignment on ATWPhysicalExplodingProjectile");
static_assert(sizeof(ATWPhysicalExplodingProjectile) == 0x000578, "Wrong size on ATWPhysicalExplodingProjectile");
static_assert(offsetof(ATWPhysicalExplodingProjectile, ExplosionMesh) == 0x000540, "Member 'ATWPhysicalExplodingProjectile::ExplosionMesh' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, KillAreaCollision) == 0x000548, "Member 'ATWPhysicalExplodingProjectile::KillAreaCollision' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, ExplosionTime) == 0x000550, "Member 'ATWPhysicalExplodingProjectile::ExplosionTime' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, MaxExplosionDiameter) == 0x000554, "Member 'ATWPhysicalExplodingProjectile::MaxExplosionDiameter' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, ExplosionThresholdScalar) == 0x000558, "Member 'ATWPhysicalExplodingProjectile::ExplosionThresholdScalar' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, MaxImpulseForce) == 0x00055C, "Member 'ATWPhysicalExplodingProjectile::MaxImpulseForce' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, DpsLifeTimeCuve) == 0x000560, "Member 'ATWPhysicalExplodingProjectile::DpsLifeTimeCuve' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, RelativeSizeOverTime) == 0x000568, "Member 'ATWPhysicalExplodingProjectile::RelativeSizeOverTime' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, bRayCastCollisionCheck) == 0x000570, "Member 'ATWPhysicalExplodingProjectile::bRayCastCollisionCheck' has a wrong offset!");
static_assert(offsetof(ATWPhysicalExplodingProjectile, DamageBlockCollisionChannel) == 0x000571, "Member 'ATWPhysicalExplodingProjectile::DamageBlockCollisionChannel' has a wrong offset!");

// Class TimeWatch.TutorialGameMode
// 0x0000 (0x0470 - 0x0470)
class ATutorialGameMode final : public ATimeWatchGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGameMode">();
	}
	static class ATutorialGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGameMode>();
	}
};
static_assert(alignof(ATutorialGameMode) == 0x000008, "Wrong alignment on ATutorialGameMode");
static_assert(sizeof(ATutorialGameMode) == 0x000470, "Wrong size on ATutorialGameMode");

// Class TimeWatch.TWAbilitiesComponent
// 0x00A0 (0x0150 - 0x00B0)
class UTWAbilitiesComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATWGameplayAbilityTargetActor*>  SpawnedTargetActors;                               // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FTWAbilityInstanceData, struct FGameplayAbilityCollection> GameplayTaskWaitingReusage; // 0x00E0(0x0050)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxEnergy;                                         // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnergyGainPerSec;                                  // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentEnergy;                                     // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameplayTasksComponent* GetGameplayTasksComponent();
	void Multicast_ActivateAbility(const struct FTWAbilityCustomDataHandle& AbilityDataHandle);
	void OnRep_Energy(float OldEnergy);
	void Server_ActivateAbility(const struct FTWAbilityCustomDataHandle& AbilityDataHandle);
	void TargetCancel();
	void TargetConfirm();
	void TryActivateAbility(TSubclassOf<class UTWAbility> Ability);

	float GetAbilityCost(int32 AbilityIndex) const;
	class ATimeWatchGameState* GetGameState() const;
	class ATimeWatchCharacter* GetOwningCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWAbilitiesComponent">();
	}
	static class UTWAbilitiesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWAbilitiesComponent>();
	}
};
static_assert(alignof(UTWAbilitiesComponent) == 0x000008, "Wrong alignment on UTWAbilitiesComponent");
static_assert(sizeof(UTWAbilitiesComponent) == 0x000150, "Wrong size on UTWAbilitiesComponent");
static_assert(offsetof(UTWAbilitiesComponent, SpawnedTargetActors) == 0x0000D0, "Member 'UTWAbilitiesComponent::SpawnedTargetActors' has a wrong offset!");
static_assert(offsetof(UTWAbilitiesComponent, GameplayTaskWaitingReusage) == 0x0000E0, "Member 'UTWAbilitiesComponent::GameplayTaskWaitingReusage' has a wrong offset!");
static_assert(offsetof(UTWAbilitiesComponent, MaxEnergy) == 0x000140, "Member 'UTWAbilitiesComponent::MaxEnergy' has a wrong offset!");
static_assert(offsetof(UTWAbilitiesComponent, EnergyGainPerSec) == 0x000144, "Member 'UTWAbilitiesComponent::EnergyGainPerSec' has a wrong offset!");
static_assert(offsetof(UTWAbilitiesComponent, CurrentEnergy) == 0x000148, "Member 'UTWAbilitiesComponent::CurrentEnergy' has a wrong offset!");

// Class TimeWatch.TWOnlineBeaconClient
// 0x0040 (0x0310 - 0x02D0)
class ATWOnlineBeaconClient final : public ANGDOnlineBeaconClient
{
public:
	uint8                                         Pad_2D0[0x40];                                     // 0x02D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_CancelMatchmaking();
	void Client_GoCustomMatch();
	void Client_ReplicateLobbySetting(const ELobbyReplicableField& Field, const class FString& Value);
	void Client_StartMatchmaking(ETWMatchQueueType MatchQueueType, const class FString& LobbyID);
	void OnCustomLobbySettingChange(ELobbyReplicableField Field, const class FString& Value);
	void Server_CancelMatchmaking();
	void Server_ChangeLobbyTeam();
	void Server_GoAsSpectator();
	void Server_GoCustomMatch();
	void Server_SetUserId(const class FString& InUserID);
	void Server_SetUserUnlockedCasual(const bool bUnlockedCasual);
	void Server_SetUserUnlockedRanked(const bool bUnlockedRanked);
	void Server_StartMatchmaking(ETWMatchQueueType MatchQueueType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWOnlineBeaconClient">();
	}
	static class ATWOnlineBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWOnlineBeaconClient>();
	}
};
static_assert(alignof(ATWOnlineBeaconClient) == 0x000008, "Wrong alignment on ATWOnlineBeaconClient");
static_assert(sizeof(ATWOnlineBeaconClient) == 0x000310, "Wrong size on ATWOnlineBeaconClient");

// Class TimeWatch.TWAbility
// 0x0048 (0x0070 - 0x0028)
class UTWAbility : public UObject
{
public:
	struct FTWAbilityData                         Data;                                              // 0x0028(0x0014)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWGameplayAbilitySystem*               TWAbilitySystem;                                   // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTWAbilityInstanceData                 InstanceData;                                      // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPassiveAbility;                                 // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_Cancel(class UTWGameplayAbilitySystem* InTWAbilitySystem);
	void BP_Commit(class UTWGameplayAbilitySystem* InTWAbilitySystem);
	void BP_OnActivated(class UTWGameplayAbilitySystem* InTWAbilitySystem, const struct FTWAbilityCustomDataHandle& AbilityDataHandle, const bool bShouldTriggerLogic);
	void BP_OnFinished();
	void BP_OnPause();
	void BP_OnPreActivated(class UTWGameplayAbilitySystem* InTWAbilitySystem, class UTWAbilitiesComponent* Caster_AbilityComp);
	void BP_OnReExecuted(class UTWGameplayAbilitySystem* InTWAbilitySystem, const struct FTWAbilityCustomDataHandle& AbilityDataHandle, const bool bShouldTriggerLogic);
	void BP_OnRestoreAfterNonResetOvertime();
	void BP_OnResume();
	void BP_Update(float DeltaSeconds);
	void EndAbility();
	struct FTWAbilityCustomDataHandle MakeAbilityCustomDataHandle(class UTWAbilitiesComponent* Caster_AbilityComp);

	struct FTWAbilityData GetAbilityData() const;
	struct FTWAbilityInstanceData GetInstanceData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWAbility">();
	}
	static class UTWAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWAbility>();
	}
};
static_assert(alignof(UTWAbility) == 0x000008, "Wrong alignment on UTWAbility");
static_assert(sizeof(UTWAbility) == 0x000070, "Wrong size on UTWAbility");
static_assert(offsetof(UTWAbility, Data) == 0x000028, "Member 'UTWAbility::Data' has a wrong offset!");
static_assert(offsetof(UTWAbility, TWAbilitySystem) == 0x000040, "Member 'UTWAbility::TWAbilitySystem' has a wrong offset!");
static_assert(offsetof(UTWAbility, InstanceData) == 0x000048, "Member 'UTWAbility::InstanceData' has a wrong offset!");
static_assert(offsetof(UTWAbility, bIsPassiveAbility) == 0x000068, "Member 'UTWAbility::bIsPassiveAbility' has a wrong offset!");

// Class TimeWatch.TWAbilityDataAsset
// 0x0078 (0x00A8 - 0x0030)
class UTWAbilityDataAsset final : public UDataAsset
{
public:
	class FString                                 AbilityIdentifier;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AbilityName;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AbilityDescription;                                // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            TextColor;                                         // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             UI_Icon;                                           // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTWAbility>                 Ability;                                           // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWAbilityDataAsset">();
	}
	static class UTWAbilityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWAbilityDataAsset>();
	}
};
static_assert(alignof(UTWAbilityDataAsset) == 0x000008, "Wrong alignment on UTWAbilityDataAsset");
static_assert(sizeof(UTWAbilityDataAsset) == 0x0000A8, "Wrong size on UTWAbilityDataAsset");
static_assert(offsetof(UTWAbilityDataAsset, AbilityIdentifier) == 0x000030, "Member 'UTWAbilityDataAsset::AbilityIdentifier' has a wrong offset!");
static_assert(offsetof(UTWAbilityDataAsset, AbilityName) == 0x000040, "Member 'UTWAbilityDataAsset::AbilityName' has a wrong offset!");
static_assert(offsetof(UTWAbilityDataAsset, AbilityDescription) == 0x000058, "Member 'UTWAbilityDataAsset::AbilityDescription' has a wrong offset!");
static_assert(offsetof(UTWAbilityDataAsset, TextColor) == 0x000070, "Member 'UTWAbilityDataAsset::TextColor' has a wrong offset!");
static_assert(offsetof(UTWAbilityDataAsset, UI_Icon) == 0x000098, "Member 'UTWAbilityDataAsset::UI_Icon' has a wrong offset!");
static_assert(offsetof(UTWAbilityDataAsset, Ability) == 0x0000A0, "Member 'UTWAbilityDataAsset::Ability' has a wrong offset!");

// Class TimeWatch.TWPlayerCardWidget
// 0x0098 (0x0318 - 0x0280)
class UTWPlayerCardWidget : public UNGDUserWidget
{
public:
	class UTextBlock*                             Text_PlayerName;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PlayerTitle;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeagueMedal;                                 // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_TeamColorAccent;                             // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Background;                                  // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                Spacer_NoLeague;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_LeagueBadge;                           // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWLeagueDataAsset*                     LeaguesData;                                       // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWRewardsDataAsset*                    RewardsDataAsset;                                  // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            NeutralColor;                                      // 0x02C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxPlayerNameSize;                                 // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPlayerNameSizeNoRank;                           // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugMode;                                        // 0x02F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TestPlayerName;                                    // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TestRanking;                                       // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlayerCardWidget">();
	}
	static class UTWPlayerCardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPlayerCardWidget>();
	}
};
static_assert(alignof(UTWPlayerCardWidget) == 0x000008, "Wrong alignment on UTWPlayerCardWidget");
static_assert(sizeof(UTWPlayerCardWidget) == 0x000318, "Wrong size on UTWPlayerCardWidget");
static_assert(offsetof(UTWPlayerCardWidget, Text_PlayerName) == 0x000280, "Member 'UTWPlayerCardWidget::Text_PlayerName' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, Text_PlayerTitle) == 0x000288, "Member 'UTWPlayerCardWidget::Text_PlayerTitle' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, Image_LeagueMedal) == 0x000290, "Member 'UTWPlayerCardWidget::Image_LeagueMedal' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, Image_TeamColorAccent) == 0x000298, "Member 'UTWPlayerCardWidget::Image_TeamColorAccent' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, Image_Background) == 0x0002A0, "Member 'UTWPlayerCardWidget::Image_Background' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, Spacer_NoLeague) == 0x0002A8, "Member 'UTWPlayerCardWidget::Spacer_NoLeague' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, VerticalBox_LeagueBadge) == 0x0002B0, "Member 'UTWPlayerCardWidget::VerticalBox_LeagueBadge' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, LeaguesData) == 0x0002B8, "Member 'UTWPlayerCardWidget::LeaguesData' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, RewardsDataAsset) == 0x0002C0, "Member 'UTWPlayerCardWidget::RewardsDataAsset' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, NeutralColor) == 0x0002C8, "Member 'UTWPlayerCardWidget::NeutralColor' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, MaxPlayerNameSize) == 0x0002F0, "Member 'UTWPlayerCardWidget::MaxPlayerNameSize' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, MaxPlayerNameSizeNoRank) == 0x0002F4, "Member 'UTWPlayerCardWidget::MaxPlayerNameSizeNoRank' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, bDebugMode) == 0x0002F8, "Member 'UTWPlayerCardWidget::bDebugMode' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, TestPlayerName) == 0x000300, "Member 'UTWPlayerCardWidget::TestPlayerName' has a wrong offset!");
static_assert(offsetof(UTWPlayerCardWidget, TestRanking) == 0x000310, "Member 'UTWPlayerCardWidget::TestRanking' has a wrong offset!");

// Class TimeWatch.TWAbilityDescriptionWidget
// 0x0018 (0x0298 - 0x0280)
class UTWAbilityDescriptionWidget : public UNGDUserWidget
{
public:
	class UImage*                                 Image_Icon;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Title;                                        // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWAbilityDescriptionWidget">();
	}
	static class UTWAbilityDescriptionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWAbilityDescriptionWidget>();
	}
};
static_assert(alignof(UTWAbilityDescriptionWidget) == 0x000008, "Wrong alignment on UTWAbilityDescriptionWidget");
static_assert(sizeof(UTWAbilityDescriptionWidget) == 0x000298, "Wrong size on UTWAbilityDescriptionWidget");
static_assert(offsetof(UTWAbilityDescriptionWidget, Image_Icon) == 0x000280, "Member 'UTWAbilityDescriptionWidget::Image_Icon' has a wrong offset!");
static_assert(offsetof(UTWAbilityDescriptionWidget, Text_Title) == 0x000288, "Member 'UTWAbilityDescriptionWidget::Text_Title' has a wrong offset!");
static_assert(offsetof(UTWAbilityDescriptionWidget, Text_Description) == 0x000290, "Member 'UTWAbilityDescriptionWidget::Text_Description' has a wrong offset!");

// Class TimeWatch.TWAbilityMelee
// 0x0058 (0x00C8 - 0x0070)
class UTWAbilityMelee : public UTWAbility
{
public:
	struct FTWMeleeConfig                         CurrentWeaponConfig;                               // 0x0070(0x0028)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTWAbilityExecutionData                CastData;                                          // 0x0098(0x0028)(BlueprintVisible, Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldAttack;                                     // 0x00C0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_PlayMeleeImpactParticles(const struct FHitResult& Hit);
	void DoMeleeAttack();
	void InitAbility(const struct FTWAbilityExecutionData& inCastData);
	void PlayBarrelHitFX(const struct FHitResult& Hit);
	void PlayDamageFX(const struct FHitResult& Hit);
	void PlayOtherActorHitFX(const struct FHitResult& Hit);
	void PlayPhysicsHitFX(const struct FHitResult& Hit);

	void CalcHitSweep(struct FVector* outStartPos, struct FVector* outEndPos) const;
	float GetDamageTime() const;
	float GetDamageTimeOffset() const;
	bool GetHit(struct FHitResult* outFoundHit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWAbilityMelee">();
	}
	static class UTWAbilityMelee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWAbilityMelee>();
	}
};
static_assert(alignof(UTWAbilityMelee) == 0x000008, "Wrong alignment on UTWAbilityMelee");
static_assert(sizeof(UTWAbilityMelee) == 0x0000C8, "Wrong size on UTWAbilityMelee");
static_assert(offsetof(UTWAbilityMelee, CurrentWeaponConfig) == 0x000070, "Member 'UTWAbilityMelee::CurrentWeaponConfig' has a wrong offset!");
static_assert(offsetof(UTWAbilityMelee, CastData) == 0x000098, "Member 'UTWAbilityMelee::CastData' has a wrong offset!");
static_assert(offsetof(UTWAbilityMelee, bShouldAttack) == 0x0000C0, "Member 'UTWAbilityMelee::bShouldAttack' has a wrong offset!");

// Class TimeWatch.TWPremiumBannerWidget
// 0x0030 (0x02B0 - 0x0280)
class UTWPremiumBannerWidget : public UNGDUserWidget
{
public:
	EBannerSize                                   BannerSize;                                        // 0x0280(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWStandardButtonWidget*                Button_UnlockPremium;                              // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_BigBanner;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_MediumBanner;                                // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_SmallBanner;                                 // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPremiumBannerWidget">();
	}
	static class UTWPremiumBannerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPremiumBannerWidget>();
	}
};
static_assert(alignof(UTWPremiumBannerWidget) == 0x000008, "Wrong alignment on UTWPremiumBannerWidget");
static_assert(sizeof(UTWPremiumBannerWidget) == 0x0002B0, "Wrong size on UTWPremiumBannerWidget");
static_assert(offsetof(UTWPremiumBannerWidget, BannerSize) == 0x000280, "Member 'UTWPremiumBannerWidget::BannerSize' has a wrong offset!");
static_assert(offsetof(UTWPremiumBannerWidget, Button_UnlockPremium) == 0x000288, "Member 'UTWPremiumBannerWidget::Button_UnlockPremium' has a wrong offset!");
static_assert(offsetof(UTWPremiumBannerWidget, Image_BigBanner) == 0x000290, "Member 'UTWPremiumBannerWidget::Image_BigBanner' has a wrong offset!");
static_assert(offsetof(UTWPremiumBannerWidget, Image_MediumBanner) == 0x000298, "Member 'UTWPremiumBannerWidget::Image_MediumBanner' has a wrong offset!");
static_assert(offsetof(UTWPremiumBannerWidget, Image_SmallBanner) == 0x0002A0, "Member 'UTWPremiumBannerWidget::Image_SmallBanner' has a wrong offset!");
static_assert(offsetof(UTWPremiumBannerWidget, Text_Description) == 0x0002A8, "Member 'UTWPremiumBannerWidget::Text_Description' has a wrong offset!");

// Class TimeWatch.TWActorCompass
// 0x0010 (0x02D0 - 0x02C0)
class UTWActorCompass : public UTW2DCompass
{
public:
	class AActor*                                 ActorToTrack;                                      // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnPreUpdate();
	void OnReset(const class AActor* OwnerActor);
	void OnUpdated(float Distance);

	bool IsCompassVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWActorCompass">();
	}
	static class UTWActorCompass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWActorCompass>();
	}
};
static_assert(alignof(UTWActorCompass) == 0x000008, "Wrong alignment on UTWActorCompass");
static_assert(sizeof(UTWActorCompass) == 0x0002D0, "Wrong size on UTWActorCompass");
static_assert(offsetof(UTWActorCompass, ActorToTrack) == 0x0002C0, "Member 'UTWActorCompass::ActorToTrack' has a wrong offset!");
static_assert(offsetof(UTWActorCompass, RemainingTime) == 0x0002C8, "Member 'UTWActorCompass::RemainingTime' has a wrong offset!");
static_assert(offsetof(UTWActorCompass, Duration) == 0x0002CC, "Member 'UTWActorCompass::Duration' has a wrong offset!");

// Class TimeWatch.TWAnnouncer
// 0x01A0 (0x03B8 - 0x0218)
class ATWAnnouncer final : public AActor
{
public:
	bool                                          bSkipDispatchEvents;                               // 0x0218(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipDispatchCustomEvents;                         // 0x0219(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDAkComponent*                        AkCrowds;                                          // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UTimeWatchEvent>, struct FBaseEventSettings> EventSettings;               // 0x0228(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UTimeWatchEvent>, float> EventCooldowns;                                  // 0x0278(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FBaseEventSettings> CustomAnnouncerEvents;                            // 0x02C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        AkComponent;                                       // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWMatchIntensityHandle*                MatchIntensityHandler;                             // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnnouncerEvent>                EventBuffer;                                       // 0x0328(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FAnnouncerEvent                        CurrentEvent;                                      // 0x0338(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DispatchCustomEvent(const class FString& EventId);
	void DispatchEvent(class UTimeWatchEvent* Event);

	bool IsCurrentEventOfClass(TSubclassOf<class UTimeWatchEvent> EventClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWAnnouncer">();
	}
	static class ATWAnnouncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWAnnouncer>();
	}
};
static_assert(alignof(ATWAnnouncer) == 0x000008, "Wrong alignment on ATWAnnouncer");
static_assert(sizeof(ATWAnnouncer) == 0x0003B8, "Wrong size on ATWAnnouncer");
static_assert(offsetof(ATWAnnouncer, bSkipDispatchEvents) == 0x000218, "Member 'ATWAnnouncer::bSkipDispatchEvents' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, bSkipDispatchCustomEvents) == 0x000219, "Member 'ATWAnnouncer::bSkipDispatchCustomEvents' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, AkCrowds) == 0x000220, "Member 'ATWAnnouncer::AkCrowds' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, EventSettings) == 0x000228, "Member 'ATWAnnouncer::EventSettings' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, EventCooldowns) == 0x000278, "Member 'ATWAnnouncer::EventCooldowns' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, CustomAnnouncerEvents) == 0x0002C8, "Member 'ATWAnnouncer::CustomAnnouncerEvents' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, AkComponent) == 0x000318, "Member 'ATWAnnouncer::AkComponent' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, MatchIntensityHandler) == 0x000320, "Member 'ATWAnnouncer::MatchIntensityHandler' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, EventBuffer) == 0x000328, "Member 'ATWAnnouncer::EventBuffer' has a wrong offset!");
static_assert(offsetof(ATWAnnouncer, CurrentEvent) == 0x000338, "Member 'ATWAnnouncer::CurrentEvent' has a wrong offset!");

// Class TimeWatch.TWAutoSpectateComponent
// 0x0060 (0x0110 - 0x00B0)
class UTWAutoSpectateComponent final : public UActorComponent
{
public:
	float                                         RagdollCameraSpringArmLength;                      // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RagdollCameraMinVelocity;                          // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxVelocityVariation;                              // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RagdollCamDuration;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeadCamDuration;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Instigator3PCamDuration;                           // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloneTransitionFadeDuration;                       // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CloneTransitionCameraRelativeRotation;             // 0x00CC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CloneTransitionFadeCurve;                          // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATimeWatchCharacter*                    ScorerClone;                                       // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DeadCamTransitionHandler;                          // 0x00F0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           Instigator3PTransitionHandler;                     // 0x00F8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACameraTransitionPoint*>         SpectatorCameraTransitionPoints;                   // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BeginTransitionToThirdPerson();
	void OnDeadCamTransitionFinished();
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnInstigatorTransitionFinished();
	void OnRagdollCamFinished();
	void OnTeamScored(int32 TeamId);
	void OnVictoryConditionReached();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWAutoSpectateComponent">();
	}
	static class UTWAutoSpectateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWAutoSpectateComponent>();
	}
};
static_assert(alignof(UTWAutoSpectateComponent) == 0x000008, "Wrong alignment on UTWAutoSpectateComponent");
static_assert(sizeof(UTWAutoSpectateComponent) == 0x000110, "Wrong size on UTWAutoSpectateComponent");
static_assert(offsetof(UTWAutoSpectateComponent, RagdollCameraSpringArmLength) == 0x0000B0, "Member 'UTWAutoSpectateComponent::RagdollCameraSpringArmLength' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, RagdollCameraMinVelocity) == 0x0000B4, "Member 'UTWAutoSpectateComponent::RagdollCameraMinVelocity' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, MaxVelocityVariation) == 0x0000B8, "Member 'UTWAutoSpectateComponent::MaxVelocityVariation' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, RagdollCamDuration) == 0x0000BC, "Member 'UTWAutoSpectateComponent::RagdollCamDuration' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, DeadCamDuration) == 0x0000C0, "Member 'UTWAutoSpectateComponent::DeadCamDuration' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, Instigator3PCamDuration) == 0x0000C4, "Member 'UTWAutoSpectateComponent::Instigator3PCamDuration' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, CloneTransitionFadeDuration) == 0x0000C8, "Member 'UTWAutoSpectateComponent::CloneTransitionFadeDuration' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, CloneTransitionCameraRelativeRotation) == 0x0000CC, "Member 'UTWAutoSpectateComponent::CloneTransitionCameraRelativeRotation' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, CloneTransitionFadeCurve) == 0x0000D8, "Member 'UTWAutoSpectateComponent::CloneTransitionFadeCurve' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, ScorerClone) == 0x0000E0, "Member 'UTWAutoSpectateComponent::ScorerClone' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, DeadCamTransitionHandler) == 0x0000F0, "Member 'UTWAutoSpectateComponent::DeadCamTransitionHandler' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, Instigator3PTransitionHandler) == 0x0000F8, "Member 'UTWAutoSpectateComponent::Instigator3PTransitionHandler' has a wrong offset!");
static_assert(offsetof(UTWAutoSpectateComponent, SpectatorCameraTransitionPoints) == 0x000100, "Member 'UTWAutoSpectateComponent::SpectatorCameraTransitionPoints' has a wrong offset!");

// Class TimeWatch.TWPlaybook
// 0x0298 (0x04B0 - 0x0218)
class alignas(0x10) ATWPlaybook final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0218(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          LevelBondingVolume;                                // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root_Mesh;                                         // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          MeshBoundingVolume;                                // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LevelMesh;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArmComp;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComp;                                        // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class ATimeWatchCharacter*, struct FPlaybookData> CharactersData;                           // 0x0250(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class ATimeWatchCharacter*, struct FTrail> Trails;                                          // 0x02A0(0x0050)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           LoopContinueCharactersPoisition;                   // 0x02F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LocationThresholdBetweenSamples;                   // 0x0300(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SegmentMaterial_Alive;                             // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SegmentMaterial_Dead;                              // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TangentScaleFactor;                                // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationTime;                                     // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillShootsAnimationTime;                           // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           KillShootsColor;                                   // 0x032C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeshAssetData                         TrailAsset;                                        // 0x0340(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMeshAssetData                         ArrowAsset;                                        // 0x0358(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMeshAssetData                         KillShootAsset;                                    // 0x0370(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMeshAssetData                         MarkerAsset_Death;                                 // 0x0388(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMeshAssetData                         MarkerAsset_Revive;                                // 0x03A0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMeshAssetData                         MarkerAsset_PositionOnContinue;                    // 0x03B8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsVisible;                                        // 0x03D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPingMarker>                    PingMarkers;                                       // 0x03D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UStaticMeshComponent*>      PingMarkerMeshes;                                  // 0x03E8(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x78];                                     // 0x0438(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPingOnPlaybook(const struct FVector& PingPlaybookPosition, const struct FVector& PingNormal);
	void DrawPlaybook();
	void GetKillData(class ATimeWatchCharacter* Character, TArray<struct FDeathData>* OutDeathData);
	void GetTrailData(class ATimeWatchCharacter* Character, TArray<struct FPointData>* OutTrailData);
	void OnPingAdded(const struct FPingMarker& NewPing);
	void OnPingRemoved(int32 PingID);
	void OnStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void ToggleCursorPlaybook(bool bToggleValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlaybook">();
	}
	static class ATWPlaybook* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWPlaybook>();
	}
};
static_assert(alignof(ATWPlaybook) == 0x000010, "Wrong alignment on ATWPlaybook");
static_assert(sizeof(ATWPlaybook) == 0x0004B0, "Wrong size on ATWPlaybook");
static_assert(offsetof(ATWPlaybook, Root) == 0x000218, "Member 'ATWPlaybook::Root' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, LevelBondingVolume) == 0x000220, "Member 'ATWPlaybook::LevelBondingVolume' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, Root_Mesh) == 0x000228, "Member 'ATWPlaybook::Root_Mesh' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, MeshBoundingVolume) == 0x000230, "Member 'ATWPlaybook::MeshBoundingVolume' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, LevelMesh) == 0x000238, "Member 'ATWPlaybook::LevelMesh' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, SpringArmComp) == 0x000240, "Member 'ATWPlaybook::SpringArmComp' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, CameraComp) == 0x000248, "Member 'ATWPlaybook::CameraComp' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, CharactersData) == 0x000250, "Member 'ATWPlaybook::CharactersData' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, Trails) == 0x0002A0, "Member 'ATWPlaybook::Trails' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, LoopContinueCharactersPoisition) == 0x0002F0, "Member 'ATWPlaybook::LoopContinueCharactersPoisition' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, LocationThresholdBetweenSamples) == 0x000300, "Member 'ATWPlaybook::LocationThresholdBetweenSamples' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, SegmentMaterial_Alive) == 0x000310, "Member 'ATWPlaybook::SegmentMaterial_Alive' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, SegmentMaterial_Dead) == 0x000318, "Member 'ATWPlaybook::SegmentMaterial_Dead' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, TangentScaleFactor) == 0x000320, "Member 'ATWPlaybook::TangentScaleFactor' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, AnimationTime) == 0x000324, "Member 'ATWPlaybook::AnimationTime' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, KillShootsAnimationTime) == 0x000328, "Member 'ATWPlaybook::KillShootsAnimationTime' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, KillShootsColor) == 0x00032C, "Member 'ATWPlaybook::KillShootsColor' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, TrailAsset) == 0x000340, "Member 'ATWPlaybook::TrailAsset' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, ArrowAsset) == 0x000358, "Member 'ATWPlaybook::ArrowAsset' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, KillShootAsset) == 0x000370, "Member 'ATWPlaybook::KillShootAsset' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, MarkerAsset_Death) == 0x000388, "Member 'ATWPlaybook::MarkerAsset_Death' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, MarkerAsset_Revive) == 0x0003A0, "Member 'ATWPlaybook::MarkerAsset_Revive' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, MarkerAsset_PositionOnContinue) == 0x0003B8, "Member 'ATWPlaybook::MarkerAsset_PositionOnContinue' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, bIsVisible) == 0x0003D0, "Member 'ATWPlaybook::bIsVisible' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, PingMarkers) == 0x0003D8, "Member 'ATWPlaybook::PingMarkers' has a wrong offset!");
static_assert(offsetof(ATWPlaybook, PingMarkerMeshes) == 0x0003E8, "Member 'ATWPlaybook::PingMarkerMeshes' has a wrong offset!");

// Class TimeWatch.TWCameraViewTargetPoint
// 0x0008 (0x0220 - 0x0218)
class ATWCameraViewTargetPoint final : public AActor
{
public:
	class USceneComponent*                        CustomRoot;                                        // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCameraViewTargetPoint">();
	}
	static class ATWCameraViewTargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWCameraViewTargetPoint>();
	}
};
static_assert(alignof(ATWCameraViewTargetPoint) == 0x000008, "Wrong alignment on ATWCameraViewTargetPoint");
static_assert(sizeof(ATWCameraViewTargetPoint) == 0x000220, "Wrong size on ATWCameraViewTargetPoint");
static_assert(offsetof(ATWCameraViewTargetPoint, CustomRoot) == 0x000218, "Member 'ATWCameraViewTargetPoint::CustomRoot' has a wrong offset!");

// Class TimeWatch.TWChallengeClock
// 0x0018 (0x0298 - 0x0280)
class UTWChallengeClock final : public UNGDUserWidget
{
public:
	float                                         Time;                                              // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x14];                                     // 0x0284(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTimer(TDelegate<void()> TimerDynamicDelegate, float Duration);
	void StartChronometer();
	void StopChronometer();
	void StopTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWChallengeClock">();
	}
	static class UTWChallengeClock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWChallengeClock>();
	}
};
static_assert(alignof(UTWChallengeClock) == 0x000008, "Wrong alignment on UTWChallengeClock");
static_assert(sizeof(UTWChallengeClock) == 0x000298, "Wrong size on UTWChallengeClock");
static_assert(offsetof(UTWChallengeClock, Time) == 0x000280, "Member 'UTWChallengeClock::Time' has a wrong offset!");

// Class TimeWatch.TWChallengeEvent
// 0x0088 (0x00B0 - 0x0028)
class UTWChallengeEvent final : public UObject
{
public:
	TMulticastInlineDelegate<void(class UTWChallengeEvent* ChallengeEvent, const struct FTWChallengeRule& Rule)> OnChallengeProgress; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTWChallengeRule>    ChallengeRules;                                    // 0x0038(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTWChallengeEntryTypes                 ChallengeInfo;                                     // 0x0088(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWChallengeEvent">();
	}
	static class UTWChallengeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWChallengeEvent>();
	}
};
static_assert(alignof(UTWChallengeEvent) == 0x000008, "Wrong alignment on UTWChallengeEvent");
static_assert(sizeof(UTWChallengeEvent) == 0x0000B0, "Wrong size on UTWChallengeEvent");
static_assert(offsetof(UTWChallengeEvent, OnChallengeProgress) == 0x000028, "Member 'UTWChallengeEvent::OnChallengeProgress' has a wrong offset!");
static_assert(offsetof(UTWChallengeEvent, ChallengeRules) == 0x000038, "Member 'UTWChallengeEvent::ChallengeRules' has a wrong offset!");
static_assert(offsetof(UTWChallengeEvent, ChallengeInfo) == 0x000088, "Member 'UTWChallengeEvent::ChallengeInfo' has a wrong offset!");

// Class TimeWatch.TWChallengeEventData
// 0x0010 (0x0040 - 0x0030)
class UTWChallengeEventData final : public UDataAsset
{
public:
	TArray<struct FTWChallengeEventInfo>          Challenges;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWChallengeEventData">();
	}
	static class UTWChallengeEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWChallengeEventData>();
	}
};
static_assert(alignof(UTWChallengeEventData) == 0x000008, "Wrong alignment on UTWChallengeEventData");
static_assert(sizeof(UTWChallengeEventData) == 0x000040, "Wrong size on UTWChallengeEventData");
static_assert(offsetof(UTWChallengeEventData, Challenges) == 0x000030, "Member 'UTWChallengeEventData::Challenges' has a wrong offset!");

// Class TimeWatch.TWChallengeWidgetContainer
// 0x0000 (0x0248 - 0x0248)
class UTWChallengeWidgetContainer final : public UNGDWidgetContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWChallengeWidgetContainer">();
	}
	static class UTWChallengeWidgetContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWChallengeWidgetContainer>();
	}
};
static_assert(alignof(UTWChallengeWidgetContainer) == 0x000008, "Wrong alignment on UTWChallengeWidgetContainer");
static_assert(sizeof(UTWChallengeWidgetContainer) == 0x000248, "Wrong size on UTWChallengeWidgetContainer");

// Class TimeWatch.TWCharacterCustomizationComponent
// 0x0130 (0x01E0 - 0x00B0)
class UTWCharacterCustomizationComponent final : public UActorComponent
{
public:
	class AFluxPlayerState*                       CustomizationPlayerState;                          // 0x00B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWCharacterDataAsset*                  SelectedCharacterDataAsset;                        // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWWeaponDataAsset*>             SelectedWeaponsDataAssets;                         // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UTWStylesDataAsset*                     SelectedStyle;                                     // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UMaterialInstanceDynamic* DynamicMaterial)> CustomizeGhostMaterial; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UMaterialInstanceDynamic*>  FPCharacterDynMatInstances;                        // 0x00E8(0x0050)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UMaterialInstanceDynamic*>  TPCharacterDynMatInstances;                        // 0x0138(0x0050)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TPNextGhostMatInt;                                 // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               TPNextGhostDynMatInst;                             // 0x0190(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TPNotNextGhostMatInt;                              // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               TPNotNextGhostDynMatInst;                          // 0x01A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SpectatorGhostMatInt;                              // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               SpectatorGhostDynMatInst;                          // 0x01B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsyncLoadCompleted;                               // 0x01B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCustomWeaponAssigned;                             // 0x01B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsyncLoadNotified;                                // 0x01BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRequestingAssetLoad;                            // 0x01BB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGhostTime;                                      // 0x01BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        AssetCache;                                        // 0x01C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckAndSetWeaponGhostMaterial();
	void OnCustomizationReplicated();
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnRep_CustomizationPlayerState();
	void SetScalarParameterValueOnMeshFP(class FName InParameterName, float InValue);
	void SetScalarParameterValueOnMeshTP(class FName InParameterName, float InValue);
	void SetVectorParameterValueOnMeshFP(class FName InParameterName, const struct FLinearColor& InValue);
	void SetVectorParameterValueOnMeshTP(class FName InParameterName, const struct FLinearColor& InValue);
	void UpdateCharacterMaterial(bool bIsTimeGhost);
	void UpdateRagdollMaterial(bool bIsTimeGhost);

	class UMaterialInstanceDynamic* GetGhostMaterial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCharacterCustomizationComponent">();
	}
	static class UTWCharacterCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWCharacterCustomizationComponent>();
	}
};
static_assert(alignof(UTWCharacterCustomizationComponent) == 0x000008, "Wrong alignment on UTWCharacterCustomizationComponent");
static_assert(sizeof(UTWCharacterCustomizationComponent) == 0x0001E0, "Wrong size on UTWCharacterCustomizationComponent");
static_assert(offsetof(UTWCharacterCustomizationComponent, CustomizationPlayerState) == 0x0000B0, "Member 'UTWCharacterCustomizationComponent::CustomizationPlayerState' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, SelectedCharacterDataAsset) == 0x0000B8, "Member 'UTWCharacterCustomizationComponent::SelectedCharacterDataAsset' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, SelectedWeaponsDataAssets) == 0x0000C0, "Member 'UTWCharacterCustomizationComponent::SelectedWeaponsDataAssets' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, SelectedStyle) == 0x0000D0, "Member 'UTWCharacterCustomizationComponent::SelectedStyle' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, CustomizeGhostMaterial) == 0x0000D8, "Member 'UTWCharacterCustomizationComponent::CustomizeGhostMaterial' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, FPCharacterDynMatInstances) == 0x0000E8, "Member 'UTWCharacterCustomizationComponent::FPCharacterDynMatInstances' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, TPCharacterDynMatInstances) == 0x000138, "Member 'UTWCharacterCustomizationComponent::TPCharacterDynMatInstances' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, TPNextGhostMatInt) == 0x000188, "Member 'UTWCharacterCustomizationComponent::TPNextGhostMatInt' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, TPNextGhostDynMatInst) == 0x000190, "Member 'UTWCharacterCustomizationComponent::TPNextGhostDynMatInst' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, TPNotNextGhostMatInt) == 0x000198, "Member 'UTWCharacterCustomizationComponent::TPNotNextGhostMatInt' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, TPNotNextGhostDynMatInst) == 0x0001A0, "Member 'UTWCharacterCustomizationComponent::TPNotNextGhostDynMatInst' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, SpectatorGhostMatInt) == 0x0001A8, "Member 'UTWCharacterCustomizationComponent::SpectatorGhostMatInt' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, SpectatorGhostDynMatInst) == 0x0001B0, "Member 'UTWCharacterCustomizationComponent::SpectatorGhostDynMatInst' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, bAsyncLoadCompleted) == 0x0001B8, "Member 'UTWCharacterCustomizationComponent::bAsyncLoadCompleted' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, bCustomWeaponAssigned) == 0x0001B9, "Member 'UTWCharacterCustomizationComponent::bCustomWeaponAssigned' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, bAsyncLoadNotified) == 0x0001BA, "Member 'UTWCharacterCustomizationComponent::bAsyncLoadNotified' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, bIsRequestingAssetLoad) == 0x0001BB, "Member 'UTWCharacterCustomizationComponent::bIsRequestingAssetLoad' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, bIsGhostTime) == 0x0001BC, "Member 'UTWCharacterCustomizationComponent::bIsGhostTime' has a wrong offset!");
static_assert(offsetof(UTWCharacterCustomizationComponent, AssetCache) == 0x0001C0, "Member 'UTWCharacterCustomizationComponent::AssetCache' has a wrong offset!");

// Class TimeWatch.TWCharacterDataAsset
// 0x0170 (0x0230 - 0x00C0)
class UTWCharacterDataAsset final : public UTWItemDataAsset
{
public:
	struct FTWCharacterEntry                      CharacterEntry;                                    // 0x00C0(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTWCharacterSounds                     CharacterSounds;                                   // 0x0158(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FPlayerIntroData>               PlayerIntros;                                      // 0x0208(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTWStylesDataAsset*                     DefaultStyleDataAsset;                             // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWStylesDataAsset*>             AvailableStyles;                                   // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCharacterDataAsset">();
	}
	static class UTWCharacterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWCharacterDataAsset>();
	}
};
static_assert(alignof(UTWCharacterDataAsset) == 0x000008, "Wrong alignment on UTWCharacterDataAsset");
static_assert(sizeof(UTWCharacterDataAsset) == 0x000230, "Wrong size on UTWCharacterDataAsset");
static_assert(offsetof(UTWCharacterDataAsset, CharacterEntry) == 0x0000C0, "Member 'UTWCharacterDataAsset::CharacterEntry' has a wrong offset!");
static_assert(offsetof(UTWCharacterDataAsset, CharacterSounds) == 0x000158, "Member 'UTWCharacterDataAsset::CharacterSounds' has a wrong offset!");
static_assert(offsetof(UTWCharacterDataAsset, PlayerIntros) == 0x000208, "Member 'UTWCharacterDataAsset::PlayerIntros' has a wrong offset!");
static_assert(offsetof(UTWCharacterDataAsset, DefaultStyleDataAsset) == 0x000218, "Member 'UTWCharacterDataAsset::DefaultStyleDataAsset' has a wrong offset!");
static_assert(offsetof(UTWCharacterDataAsset, AvailableStyles) == 0x000220, "Member 'UTWCharacterDataAsset::AvailableStyles' has a wrong offset!");

// Class TimeWatch.TWCharacterGhost
// 0x0060 (0x0278 - 0x0218)
class ATWCharacterGhost : public AActor
{
public:
	float                                         ParadoxLifespan;                                   // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATWCharacterGhost* TWGhacrGhost, class ATimeWatchCharacter* TWMimicCharacter)> OnDestroyParadox; // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ATWCharacterGhost* TWGhacrGhost, class ATimeWatchCharacter* TWMimicCharacter)> OnGhostDisappear; // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CharacterMesh;                                     // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParadoxParticleSystem;                             // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCharacterGhostAnimInstance> AnimInstanceClass;                                // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsMarkedForRewindDestruction;                      // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0xF];                                      // 0x0261(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class ATimeWatchCharacter*                    CharacterToMimic;                                  // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Cosmetic_MimicCharacter(class ATimeWatchCharacter* Character);
	void DestroyParadox(bool bShouldDoAnimation);
	void MimicCharacter(class ATimeWatchCharacter* Character, bool SkipDestruction, bool bRealTime);
	void PerformDestroy(bool bShouldDoAnimation);
	void ResetCreationTime();
	void SetGhostLifespan(float DesiredLifespan);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCharacterGhost">();
	}
	static class ATWCharacterGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWCharacterGhost>();
	}
};
static_assert(alignof(ATWCharacterGhost) == 0x000008, "Wrong alignment on ATWCharacterGhost");
static_assert(sizeof(ATWCharacterGhost) == 0x000278, "Wrong size on ATWCharacterGhost");
static_assert(offsetof(ATWCharacterGhost, ParadoxLifespan) == 0x000218, "Member 'ATWCharacterGhost::ParadoxLifespan' has a wrong offset!");
static_assert(offsetof(ATWCharacterGhost, OnDestroyParadox) == 0x000220, "Member 'ATWCharacterGhost::OnDestroyParadox' has a wrong offset!");
static_assert(offsetof(ATWCharacterGhost, OnGhostDisappear) == 0x000230, "Member 'ATWCharacterGhost::OnGhostDisappear' has a wrong offset!");
static_assert(offsetof(ATWCharacterGhost, WeaponMesh) == 0x000240, "Member 'ATWCharacterGhost::WeaponMesh' has a wrong offset!");
static_assert(offsetof(ATWCharacterGhost, CharacterMesh) == 0x000248, "Member 'ATWCharacterGhost::CharacterMesh' has a wrong offset!");
static_assert(offsetof(ATWCharacterGhost, ParadoxParticleSystem) == 0x000250, "Member 'ATWCharacterGhost::ParadoxParticleSystem' has a wrong offset!");
static_assert(offsetof(ATWCharacterGhost, AnimInstanceClass) == 0x000258, "Member 'ATWCharacterGhost::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ATWCharacterGhost, IsMarkedForRewindDestruction) == 0x000260, "Member 'ATWCharacterGhost::IsMarkedForRewindDestruction' has a wrong offset!");
static_assert(offsetof(ATWCharacterGhost, CharacterToMimic) == 0x000270, "Member 'ATWCharacterGhost::CharacterToMimic' has a wrong offset!");

// Class TimeWatch.TWCloneOverheadWidget
// 0x0060 (0x02E0 - 0x0280)
class UTWCloneOverheadWidget : public UNGDUserWidget
{
public:
	float                                         HealthBarHeightForPlayer;                          // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarWidthForPlayer;                           // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarHeightForClone;                           // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarWidthForClone;                            // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloneInfoHeightForPlayer;                          // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloneInfoWidthForPlayer;                           // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloneInfoHeightForClone;                           // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloneInfoWidthForClone;                            // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_PlayerName;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWOverheadCloneInfoWidget*             OverheadCloneInfo;                                 // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWOverheadHealthBarWidget*             OverheadHealthBar;                                 // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_DisruptionVisionIcon;                        // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_CloneOverhead;                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox_HealthBar;                                 // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox_CloneInfo;                                 // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATimeWatchCharacter*                    Owner;                                             // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeWidget();
	void InitPlayerNameText();
	void SetCloneIconVisibility(ESlateVisibility NewVisibility);
	void SetCloneInfoScale(const struct FVector2D& NewScale);
	void SetCloneInfoText(int32 CloneIndex);
	void SetDisruptionVisionIconVisibility(ESlateVisibility NewVisibility);
	void SetHealthBarProgress(float ProgressValue);
	void SetHealthBarVisibility(ESlateVisibility NewVisibility);
	void SetHitFeedbackProgress(float ProgressValue);
	void SetOwner(class ATimeWatchCharacter* NewOwner);
	void TogglePlayerNameVisibility();
	void UpdatePlayerNameVisibilityFromCvar();
	void UpdateWidgetStyle(bool IsPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCloneOverheadWidget">();
	}
	static class UTWCloneOverheadWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWCloneOverheadWidget>();
	}
};
static_assert(alignof(UTWCloneOverheadWidget) == 0x000008, "Wrong alignment on UTWCloneOverheadWidget");
static_assert(sizeof(UTWCloneOverheadWidget) == 0x0002E0, "Wrong size on UTWCloneOverheadWidget");
static_assert(offsetof(UTWCloneOverheadWidget, HealthBarHeightForPlayer) == 0x000280, "Member 'UTWCloneOverheadWidget::HealthBarHeightForPlayer' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, HealthBarWidthForPlayer) == 0x000284, "Member 'UTWCloneOverheadWidget::HealthBarWidthForPlayer' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, HealthBarHeightForClone) == 0x000288, "Member 'UTWCloneOverheadWidget::HealthBarHeightForClone' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, HealthBarWidthForClone) == 0x00028C, "Member 'UTWCloneOverheadWidget::HealthBarWidthForClone' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, CloneInfoHeightForPlayer) == 0x000290, "Member 'UTWCloneOverheadWidget::CloneInfoHeightForPlayer' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, CloneInfoWidthForPlayer) == 0x000294, "Member 'UTWCloneOverheadWidget::CloneInfoWidthForPlayer' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, CloneInfoHeightForClone) == 0x000298, "Member 'UTWCloneOverheadWidget::CloneInfoHeightForClone' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, CloneInfoWidthForClone) == 0x00029C, "Member 'UTWCloneOverheadWidget::CloneInfoWidthForClone' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, Text_PlayerName) == 0x0002A0, "Member 'UTWCloneOverheadWidget::Text_PlayerName' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, OverheadCloneInfo) == 0x0002A8, "Member 'UTWCloneOverheadWidget::OverheadCloneInfo' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, OverheadHealthBar) == 0x0002B0, "Member 'UTWCloneOverheadWidget::OverheadHealthBar' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, Image_DisruptionVisionIcon) == 0x0002B8, "Member 'UTWCloneOverheadWidget::Image_DisruptionVisionIcon' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, VerticalBox_CloneOverhead) == 0x0002C0, "Member 'UTWCloneOverheadWidget::VerticalBox_CloneOverhead' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, SizeBox_HealthBar) == 0x0002C8, "Member 'UTWCloneOverheadWidget::SizeBox_HealthBar' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, SizeBox_CloneInfo) == 0x0002D0, "Member 'UTWCloneOverheadWidget::SizeBox_CloneInfo' has a wrong offset!");
static_assert(offsetof(UTWCloneOverheadWidget, Owner) == 0x0002D8, "Member 'UTWCloneOverheadWidget::Owner' has a wrong offset!");

// Class TimeWatch.TWClonesOnPointWidget
// 0x0098 (0x0318 - 0x0280)
class UTWClonesOnPointWidget : public UNGDUserWidget
{
public:
	class UHorizontalBox*                         HorizontalBox_LeftGroup;                           // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_RightGroup;                          // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PointAllied;                                 // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PointOpponent;                               // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PointEmpty;                                  // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Point;                                        // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWClonePointWidget>        ClonePointWidgetTemplate;                          // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     AlliedGradientMaterial;                            // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     OpponentGradientMaterial;                          // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     NeutralGradientMaterial;                           // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlotSizeX;                                         // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlotSizeY;                                         // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlotPadding;                                       // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NeutralPointColor;                                 // 0x02DC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NeutralTextColor;                                  // 0x02EC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTWClonePointWidget*>            ClonePoints;                                       // 0x0300(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AScoreAreaVolume*                       ScoreArea;                                         // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWClonesOnPointWidget">();
	}
	static class UTWClonesOnPointWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWClonesOnPointWidget>();
	}
};
static_assert(alignof(UTWClonesOnPointWidget) == 0x000008, "Wrong alignment on UTWClonesOnPointWidget");
static_assert(sizeof(UTWClonesOnPointWidget) == 0x000318, "Wrong size on UTWClonesOnPointWidget");
static_assert(offsetof(UTWClonesOnPointWidget, HorizontalBox_LeftGroup) == 0x000280, "Member 'UTWClonesOnPointWidget::HorizontalBox_LeftGroup' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, HorizontalBox_RightGroup) == 0x000288, "Member 'UTWClonesOnPointWidget::HorizontalBox_RightGroup' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, Image_PointAllied) == 0x000290, "Member 'UTWClonesOnPointWidget::Image_PointAllied' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, Image_PointOpponent) == 0x000298, "Member 'UTWClonesOnPointWidget::Image_PointOpponent' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, Image_PointEmpty) == 0x0002A0, "Member 'UTWClonesOnPointWidget::Image_PointEmpty' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, Text_Point) == 0x0002A8, "Member 'UTWClonesOnPointWidget::Text_Point' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, ClonePointWidgetTemplate) == 0x0002B0, "Member 'UTWClonesOnPointWidget::ClonePointWidgetTemplate' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, AlliedGradientMaterial) == 0x0002B8, "Member 'UTWClonesOnPointWidget::AlliedGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, OpponentGradientMaterial) == 0x0002C0, "Member 'UTWClonesOnPointWidget::OpponentGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, NeutralGradientMaterial) == 0x0002C8, "Member 'UTWClonesOnPointWidget::NeutralGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, SlotSizeX) == 0x0002D0, "Member 'UTWClonesOnPointWidget::SlotSizeX' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, SlotSizeY) == 0x0002D4, "Member 'UTWClonesOnPointWidget::SlotSizeY' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, SlotPadding) == 0x0002D8, "Member 'UTWClonesOnPointWidget::SlotPadding' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, NeutralPointColor) == 0x0002DC, "Member 'UTWClonesOnPointWidget::NeutralPointColor' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, NeutralTextColor) == 0x0002EC, "Member 'UTWClonesOnPointWidget::NeutralTextColor' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, ClonePoints) == 0x000300, "Member 'UTWClonesOnPointWidget::ClonePoints' has a wrong offset!");
static_assert(offsetof(UTWClonesOnPointWidget, ScoreArea) == 0x000310, "Member 'UTWClonesOnPointWidget::ScoreArea' has a wrong offset!");

// Class TimeWatch.TWChromaColorSchemeDataAsset
// 0x0080 (0x00B0 - 0x0030)
class UTWChromaColorSchemeDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FLinearColor>        ActionColorMap;                                    // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         KeyboardBackgroundAnimName;                        // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         ChromaLinkBackgroundAnimName;                      // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         MouseBackgroundAnimName;                           // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWChromaColorSchemeDataAsset">();
	}
	static class UTWChromaColorSchemeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWChromaColorSchemeDataAsset>();
	}
};
static_assert(alignof(UTWChromaColorSchemeDataAsset) == 0x000008, "Wrong alignment on UTWChromaColorSchemeDataAsset");
static_assert(sizeof(UTWChromaColorSchemeDataAsset) == 0x0000B0, "Wrong size on UTWChromaColorSchemeDataAsset");
static_assert(offsetof(UTWChromaColorSchemeDataAsset, ActionColorMap) == 0x000030, "Member 'UTWChromaColorSchemeDataAsset::ActionColorMap' has a wrong offset!");
static_assert(offsetof(UTWChromaColorSchemeDataAsset, KeyboardBackgroundAnimName) == 0x000080, "Member 'UTWChromaColorSchemeDataAsset::KeyboardBackgroundAnimName' has a wrong offset!");
static_assert(offsetof(UTWChromaColorSchemeDataAsset, ChromaLinkBackgroundAnimName) == 0x000090, "Member 'UTWChromaColorSchemeDataAsset::ChromaLinkBackgroundAnimName' has a wrong offset!");
static_assert(offsetof(UTWChromaColorSchemeDataAsset, MouseBackgroundAnimName) == 0x0000A0, "Member 'UTWChromaColorSchemeDataAsset::MouseBackgroundAnimName' has a wrong offset!");

// Class TimeWatch.TWColorSchemeDataAsset
// 0x0428 (0x0458 - 0x0030)
class UTWColorSchemeDataAsset final : public UDataAsset
{
public:
	struct FGameplayColorScheme                   ColorScheme;                                       // 0x0030(0x0428)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWColorSchemeDataAsset">();
	}
	static class UTWColorSchemeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWColorSchemeDataAsset>();
	}
};
static_assert(alignof(UTWColorSchemeDataAsset) == 0x000008, "Wrong alignment on UTWColorSchemeDataAsset");
static_assert(sizeof(UTWColorSchemeDataAsset) == 0x000458, "Wrong size on UTWColorSchemeDataAsset");
static_assert(offsetof(UTWColorSchemeDataAsset, ColorScheme) == 0x000030, "Member 'UTWColorSchemeDataAsset::ColorScheme' has a wrong offset!");

// Class TimeWatch.TWDamageableActor
// 0x0040 (0x0258 - 0x0218)
class ATWDamageableActor : public AActor
{
public:
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      RewindCollider;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HitRegistrationCollider;                           // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDRewindComponent*                    RewindComponent;                                   // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDPostUpdateWorkComponent*            NGDPostUpdateWorkComponent;                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         Mesh;                                              // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDMortalityComponent*                 MortalityComponent;                                // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnDeath(const struct FNGDDamageEvent& DamageEvent, class AController* InstigatorController, class AActor* DamageCauser);
	float BP_OnTakeDamage(float Damage, const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void MulticastOnDeath(const struct FNGDDamageEvent& DamageEvent, class ANGDCharacter* EventInstigator, class AActor* DamageCauser);
	void OnDeath(const struct FNGDDamageEvent& DamageEvent, class AController* InstigatorController, class AActor* DamageCauser);
	void OnPostUpdateWorkTick();
	float OnTakeDamage(float Damage, const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void SetHealth(const float NewHealth);

	class UCapsuleComponent* GetHitRegistrationCollider() const;
	class UNGDMortalityComponent* GetMortalityComponent() const;
	class UMeshComponent* GetRewindableMeshComponent() const;
	class UCapsuleComponent* GetRewindCollider() const;
	class UNGDRewindComponent* GetRewindComponent() const;
	bool IsRewindRelevant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWDamageableActor">();
	}
	static class ATWDamageableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWDamageableActor>();
	}
};
static_assert(alignof(ATWDamageableActor) == 0x000008, "Wrong alignment on ATWDamageableActor");
static_assert(sizeof(ATWDamageableActor) == 0x000258, "Wrong size on ATWDamageableActor");
static_assert(offsetof(ATWDamageableActor, RewindCollider) == 0x000228, "Member 'ATWDamageableActor::RewindCollider' has a wrong offset!");
static_assert(offsetof(ATWDamageableActor, HitRegistrationCollider) == 0x000230, "Member 'ATWDamageableActor::HitRegistrationCollider' has a wrong offset!");
static_assert(offsetof(ATWDamageableActor, RewindComponent) == 0x000238, "Member 'ATWDamageableActor::RewindComponent' has a wrong offset!");
static_assert(offsetof(ATWDamageableActor, NGDPostUpdateWorkComponent) == 0x000240, "Member 'ATWDamageableActor::NGDPostUpdateWorkComponent' has a wrong offset!");
static_assert(offsetof(ATWDamageableActor, Mesh) == 0x000248, "Member 'ATWDamageableActor::Mesh' has a wrong offset!");
static_assert(offsetof(ATWDamageableActor, MortalityComponent) == 0x000250, "Member 'ATWDamageableActor::MortalityComponent' has a wrong offset!");

// Class TimeWatch.TWDeathMatchGameState
// 0x0018 (0x07A0 - 0x0788)
class ATWDeathMatchGameState final : public ATimeWatchGameState
{
public:
	TMulticastInlineDelegate<void()>              OnLeadingTeamChanged;                              // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         LeadingTeamID;                                     // 0x0798(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79C[0x4];                                      // 0x079C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnRep_LeadingTeamID();

	int32 GetDeathClonesCount() const;
	int32 GetLeadingTeamID() const;
	int32 GetTeamDeathClonesCount(int32 TeamId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWDeathMatchGameState">();
	}
	static class ATWDeathMatchGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWDeathMatchGameState>();
	}
};
static_assert(alignof(ATWDeathMatchGameState) == 0x000008, "Wrong alignment on ATWDeathMatchGameState");
static_assert(sizeof(ATWDeathMatchGameState) == 0x0007A0, "Wrong size on ATWDeathMatchGameState");
static_assert(offsetof(ATWDeathMatchGameState, OnLeadingTeamChanged) == 0x000788, "Member 'ATWDeathMatchGameState::OnLeadingTeamChanged' has a wrong offset!");
static_assert(offsetof(ATWDeathMatchGameState, LeadingTeamID) == 0x000798, "Member 'ATWDeathMatchGameState::LeadingTeamID' has a wrong offset!");

// Class TimeWatch.TWDeathMatchScoreWidget
// 0x0070 (0x02F0 - 0x0280)
class UTWDeathMatchScoreWidget : public UNGDUserWidget
{
public:
	struct FLinearColor                           BackgroundScoreColor;                              // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockedOpacity;                                     // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LeftGradientMaterial;                              // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     RightGradientMaterial;                             // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftFill;                                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightFill;                                   // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_Left;                                      // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_Right;                                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x20];                                     // 0x02C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EDMScoreState                                 LastScoreState;                                    // 0x02E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWDeathMatchScoreWidget">();
	}
	static class UTWDeathMatchScoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWDeathMatchScoreWidget>();
	}
};
static_assert(alignof(UTWDeathMatchScoreWidget) == 0x000008, "Wrong alignment on UTWDeathMatchScoreWidget");
static_assert(sizeof(UTWDeathMatchScoreWidget) == 0x0002F0, "Wrong size on UTWDeathMatchScoreWidget");
static_assert(offsetof(UTWDeathMatchScoreWidget, BackgroundScoreColor) == 0x000280, "Member 'UTWDeathMatchScoreWidget::BackgroundScoreColor' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchScoreWidget, LockedOpacity) == 0x000290, "Member 'UTWDeathMatchScoreWidget::LockedOpacity' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchScoreWidget, LeftGradientMaterial) == 0x000298, "Member 'UTWDeathMatchScoreWidget::LeftGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchScoreWidget, RightGradientMaterial) == 0x0002A0, "Member 'UTWDeathMatchScoreWidget::RightGradientMaterial' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchScoreWidget, Image_LeftFill) == 0x0002A8, "Member 'UTWDeathMatchScoreWidget::Image_LeftFill' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchScoreWidget, Image_RightFill) == 0x0002B0, "Member 'UTWDeathMatchScoreWidget::Image_RightFill' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchScoreWidget, Overlay_Left) == 0x0002B8, "Member 'UTWDeathMatchScoreWidget::Overlay_Left' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchScoreWidget, Overlay_Right) == 0x0002C0, "Member 'UTWDeathMatchScoreWidget::Overlay_Right' has a wrong offset!");
static_assert(offsetof(UTWDeathMatchScoreWidget, LastScoreState) == 0x0002E8, "Member 'UTWDeathMatchScoreWidget::LastScoreState' has a wrong offset!");

// Class TimeWatch.TWKillFromPastEvent
// 0x0000 (0x0048 - 0x0048)
class UTWKillFromPastEvent final : public UTWKillEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWKillFromPastEvent">();
	}
	static class UTWKillFromPastEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWKillFromPastEvent>();
	}
};
static_assert(alignof(UTWKillFromPastEvent) == 0x000008, "Wrong alignment on UTWKillFromPastEvent");
static_assert(sizeof(UTWKillFromPastEvent) == 0x000048, "Wrong size on UTWKillFromPastEvent");

// Class TimeWatch.TWCloseRangeKill
// 0x0000 (0x0048 - 0x0048)
class UTWCloseRangeKill final : public UTWKillEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCloseRangeKill">();
	}
	static class UTWCloseRangeKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWCloseRangeKill>();
	}
};
static_assert(alignof(UTWCloseRangeKill) == 0x000008, "Wrong alignment on UTWCloseRangeKill");
static_assert(sizeof(UTWCloseRangeKill) == 0x000048, "Wrong size on UTWCloseRangeKill");

// Class TimeWatch.TWBarrelKill
// 0x0000 (0x0048 - 0x0048)
class UTWBarrelKill final : public UTWKillEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWBarrelKill">();
	}
	static class UTWBarrelKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWBarrelKill>();
	}
};
static_assert(alignof(UTWBarrelKill) == 0x000008, "Wrong alignment on UTWBarrelKill");
static_assert(sizeof(UTWBarrelKill) == 0x000048, "Wrong size on UTWBarrelKill");

// Class TimeWatch.TWKillForKillfeedEvent
// 0x0008 (0x0050 - 0x0048)
class UTWKillForKillfeedEvent final : public UTWKillEvent
{
public:
	bool                                          bWasPrefiredBoosted;                               // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWKillForKillfeedEvent">();
	}
	static class UTWKillForKillfeedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWKillForKillfeedEvent>();
	}
};
static_assert(alignof(UTWKillForKillfeedEvent) == 0x000008, "Wrong alignment on UTWKillForKillfeedEvent");
static_assert(sizeof(UTWKillForKillfeedEvent) == 0x000050, "Wrong size on UTWKillForKillfeedEvent");
static_assert(offsetof(UTWKillForKillfeedEvent, bWasPrefiredBoosted) == 0x000048, "Member 'UTWKillForKillfeedEvent::bWasPrefiredBoosted' has a wrong offset!");

// Class TimeWatch.TWScoreEvent
// 0x0000 (0x0038 - 0x0038)
class UTWScoreEvent final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWScoreEvent">();
	}
	static class UTWScoreEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWScoreEvent>();
	}
};
static_assert(alignof(UTWScoreEvent) == 0x000008, "Wrong alignment on UTWScoreEvent");
static_assert(sizeof(UTWScoreEvent) == 0x000038, "Wrong size on UTWScoreEvent");

// Class TimeWatch.TWWinEvent
// 0x0000 (0x0038 - 0x0038)
class UTWWinEvent final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWWinEvent">();
	}
	static class UTWWinEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWWinEvent>();
	}
};
static_assert(alignof(UTWWinEvent) == 0x000008, "Wrong alignment on UTWWinEvent");
static_assert(sizeof(UTWWinEvent) == 0x000038, "Wrong size on UTWWinEvent");

// Class TimeWatch.TWMatchPointEvent
// 0x0000 (0x0038 - 0x0038)
class UTWMatchPointEvent final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWMatchPointEvent">();
	}
	static class UTWMatchPointEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWMatchPointEvent>();
	}
};
static_assert(alignof(UTWMatchPointEvent) == 0x000008, "Wrong alignment on UTWMatchPointEvent");
static_assert(sizeof(UTWMatchPointEvent) == 0x000038, "Wrong size on UTWMatchPointEvent");

// Class TimeWatch.TWFirstCycleStart
// 0x0000 (0x0038 - 0x0038)
class UTWFirstCycleStart final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWFirstCycleStart">();
	}
	static class UTWFirstCycleStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWFirstCycleStart>();
	}
};
static_assert(alignof(UTWFirstCycleStart) == 0x000008, "Wrong alignment on UTWFirstCycleStart");
static_assert(sizeof(UTWFirstCycleStart) == 0x000038, "Wrong size on UTWFirstCycleStart");

// Class TimeWatch.TWNonScoringRound
// 0x0000 (0x0038 - 0x0038)
class UTWNonScoringRound final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWNonScoringRound">();
	}
	static class UTWNonScoringRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWNonScoringRound>();
	}
};
static_assert(alignof(UTWNonScoringRound) == 0x000008, "Wrong alignment on UTWNonScoringRound");
static_assert(sizeof(UTWNonScoringRound) == 0x000038, "Wrong size on UTWNonScoringRound");

// Class TimeWatch.TWAttemptToScoreEvent
// 0x0000 (0x0038 - 0x0038)
class UTWAttemptToScoreEvent final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWAttemptToScoreEvent">();
	}
	static class UTWAttemptToScoreEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWAttemptToScoreEvent>();
	}
};
static_assert(alignof(UTWAttemptToScoreEvent) == 0x000008, "Wrong alignment on UTWAttemptToScoreEvent");
static_assert(sizeof(UTWAttemptToScoreEvent) == 0x000038, "Wrong size on UTWAttemptToScoreEvent");

// Class TimeWatch.TWTeamKillEvent
// 0x0000 (0x0038 - 0x0038)
class UTWTeamKillEvent final : public UTimeWatchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTeamKillEvent">();
	}
	static class UTWTeamKillEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTeamKillEvent>();
	}
};
static_assert(alignof(UTWTeamKillEvent) == 0x000008, "Wrong alignment on UTWTeamKillEvent");
static_assert(sizeof(UTWTeamKillEvent) == 0x000038, "Wrong size on UTWTeamKillEvent");

// Class TimeWatch.TWFriendRowWidget
// 0x0068 (0x02E8 - 0x0280)
class UTWFriendRowWidget : public UNGDUserWidget
{
public:
	float                                         RowWidth;                                          // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RowHeight;                                         // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& FriendID, const class FString& FriendName)> OnFriendRowButtonClicked; // 0x0288(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0298(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 UserName;                                          // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             Text_PlayerName;                                   // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_RowButton;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Portrait;                                    // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFriendButtonClicked();
	void SetFriendData();
	void SetPlayer(const class FString& InUserID, const class FString& InUserName);

	class FString GetUserName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWFriendRowWidget">();
	}
	static class UTWFriendRowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWFriendRowWidget>();
	}
};
static_assert(alignof(UTWFriendRowWidget) == 0x000008, "Wrong alignment on UTWFriendRowWidget");
static_assert(sizeof(UTWFriendRowWidget) == 0x0002E8, "Wrong size on UTWFriendRowWidget");
static_assert(offsetof(UTWFriendRowWidget, RowWidth) == 0x000280, "Member 'UTWFriendRowWidget::RowWidth' has a wrong offset!");
static_assert(offsetof(UTWFriendRowWidget, RowHeight) == 0x000284, "Member 'UTWFriendRowWidget::RowHeight' has a wrong offset!");
static_assert(offsetof(UTWFriendRowWidget, OnFriendRowButtonClicked) == 0x000288, "Member 'UTWFriendRowWidget::OnFriendRowButtonClicked' has a wrong offset!");
static_assert(offsetof(UTWFriendRowWidget, UserId) == 0x000298, "Member 'UTWFriendRowWidget::UserId' has a wrong offset!");
static_assert(offsetof(UTWFriendRowWidget, UserName) == 0x0002A8, "Member 'UTWFriendRowWidget::UserName' has a wrong offset!");
static_assert(offsetof(UTWFriendRowWidget, Text_PlayerName) == 0x0002C8, "Member 'UTWFriendRowWidget::Text_PlayerName' has a wrong offset!");
static_assert(offsetof(UTWFriendRowWidget, Button_RowButton) == 0x0002D0, "Member 'UTWFriendRowWidget::Button_RowButton' has a wrong offset!");
static_assert(offsetof(UTWFriendRowWidget, Image_Portrait) == 0x0002D8, "Member 'UTWFriendRowWidget::Image_Portrait' has a wrong offset!");

// Class TimeWatch.TWGameGlobals
// 0x0258 (0x0280 - 0x0028)
class UTWGameGlobals : public UObject
{
public:
	TSubclassOf<class ATimeWatchHUD>              ReplayHUDClass;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FChallengeData>    ChallengesData;                                    // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PlayerIntroDebuggerClass;                          // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGameModeType, struct FGameModeData>     GameModesData;                                     // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, ETWLocalizedLanguage>     LocalizedLanguages;                                // 0x00D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EQuickChatCategory, struct FTWQuickChatEntries> QuickChatEntries;                           // 0x0128(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCharacterAbilitiesData> CharacterAbilitiesData;                      // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCharacterAbilitiesData> CharacterPassiveAbilitiesData;               // 0x01C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UTWLevelEntry>>      PlayableLevelEntryClasses;                         // 0x0218(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWLevelEntry>              DefaultLevelEntryClass;                            // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoadingScreenMinimumTime;                          // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CharacterSelectionScreenTime;                      // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CharacterSelectionCatchupTime;                     // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LevelToUnlockRanked;                               // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           TipsList;                                          // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ForwardTimeDilationCurve;                          // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RewindTimeDilationCurve;                           // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardTimeDilationLenght;                         // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RewindTimeDilationLenght;                          // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayedMapsWeightReduction;                         // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATWBaseMatchIntroActor>     MatchIntroClass;                                   // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWReverseSoundsDataAsset*              ReverseSoundsConfig;                               // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<class UTWLevelEntry*> GetAllLevelEntries() const;
	TArray<class UTWLevelEntry*> GetAllPlayableChallengeLevels(bool IncludeDevelopment) const;
	TArray<class UTWLevelEntry*> GetAllPlayableLevelEntries(ETWMatchType MatchType, bool IncludeDevelopmentLevels) const;
	TArray<class FText> GetTipsList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameGlobals">();
	}
	static class UTWGameGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGameGlobals>();
	}
};
static_assert(alignof(UTWGameGlobals) == 0x000008, "Wrong alignment on UTWGameGlobals");
static_assert(sizeof(UTWGameGlobals) == 0x000280, "Wrong size on UTWGameGlobals");
static_assert(offsetof(UTWGameGlobals, ReplayHUDClass) == 0x000028, "Member 'UTWGameGlobals::ReplayHUDClass' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, ChallengesData) == 0x000030, "Member 'UTWGameGlobals::ChallengesData' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, PlayerIntroDebuggerClass) == 0x000080, "Member 'UTWGameGlobals::PlayerIntroDebuggerClass' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, GameModesData) == 0x000088, "Member 'UTWGameGlobals::GameModesData' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, LocalizedLanguages) == 0x0000D8, "Member 'UTWGameGlobals::LocalizedLanguages' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, QuickChatEntries) == 0x000128, "Member 'UTWGameGlobals::QuickChatEntries' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, CharacterAbilitiesData) == 0x000178, "Member 'UTWGameGlobals::CharacterAbilitiesData' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, CharacterPassiveAbilitiesData) == 0x0001C8, "Member 'UTWGameGlobals::CharacterPassiveAbilitiesData' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, PlayableLevelEntryClasses) == 0x000218, "Member 'UTWGameGlobals::PlayableLevelEntryClasses' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, DefaultLevelEntryClass) == 0x000228, "Member 'UTWGameGlobals::DefaultLevelEntryClass' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, LoadingScreenMinimumTime) == 0x000230, "Member 'UTWGameGlobals::LoadingScreenMinimumTime' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, CharacterSelectionScreenTime) == 0x000234, "Member 'UTWGameGlobals::CharacterSelectionScreenTime' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, CharacterSelectionCatchupTime) == 0x000238, "Member 'UTWGameGlobals::CharacterSelectionCatchupTime' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, LevelToUnlockRanked) == 0x00023C, "Member 'UTWGameGlobals::LevelToUnlockRanked' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, TipsList) == 0x000240, "Member 'UTWGameGlobals::TipsList' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, ForwardTimeDilationCurve) == 0x000250, "Member 'UTWGameGlobals::ForwardTimeDilationCurve' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, RewindTimeDilationCurve) == 0x000258, "Member 'UTWGameGlobals::RewindTimeDilationCurve' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, ForwardTimeDilationLenght) == 0x000260, "Member 'UTWGameGlobals::ForwardTimeDilationLenght' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, RewindTimeDilationLenght) == 0x000264, "Member 'UTWGameGlobals::RewindTimeDilationLenght' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, PlayedMapsWeightReduction) == 0x000268, "Member 'UTWGameGlobals::PlayedMapsWeightReduction' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, MatchIntroClass) == 0x000270, "Member 'UTWGameGlobals::MatchIntroClass' has a wrong offset!");
static_assert(offsetof(UTWGameGlobals, ReverseSoundsConfig) == 0x000278, "Member 'UTWGameGlobals::ReverseSoundsConfig' has a wrong offset!");

// Class TimeWatch.TWGameplayAbilityTargetActor_Trace
// 0x0028 (0x02A0 - 0x0278)
class ATWGameplayAbilityTargetActor_Trace final : public ATWGameplayAbilityTargetActor
{
public:
	struct FTWGameplayTargetDataFilterHandle      Filter;                                            // 0x0278(0x0010)(BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReticleOffset;                                     // 0x028C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceAffectsAimPitch;                             // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AimWithPlayerController(struct FHitResult* OutHitResult, bool bIgnorePitch, bool bTraceComplex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayAbilityTargetActor_Trace">();
	}
	static class ATWGameplayAbilityTargetActor_Trace* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWGameplayAbilityTargetActor_Trace>();
	}
};
static_assert(alignof(ATWGameplayAbilityTargetActor_Trace) == 0x000008, "Wrong alignment on ATWGameplayAbilityTargetActor_Trace");
static_assert(sizeof(ATWGameplayAbilityTargetActor_Trace) == 0x0002A0, "Wrong size on ATWGameplayAbilityTargetActor_Trace");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Trace, Filter) == 0x000278, "Member 'ATWGameplayAbilityTargetActor_Trace::Filter' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Trace, MaxRange) == 0x000288, "Member 'ATWGameplayAbilityTargetActor_Trace::MaxRange' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Trace, ReticleOffset) == 0x00028C, "Member 'ATWGameplayAbilityTargetActor_Trace::ReticleOffset' has a wrong offset!");
static_assert(offsetof(ATWGameplayAbilityTargetActor_Trace, bTraceAffectsAimPitch) == 0x000298, "Member 'ATWGameplayAbilityTargetActor_Trace::bTraceAffectsAimPitch' has a wrong offset!");

// Class TimeWatch.TWGameplayTask_SpawnProjectile
// 0x0068 (0x00E0 - 0x0078)
class alignas(0x10) UTWGameplayTask_SpawnProjectile final : public UTWGameplayTask
{
public:
	TMulticastInlineDelegate<void(const struct FHitResult& HitResult)> ProjectileHit;                // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x48];                                      // 0x0088(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ATWPhysicalProjectile*                  SpawnedProjectile;                                 // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTWGameplayTask_SpawnProjectile* SpawnProjectile(class UTWAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class ATWPhysicalProjectile> Class_0, const struct FTransform& InSpawnTransform, float LaunchSpeed, int32 TaskID);

	bool BeginSpawningActor(class UTWAbility* OwningAbility, TSubclassOf<class ATWPhysicalProjectile> Class_0, class ATWPhysicalProjectile** SpawnedActor);
	void FinishSpawningActor(class UTWAbility* OwningAbility, class ATWPhysicalProjectile* SpawnedActor);
	void OnProjectileHit(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameplayTask_SpawnProjectile">();
	}
	static class UTWGameplayTask_SpawnProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGameplayTask_SpawnProjectile>();
	}
};
static_assert(alignof(UTWGameplayTask_SpawnProjectile) == 0x000010, "Wrong alignment on UTWGameplayTask_SpawnProjectile");
static_assert(sizeof(UTWGameplayTask_SpawnProjectile) == 0x0000E0, "Wrong size on UTWGameplayTask_SpawnProjectile");
static_assert(offsetof(UTWGameplayTask_SpawnProjectile, ProjectileHit) == 0x000078, "Member 'UTWGameplayTask_SpawnProjectile::ProjectileHit' has a wrong offset!");
static_assert(offsetof(UTWGameplayTask_SpawnProjectile, SpawnedProjectile) == 0x0000D0, "Member 'UTWGameplayTask_SpawnProjectile::SpawnedProjectile' has a wrong offset!");

// Class TimeWatch.TWGameViewportClient
// 0x0008 (0x02F0 - 0x02E8)
class UTWGameViewportClient final : public UNGDGameViewportClient
{
public:
	class UTWStandardButtonWidget*                LastFocusedTWButton;                               // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGameViewportClient">();
	}
	static class UTWGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWGameViewportClient>();
	}
};
static_assert(alignof(UTWGameViewportClient) == 0x000008, "Wrong alignment on UTWGameViewportClient");
static_assert(sizeof(UTWGameViewportClient) == 0x0002F0, "Wrong size on UTWGameViewportClient");
static_assert(offsetof(UTWGameViewportClient, LastFocusedTWButton) == 0x0002E8, "Member 'UTWGameViewportClient::LastFocusedTWButton' has a wrong offset!");

// Class TimeWatch.TWGhostBase
// 0x0000 (0x0218 - 0x0218)
class ATWGhostBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWGhostBase">();
	}
	static class ATWGhostBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWGhostBase>();
	}
};
static_assert(alignof(ATWGhostBase) == 0x000008, "Wrong alignment on ATWGhostBase");
static_assert(sizeof(ATWGhostBase) == 0x000218, "Wrong size on ATWGhostBase");

// Class TimeWatch.TWHUDFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTWHUDFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float ConvertLvlToXP(float InLevel);
	static int32 ConvertXPToLevel(float InXP);
	static void FindScreenEdgeLocationForWorldLocation(class UObject* WorldContextObject, const struct FVector& WorldLocation, const struct FVector2D& Padding, const struct FVector2D& WidgetSize, const struct FRotator& CameraRotator, struct FVector2D* OutScreenPosition, float* OutRotationAngleDegrees, bool* bIsOnScreen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWHUDFunctionLibrary">();
	}
	static class UTWHUDFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWHUDFunctionLibrary>();
	}
};
static_assert(alignof(UTWHUDFunctionLibrary) == 0x000008, "Wrong alignment on UTWHUDFunctionLibrary");
static_assert(sizeof(UTWHUDFunctionLibrary) == 0x000028, "Wrong size on UTWHUDFunctionLibrary");

// Class TimeWatch.TWImagePopupHudState
// 0x0000 (0x0270 - 0x0270)
class UTWImagePopupHudState : public UNGDPopupHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWImagePopupHudState">();
	}
	static class UTWImagePopupHudState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWImagePopupHudState>();
	}
};
static_assert(alignof(UTWImagePopupHudState) == 0x000008, "Wrong alignment on UTWImagePopupHudState");
static_assert(sizeof(UTWImagePopupHudState) == 0x000270, "Wrong size on UTWImagePopupHudState");

// Class TimeWatch.TWInteractableRewindableComponent
// 0x0020 (0x0430 - 0x0410)
class UTWInteractableRewindableComponent final : public UTWInteractableComponent
{
public:
	TMulticastInlineDelegate<void()>              OnReset;                                           // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsUndoable;                                       // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWInteractableTimeline*                Timeline;                                          // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWInteractableRewindableComponent">();
	}
	static class UTWInteractableRewindableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWInteractableRewindableComponent>();
	}
};
static_assert(alignof(UTWInteractableRewindableComponent) == 0x000010, "Wrong alignment on UTWInteractableRewindableComponent");
static_assert(sizeof(UTWInteractableRewindableComponent) == 0x000430, "Wrong size on UTWInteractableRewindableComponent");
static_assert(offsetof(UTWInteractableRewindableComponent, OnReset) == 0x000410, "Member 'UTWInteractableRewindableComponent::OnReset' has a wrong offset!");
static_assert(offsetof(UTWInteractableRewindableComponent, bIsUndoable) == 0x000420, "Member 'UTWInteractableRewindableComponent::bIsUndoable' has a wrong offset!");
static_assert(offsetof(UTWInteractableRewindableComponent, Timeline) == 0x000428, "Member 'UTWInteractableRewindableComponent::Timeline' has a wrong offset!");

// Class TimeWatch.TWInteractionComponent
// 0x0000 (0x0400 - 0x0400)
class UTWInteractionComponent final : public UCapsuleComponent
{
public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWInteractionComponent">();
	}
	static class UTWInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWInteractionComponent>();
	}
};
static_assert(alignof(UTWInteractionComponent) == 0x000010, "Wrong alignment on UTWInteractionComponent");
static_assert(sizeof(UTWInteractionComponent) == 0x000400, "Wrong size on UTWInteractionComponent");

// Class TimeWatch.TWJumpModifierActor
// 0x0000 (0x0218 - 0x0218)
class ATWJumpModifierActor final : public AActor
{
public:
	void OnTriggered(const class AActor* TriggeredBy);

	struct FJumpModifier GetJumpModifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWJumpModifierActor">();
	}
	static class ATWJumpModifierActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWJumpModifierActor>();
	}
};
static_assert(alignof(ATWJumpModifierActor) == 0x000008, "Wrong alignment on ATWJumpModifierActor");
static_assert(sizeof(ATWJumpModifierActor) == 0x000218, "Wrong size on ATWJumpModifierActor");

// Class TimeWatch.TWLeaderboardRowWidget
// 0x0118 (0x0398 - 0x0280)
class UTWLeaderboardRowWidget : public UNGDUserWidget
{
public:
	struct FRowFieldProperties                    TitleRowProperties;                                // 0x0280(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             RowUserBG;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             RowYouBG;                                          // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             UsernameOverlayTexture;                            // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_RowBox;                              // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_BackgroundImage;                             // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            TopEntryFontColor;                                 // 0x0330(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         UsernameMaxLength;                                 // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x3C];                                     // 0x035C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLeaderboardRowWidget">();
	}
	static class UTWLeaderboardRowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLeaderboardRowWidget>();
	}
};
static_assert(alignof(UTWLeaderboardRowWidget) == 0x000008, "Wrong alignment on UTWLeaderboardRowWidget");
static_assert(sizeof(UTWLeaderboardRowWidget) == 0x000398, "Wrong size on UTWLeaderboardRowWidget");
static_assert(offsetof(UTWLeaderboardRowWidget, TitleRowProperties) == 0x000280, "Member 'UTWLeaderboardRowWidget::TitleRowProperties' has a wrong offset!");
static_assert(offsetof(UTWLeaderboardRowWidget, RowUserBG) == 0x000308, "Member 'UTWLeaderboardRowWidget::RowUserBG' has a wrong offset!");
static_assert(offsetof(UTWLeaderboardRowWidget, RowYouBG) == 0x000310, "Member 'UTWLeaderboardRowWidget::RowYouBG' has a wrong offset!");
static_assert(offsetof(UTWLeaderboardRowWidget, UsernameOverlayTexture) == 0x000318, "Member 'UTWLeaderboardRowWidget::UsernameOverlayTexture' has a wrong offset!");
static_assert(offsetof(UTWLeaderboardRowWidget, HorizontalBox_RowBox) == 0x000320, "Member 'UTWLeaderboardRowWidget::HorizontalBox_RowBox' has a wrong offset!");
static_assert(offsetof(UTWLeaderboardRowWidget, Image_BackgroundImage) == 0x000328, "Member 'UTWLeaderboardRowWidget::Image_BackgroundImage' has a wrong offset!");
static_assert(offsetof(UTWLeaderboardRowWidget, TopEntryFontColor) == 0x000330, "Member 'UTWLeaderboardRowWidget::TopEntryFontColor' has a wrong offset!");
static_assert(offsetof(UTWLeaderboardRowWidget, UsernameMaxLength) == 0x000358, "Member 'UTWLeaderboardRowWidget::UsernameMaxLength' has a wrong offset!");

// Class TimeWatch.TWLeagueStatusItemWidget
// 0x0020 (0x02A0 - 0x0280)
class UTWLeagueStatusItemWidget : public UNGDUserWidget
{
public:
	float                                         MaxPlayerNameTextSizeX;                            // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             Text_PlayerPosition;                               // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PlayerName;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLeagueStatusItemWidget">();
	}
	static class UTWLeagueStatusItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLeagueStatusItemWidget>();
	}
};
static_assert(alignof(UTWLeagueStatusItemWidget) == 0x000008, "Wrong alignment on UTWLeagueStatusItemWidget");
static_assert(sizeof(UTWLeagueStatusItemWidget) == 0x0002A0, "Wrong size on UTWLeagueStatusItemWidget");
static_assert(offsetof(UTWLeagueStatusItemWidget, MaxPlayerNameTextSizeX) == 0x000280, "Member 'UTWLeagueStatusItemWidget::MaxPlayerNameTextSizeX' has a wrong offset!");
static_assert(offsetof(UTWLeagueStatusItemWidget, Text_PlayerPosition) == 0x000288, "Member 'UTWLeagueStatusItemWidget::Text_PlayerPosition' has a wrong offset!");
static_assert(offsetof(UTWLeagueStatusItemWidget, Text_PlayerName) == 0x000290, "Member 'UTWLeagueStatusItemWidget::Text_PlayerName' has a wrong offset!");

// Class TimeWatch.TWLevelEntry
// 0x0128 (0x0150 - 0x0028)
class UTWLevelEntry : public UObject
{
public:
	class FString                                 LevelIdentifierName;                               // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FriendlyName;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Asset;                                             // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             LoadingScreenBackgroundTexture;                    // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CustomMatchThumbnailTexture;                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CharacterSelectionBackgroundTexture;               // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   GamemodeFriendlyName;                              // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             GameModeIcon;                                      // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   GameModeExplanation;                               // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          IsDevelopmentLevel;                                // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AllowedMatchTypes;                                 // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchSettings                         DefaultSettings;                                   // 0x00D0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FWeaponLoadoutEntry                    WeaponLoadoutOverride;                             // 0x0110(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShouldShowTips;                                   // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReplayBeRecorded;                              // 0x0131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchmakingWeight;                                 // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInGameTutorialTips;                         // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATWTutorialTooltipManager>  OptionalTooltipManagerOverride;                    // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCharacterSelection;                           // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLevelEntry">();
	}
	static class UTWLevelEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLevelEntry>();
	}
};
static_assert(alignof(UTWLevelEntry) == 0x000008, "Wrong alignment on UTWLevelEntry");
static_assert(sizeof(UTWLevelEntry) == 0x000150, "Wrong size on UTWLevelEntry");
static_assert(offsetof(UTWLevelEntry, LevelIdentifierName) == 0x000028, "Member 'UTWLevelEntry::LevelIdentifierName' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, FriendlyName) == 0x000038, "Member 'UTWLevelEntry::FriendlyName' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, Asset) == 0x000050, "Member 'UTWLevelEntry::Asset' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, LoadingScreenBackgroundTexture) == 0x000078, "Member 'UTWLevelEntry::LoadingScreenBackgroundTexture' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, CustomMatchThumbnailTexture) == 0x000080, "Member 'UTWLevelEntry::CustomMatchThumbnailTexture' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, CharacterSelectionBackgroundTexture) == 0x000088, "Member 'UTWLevelEntry::CharacterSelectionBackgroundTexture' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, GamemodeFriendlyName) == 0x000090, "Member 'UTWLevelEntry::GamemodeFriendlyName' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, GameModeIcon) == 0x0000A8, "Member 'UTWLevelEntry::GameModeIcon' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, GameModeExplanation) == 0x0000B0, "Member 'UTWLevelEntry::GameModeExplanation' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, IsDevelopmentLevel) == 0x0000C8, "Member 'UTWLevelEntry::IsDevelopmentLevel' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, AllowedMatchTypes) == 0x0000C9, "Member 'UTWLevelEntry::AllowedMatchTypes' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, DefaultSettings) == 0x0000D0, "Member 'UTWLevelEntry::DefaultSettings' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, WeaponLoadoutOverride) == 0x000110, "Member 'UTWLevelEntry::WeaponLoadoutOverride' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, bShouldShowTips) == 0x000130, "Member 'UTWLevelEntry::bShouldShowTips' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, bCanReplayBeRecorded) == 0x000131, "Member 'UTWLevelEntry::bCanReplayBeRecorded' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, MatchmakingWeight) == 0x000134, "Member 'UTWLevelEntry::MatchmakingWeight' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, bEnableInGameTutorialTips) == 0x000138, "Member 'UTWLevelEntry::bEnableInGameTutorialTips' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, OptionalTooltipManagerOverride) == 0x000140, "Member 'UTWLevelEntry::OptionalTooltipManagerOverride' has a wrong offset!");
static_assert(offsetof(UTWLevelEntry, bSkipCharacterSelection) == 0x000148, "Member 'UTWLevelEntry::bSkipCharacterSelection' has a wrong offset!");

// Class TimeWatch.TWLinearCrosshairWidget
// 0x0070 (0x0300 - 0x0290)
class UTWLinearCrosshairWidget : public UNGDCrosshairWidget
{
public:
	class UImage*                                 Image_Top;                                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Right;                                       // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Bottom;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Left;                                        // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_ADSCrosshair;                          // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_MainCrosshair;                         // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ADSCrosshair;                                // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SpreadCrosshairAmplitud;                           // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWColorSchemeDataAsset*                ColorSchemeDataAsset;                              // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWeaponSpread;                                   // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWeaponSpread;                                   // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCenterTranslationOffset;                        // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCenterTranslationOffset;                        // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HittedFeedbackMinScale;                            // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HittedFeedbackMaxScale;                            // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HittedFeedbackScaleRiseFactor;                     // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HittedFeedbackScaleDecayFactor;                    // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentHittedFeedbackScale;                        // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsCrosshairDynamic();
	void OnADSComplete();
	void OnADSEnter();
	void OnADSExit();
	void OnADSStartExit();
	void ShowHitFeedback(const struct FLinearColor& HitColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLinearCrosshairWidget">();
	}
	static class UTWLinearCrosshairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLinearCrosshairWidget>();
	}
};
static_assert(alignof(UTWLinearCrosshairWidget) == 0x000008, "Wrong alignment on UTWLinearCrosshairWidget");
static_assert(sizeof(UTWLinearCrosshairWidget) == 0x000300, "Wrong size on UTWLinearCrosshairWidget");
static_assert(offsetof(UTWLinearCrosshairWidget, Image_Top) == 0x000290, "Member 'UTWLinearCrosshairWidget::Image_Top' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, Image_Right) == 0x000298, "Member 'UTWLinearCrosshairWidget::Image_Right' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, Image_Bottom) == 0x0002A0, "Member 'UTWLinearCrosshairWidget::Image_Bottom' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, Image_Left) == 0x0002A8, "Member 'UTWLinearCrosshairWidget::Image_Left' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, CanvasPanel_ADSCrosshair) == 0x0002B0, "Member 'UTWLinearCrosshairWidget::CanvasPanel_ADSCrosshair' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, CanvasPanel_MainCrosshair) == 0x0002B8, "Member 'UTWLinearCrosshairWidget::CanvasPanel_MainCrosshair' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, Image_ADSCrosshair) == 0x0002C0, "Member 'UTWLinearCrosshairWidget::Image_ADSCrosshair' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, SpreadCrosshairAmplitud) == 0x0002C8, "Member 'UTWLinearCrosshairWidget::SpreadCrosshairAmplitud' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, ColorSchemeDataAsset) == 0x0002D0, "Member 'UTWLinearCrosshairWidget::ColorSchemeDataAsset' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, MinWeaponSpread) == 0x0002D8, "Member 'UTWLinearCrosshairWidget::MinWeaponSpread' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, MaxWeaponSpread) == 0x0002DC, "Member 'UTWLinearCrosshairWidget::MaxWeaponSpread' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, MinCenterTranslationOffset) == 0x0002E0, "Member 'UTWLinearCrosshairWidget::MinCenterTranslationOffset' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, MaxCenterTranslationOffset) == 0x0002E4, "Member 'UTWLinearCrosshairWidget::MaxCenterTranslationOffset' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, HittedFeedbackMinScale) == 0x0002E8, "Member 'UTWLinearCrosshairWidget::HittedFeedbackMinScale' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, HittedFeedbackMaxScale) == 0x0002EC, "Member 'UTWLinearCrosshairWidget::HittedFeedbackMaxScale' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, HittedFeedbackScaleRiseFactor) == 0x0002F0, "Member 'UTWLinearCrosshairWidget::HittedFeedbackScaleRiseFactor' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, HittedFeedbackScaleDecayFactor) == 0x0002F4, "Member 'UTWLinearCrosshairWidget::HittedFeedbackScaleDecayFactor' has a wrong offset!");
static_assert(offsetof(UTWLinearCrosshairWidget, CurrentHittedFeedbackScale) == 0x0002F8, "Member 'UTWLinearCrosshairWidget::CurrentHittedFeedbackScale' has a wrong offset!");

// Class TimeWatch.TWLinearHealthBar
// 0x0110 (0x0390 - 0x0280)
class UTWLinearHealthBar : public UNGDUserWidget
{
public:
	struct FWidgetColorStructure                  HealthBarColors;                                   // 0x0280(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Image_BackgroundCeldedBar;                         // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_BackgroundLinearBar;                         // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_LinearBackgroundBar;                   // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_CeldedBackgroundBar;                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_CeldedTopBar;                          // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_LinearTopBar;                          // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_Celded;                                // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_Linear;                                // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CeldedHealthBarBaseMaterial;                       // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     LinearHealthBarBaseMaterial;                       // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeWidget(const struct FWidgetColorStructure& NewHealthBarColors);
	void SetActiveHealthBar(bool bIsPlayer);
	void SetHealthBarPercentValue(float Value);
	void SetHitFeedbackPercentValue(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLinearHealthBar">();
	}
	static class UTWLinearHealthBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLinearHealthBar>();
	}
};
static_assert(alignof(UTWLinearHealthBar) == 0x000008, "Wrong alignment on UTWLinearHealthBar");
static_assert(sizeof(UTWLinearHealthBar) == 0x000390, "Wrong size on UTWLinearHealthBar");
static_assert(offsetof(UTWLinearHealthBar, HealthBarColors) == 0x000280, "Member 'UTWLinearHealthBar::HealthBarColors' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, Image_BackgroundCeldedBar) == 0x000340, "Member 'UTWLinearHealthBar::Image_BackgroundCeldedBar' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, Image_BackgroundLinearBar) == 0x000348, "Member 'UTWLinearHealthBar::Image_BackgroundLinearBar' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, ProgressBar_LinearBackgroundBar) == 0x000350, "Member 'UTWLinearHealthBar::ProgressBar_LinearBackgroundBar' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, ProgressBar_CeldedBackgroundBar) == 0x000358, "Member 'UTWLinearHealthBar::ProgressBar_CeldedBackgroundBar' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, ProgressBar_CeldedTopBar) == 0x000360, "Member 'UTWLinearHealthBar::ProgressBar_CeldedTopBar' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, ProgressBar_LinearTopBar) == 0x000368, "Member 'UTWLinearHealthBar::ProgressBar_LinearTopBar' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, CanvasPanel_Celded) == 0x000370, "Member 'UTWLinearHealthBar::CanvasPanel_Celded' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, CanvasPanel_Linear) == 0x000378, "Member 'UTWLinearHealthBar::CanvasPanel_Linear' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, CeldedHealthBarBaseMaterial) == 0x000380, "Member 'UTWLinearHealthBar::CeldedHealthBarBaseMaterial' has a wrong offset!");
static_assert(offsetof(UTWLinearHealthBar, LinearHealthBarBaseMaterial) == 0x000388, "Member 'UTWLinearHealthBar::LinearHealthBarBaseMaterial' has a wrong offset!");

// Class TimeWatch.TWLoadingScreenWidget
// 0x0078 (0x02F8 - 0x0280)
class UTWLoadingScreenWidget : public UNGDUserWidget
{
public:
	class UImage*                                 Image_BackgroundImage;                             // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_GameModeTitle;                           // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_LevelName;                               // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ExplanationText;                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_TipText;                                 // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_QueueType;                               // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_GameModeIcon;                                // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_TipsCanvas;                            // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_GameModeInfo;                          // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWMatchQueuesDataAsset*                MatchQueuesDataAsset;                              // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   QueueTypeText;                                     // 0x02D0(0x0018)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLoadingScreenWidget">();
	}
	static class UTWLoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLoadingScreenWidget>();
	}
};
static_assert(alignof(UTWLoadingScreenWidget) == 0x000008, "Wrong alignment on UTWLoadingScreenWidget");
static_assert(sizeof(UTWLoadingScreenWidget) == 0x0002F8, "Wrong size on UTWLoadingScreenWidget");
static_assert(offsetof(UTWLoadingScreenWidget, Image_BackgroundImage) == 0x000280, "Member 'UTWLoadingScreenWidget::Image_BackgroundImage' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, TextBlock_GameModeTitle) == 0x000288, "Member 'UTWLoadingScreenWidget::TextBlock_GameModeTitle' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, TextBlock_LevelName) == 0x000290, "Member 'UTWLoadingScreenWidget::TextBlock_LevelName' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, TextBlock_ExplanationText) == 0x000298, "Member 'UTWLoadingScreenWidget::TextBlock_ExplanationText' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, TextBlock_TipText) == 0x0002A0, "Member 'UTWLoadingScreenWidget::TextBlock_TipText' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, TextBlock_QueueType) == 0x0002A8, "Member 'UTWLoadingScreenWidget::TextBlock_QueueType' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, Image_GameModeIcon) == 0x0002B0, "Member 'UTWLoadingScreenWidget::Image_GameModeIcon' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, CanvasPanel_TipsCanvas) == 0x0002B8, "Member 'UTWLoadingScreenWidget::CanvasPanel_TipsCanvas' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, CanvasPanel_GameModeInfo) == 0x0002C0, "Member 'UTWLoadingScreenWidget::CanvasPanel_GameModeInfo' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, MatchQueuesDataAsset) == 0x0002C8, "Member 'UTWLoadingScreenWidget::MatchQueuesDataAsset' has a wrong offset!");
static_assert(offsetof(UTWLoadingScreenWidget, QueueTypeText) == 0x0002D0, "Member 'UTWLoadingScreenWidget::QueueTypeText' has a wrong offset!");

// Class TimeWatch.TWLobbyGridPanelWidget
// 0x0020 (0x02A0 - 0x0280)
class UTWLobbyGridPanelWidget final : public UNGDUserWidget
{
public:
	class UGridPanel*                             GridPanel_MainGrid;                                // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           VerticalBox_FirstColumn;                           // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           VerticalBox_SecondColumn;                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           VerticalBox_ThirdColumn;                           // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UVerticalBox* GetGridColumnByIndex(int32 ColumnIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLobbyGridPanelWidget">();
	}
	static class UTWLobbyGridPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLobbyGridPanelWidget>();
	}
};
static_assert(alignof(UTWLobbyGridPanelWidget) == 0x000008, "Wrong alignment on UTWLobbyGridPanelWidget");
static_assert(sizeof(UTWLobbyGridPanelWidget) == 0x0002A0, "Wrong size on UTWLobbyGridPanelWidget");
static_assert(offsetof(UTWLobbyGridPanelWidget, GridPanel_MainGrid) == 0x000280, "Member 'UTWLobbyGridPanelWidget::GridPanel_MainGrid' has a wrong offset!");
static_assert(offsetof(UTWLobbyGridPanelWidget, VerticalBox_FirstColumn) == 0x000288, "Member 'UTWLobbyGridPanelWidget::VerticalBox_FirstColumn' has a wrong offset!");
static_assert(offsetof(UTWLobbyGridPanelWidget, VerticalBox_SecondColumn) == 0x000290, "Member 'UTWLobbyGridPanelWidget::VerticalBox_SecondColumn' has a wrong offset!");
static_assert(offsetof(UTWLobbyGridPanelWidget, VerticalBox_ThirdColumn) == 0x000298, "Member 'UTWLobbyGridPanelWidget::VerticalBox_ThirdColumn' has a wrong offset!");

// Class TimeWatch.TWLobbyPlayerRowWidget
// 0x0038 (0x02B8 - 0x0280)
class UTWLobbyPlayerRowWidget final : public UNGDUserWidget
{
public:
	class UTWLobbyGridPanelWidget*                MainGrid;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0288(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 UserName;                                          // 0x0298(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PlayerName;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWLobbyChallengeWidget*                Owner;                                             // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetPlayer(const class FString& InUserID, const class FString& InUserName, class UTWLobbyChallengeWidget* InOwner);

	class FString GetUserName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLobbyPlayerRowWidget">();
	}
	static class UTWLobbyPlayerRowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLobbyPlayerRowWidget>();
	}
};
static_assert(alignof(UTWLobbyPlayerRowWidget) == 0x000008, "Wrong alignment on UTWLobbyPlayerRowWidget");
static_assert(sizeof(UTWLobbyPlayerRowWidget) == 0x0002B8, "Wrong size on UTWLobbyPlayerRowWidget");
static_assert(offsetof(UTWLobbyPlayerRowWidget, MainGrid) == 0x000280, "Member 'UTWLobbyPlayerRowWidget::MainGrid' has a wrong offset!");
static_assert(offsetof(UTWLobbyPlayerRowWidget, UserId) == 0x000288, "Member 'UTWLobbyPlayerRowWidget::UserId' has a wrong offset!");
static_assert(offsetof(UTWLobbyPlayerRowWidget, UserName) == 0x000298, "Member 'UTWLobbyPlayerRowWidget::UserName' has a wrong offset!");
static_assert(offsetof(UTWLobbyPlayerRowWidget, Text_PlayerName) == 0x0002A8, "Member 'UTWLobbyPlayerRowWidget::Text_PlayerName' has a wrong offset!");
static_assert(offsetof(UTWLobbyPlayerRowWidget, Owner) == 0x0002B0, "Member 'UTWLobbyPlayerRowWidget::Owner' has a wrong offset!");

// Class TimeWatch.TWLoopIndicatorWidget
// 0x0030 (0x02B0 - 0x0280)
class UTWLoopIndicatorWidget final : public UNGDUserWidget
{
public:
	class UTextBlock*                             Text_LoopName;                                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Background;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         LoopsNames;                                        // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         PastLoopIndicatorOpacity;                          // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FutureLoopIndicatorOpacity;                        // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentLoopIndicatorOpacity;                       // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWLoopIndicatorWidget">();
	}
	static class UTWLoopIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWLoopIndicatorWidget>();
	}
};
static_assert(alignof(UTWLoopIndicatorWidget) == 0x000008, "Wrong alignment on UTWLoopIndicatorWidget");
static_assert(sizeof(UTWLoopIndicatorWidget) == 0x0002B0, "Wrong size on UTWLoopIndicatorWidget");
static_assert(offsetof(UTWLoopIndicatorWidget, Text_LoopName) == 0x000280, "Member 'UTWLoopIndicatorWidget::Text_LoopName' has a wrong offset!");
static_assert(offsetof(UTWLoopIndicatorWidget, Image_Background) == 0x000288, "Member 'UTWLoopIndicatorWidget::Image_Background' has a wrong offset!");
static_assert(offsetof(UTWLoopIndicatorWidget, LoopsNames) == 0x000290, "Member 'UTWLoopIndicatorWidget::LoopsNames' has a wrong offset!");
static_assert(offsetof(UTWLoopIndicatorWidget, PastLoopIndicatorOpacity) == 0x0002A0, "Member 'UTWLoopIndicatorWidget::PastLoopIndicatorOpacity' has a wrong offset!");
static_assert(offsetof(UTWLoopIndicatorWidget, FutureLoopIndicatorOpacity) == 0x0002A4, "Member 'UTWLoopIndicatorWidget::FutureLoopIndicatorOpacity' has a wrong offset!");
static_assert(offsetof(UTWLoopIndicatorWidget, CurrentLoopIndicatorOpacity) == 0x0002A8, "Member 'UTWLoopIndicatorWidget::CurrentLoopIndicatorOpacity' has a wrong offset!");

// Class TimeWatch.TWMatchIntensityHandle
// 0x0050 (0x0100 - 0x00B0)
class UTWMatchIntensityHandle final : public UActorComponent
{
public:
	TMap<TSubclassOf<class UTimeWatchEvent>, struct FTWCrowdReactionConfig> CrowdReactionSettings;   // 0x00B0(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWMatchIntensityHandle">();
	}
	static class UTWMatchIntensityHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWMatchIntensityHandle>();
	}
};
static_assert(alignof(UTWMatchIntensityHandle) == 0x000008, "Wrong alignment on UTWMatchIntensityHandle");
static_assert(sizeof(UTWMatchIntensityHandle) == 0x000100, "Wrong size on UTWMatchIntensityHandle");
static_assert(offsetof(UTWMatchIntensityHandle, CrowdReactionSettings) == 0x0000B0, "Member 'UTWMatchIntensityHandle::CrowdReactionSettings' has a wrong offset!");

// Class TimeWatch.TWMatchQueuesDataAsset
// 0x0098 (0x00C8 - 0x0030)
class UTWMatchQueuesDataAsset final : public UDataAsset
{
public:
	TMap<ETWMatchType, struct FMatchOptionData>   MatchQueuesData;                                   // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Text_Generic1v1;                                   // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Text_Generic2v2;                                   // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Text_Singleplayer;                                 // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWMatchQueuesDataAsset">();
	}
	static class UTWMatchQueuesDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWMatchQueuesDataAsset>();
	}
};
static_assert(alignof(UTWMatchQueuesDataAsset) == 0x000008, "Wrong alignment on UTWMatchQueuesDataAsset");
static_assert(sizeof(UTWMatchQueuesDataAsset) == 0x0000C8, "Wrong size on UTWMatchQueuesDataAsset");
static_assert(offsetof(UTWMatchQueuesDataAsset, MatchQueuesData) == 0x000030, "Member 'UTWMatchQueuesDataAsset::MatchQueuesData' has a wrong offset!");
static_assert(offsetof(UTWMatchQueuesDataAsset, Text_Generic1v1) == 0x000080, "Member 'UTWMatchQueuesDataAsset::Text_Generic1v1' has a wrong offset!");
static_assert(offsetof(UTWMatchQueuesDataAsset, Text_Generic2v2) == 0x000098, "Member 'UTWMatchQueuesDataAsset::Text_Generic2v2' has a wrong offset!");
static_assert(offsetof(UTWMatchQueuesDataAsset, Text_Singleplayer) == 0x0000B0, "Member 'UTWMatchQueuesDataAsset::Text_Singleplayer' has a wrong offset!");

// Class TimeWatch.TWMusicActor
// 0x0000 (0x0218 - 0x0218)
class ATWMusicActor final : public AActor
{
public:
	void BP_SetMusicLoop(int32 LoopIndex);
	void SetMusicLoop(int32 LoopIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWMusicActor">();
	}
	static class ATWMusicActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWMusicActor>();
	}
};
static_assert(alignof(ATWMusicActor) == 0x000008, "Wrong alignment on ATWMusicActor");
static_assert(sizeof(ATWMusicActor) == 0x000218, "Wrong size on ATWMusicActor");

// Class TimeWatch.TWOnlineBeaconHostRouter
// 0x0008 (0x0258 - 0x0250)
class ATWOnlineBeaconHostRouter final : public ANGDOnlineBeaconHostRouter
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWOnlineBeaconHostRouter">();
	}
	static class ATWOnlineBeaconHostRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWOnlineBeaconHostRouter>();
	}
};
static_assert(alignof(ATWOnlineBeaconHostRouter) == 0x000008, "Wrong alignment on ATWOnlineBeaconHostRouter");
static_assert(sizeof(ATWOnlineBeaconHostRouter) == 0x000258, "Wrong size on ATWOnlineBeaconHostRouter");

// Class TimeWatch.TWOverheadCloneInfoWidget
// 0x0078 (0x02F8 - 0x0280)
class UTWOverheadCloneInfoWidget : public UNGDUserWidget
{
public:
	class UImage*                                 Image_Outline_Clone;                               // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CloneColor;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CloneNumber;                                 // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_PlayerInfoOverlay;                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UTexture2D*>                CloneIndexTextures;                                // 0x02A0(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ATimeWatchCharacter*                    Owner;                                             // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeWidget();
	void SetCloneColorVisibility(ESlateVisibility NewVisibility);
	void SetCloneIndexText(int32 CloneIndex);
	void SetOwner(class ATimeWatchCharacter* NewOwner);
	void SetPlayerInfoOverlayScale(const struct FVector2D& NewScale);
	void UpdateWidgetStyle(bool IsPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWOverheadCloneInfoWidget">();
	}
	static class UTWOverheadCloneInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWOverheadCloneInfoWidget>();
	}
};
static_assert(alignof(UTWOverheadCloneInfoWidget) == 0x000008, "Wrong alignment on UTWOverheadCloneInfoWidget");
static_assert(sizeof(UTWOverheadCloneInfoWidget) == 0x0002F8, "Wrong size on UTWOverheadCloneInfoWidget");
static_assert(offsetof(UTWOverheadCloneInfoWidget, Image_Outline_Clone) == 0x000280, "Member 'UTWOverheadCloneInfoWidget::Image_Outline_Clone' has a wrong offset!");
static_assert(offsetof(UTWOverheadCloneInfoWidget, Image_CloneColor) == 0x000288, "Member 'UTWOverheadCloneInfoWidget::Image_CloneColor' has a wrong offset!");
static_assert(offsetof(UTWOverheadCloneInfoWidget, Image_CloneNumber) == 0x000290, "Member 'UTWOverheadCloneInfoWidget::Image_CloneNumber' has a wrong offset!");
static_assert(offsetof(UTWOverheadCloneInfoWidget, Overlay_PlayerInfoOverlay) == 0x000298, "Member 'UTWOverheadCloneInfoWidget::Overlay_PlayerInfoOverlay' has a wrong offset!");
static_assert(offsetof(UTWOverheadCloneInfoWidget, CloneIndexTextures) == 0x0002A0, "Member 'UTWOverheadCloneInfoWidget::CloneIndexTextures' has a wrong offset!");
static_assert(offsetof(UTWOverheadCloneInfoWidget, Owner) == 0x0002F0, "Member 'UTWOverheadCloneInfoWidget::Owner' has a wrong offset!");

// Class TimeWatch.TWPlayableCharacterData
// 0x0020 (0x0050 - 0x0030)
class UTWPlayableCharacterData final : public UDataAsset
{
public:
	class FString                                 ServerOwnership;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UIDisplayName;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ANGDCharacter>              CharacterClass;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlayableCharacterData">();
	}
	static class UTWPlayableCharacterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPlayableCharacterData>();
	}
};
static_assert(alignof(UTWPlayableCharacterData) == 0x000008, "Wrong alignment on UTWPlayableCharacterData");
static_assert(sizeof(UTWPlayableCharacterData) == 0x000050, "Wrong size on UTWPlayableCharacterData");
static_assert(offsetof(UTWPlayableCharacterData, ServerOwnership) == 0x000030, "Member 'UTWPlayableCharacterData::ServerOwnership' has a wrong offset!");
static_assert(offsetof(UTWPlayableCharacterData, UIDisplayName) == 0x000040, "Member 'UTWPlayableCharacterData::UIDisplayName' has a wrong offset!");
static_assert(offsetof(UTWPlayableCharacterData, CharacterClass) == 0x000048, "Member 'UTWPlayableCharacterData::CharacterClass' has a wrong offset!");

// Class TimeWatch.TWPlayerCameraManager
// 0x06D0 (0x2DA0 - 0x26D0)
class ATWPlayerCameraManager : public ANGDPlayerCameraManager
{
public:
	uint8                                         Pad_26D0[0x10];                                    // 0x26D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloneTransitionTime;                               // 0x26E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26E4[0x4];                                     // 0x26E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FadeFullCurve;                                     // 0x26E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            FadeHalfCurve;                                     // 0x26F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionProgressToUnposses;                      // 0x26F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FadeColor;                                         // 0x26FC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathFadeDuration;                                 // 0x270C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DeathFadeCurve;                                    // 0x2710(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CustomFadeDuration;                                // 0x2718(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271C[0x4];                                     // 0x271C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPostProcessType, TSubclassOf<class UNGDCameraModifier>> CameraModifierMap;                 // 0x2720(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ACameraTransitionPoint*                 PointReplayPOV;                                    // 0x2770(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATimeWatchCharacter*                    NextClone;                                         // 0x2778(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MPC_ExhibitionMode;                                // 0x2780(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2788[0x600];                                   // 0x2788(0x0600)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomFadeCurve;                                   // 0x2D88(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D90[0x10];                                    // 0x2D90(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDefaultFOV(float NewFloat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlayerCameraManager">();
	}
	static class ATWPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWPlayerCameraManager>();
	}
};
static_assert(alignof(ATWPlayerCameraManager) == 0x000010, "Wrong alignment on ATWPlayerCameraManager");
static_assert(sizeof(ATWPlayerCameraManager) == 0x002DA0, "Wrong size on ATWPlayerCameraManager");
static_assert(offsetof(ATWPlayerCameraManager, CloneTransitionTime) == 0x0026E0, "Member 'ATWPlayerCameraManager::CloneTransitionTime' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, FadeFullCurve) == 0x0026E8, "Member 'ATWPlayerCameraManager::FadeFullCurve' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, FadeHalfCurve) == 0x0026F0, "Member 'ATWPlayerCameraManager::FadeHalfCurve' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, TransitionProgressToUnposses) == 0x0026F8, "Member 'ATWPlayerCameraManager::TransitionProgressToUnposses' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, FadeColor) == 0x0026FC, "Member 'ATWPlayerCameraManager::FadeColor' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, DeathFadeDuration) == 0x00270C, "Member 'ATWPlayerCameraManager::DeathFadeDuration' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, DeathFadeCurve) == 0x002710, "Member 'ATWPlayerCameraManager::DeathFadeCurve' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, CustomFadeDuration) == 0x002718, "Member 'ATWPlayerCameraManager::CustomFadeDuration' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, CameraModifierMap) == 0x002720, "Member 'ATWPlayerCameraManager::CameraModifierMap' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, PointReplayPOV) == 0x002770, "Member 'ATWPlayerCameraManager::PointReplayPOV' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, NextClone) == 0x002778, "Member 'ATWPlayerCameraManager::NextClone' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, MPC_ExhibitionMode) == 0x002780, "Member 'ATWPlayerCameraManager::MPC_ExhibitionMode' has a wrong offset!");
static_assert(offsetof(ATWPlayerCameraManager, CustomFadeCurve) == 0x002D88, "Member 'ATWPlayerCameraManager::CustomFadeCurve' has a wrong offset!");

// Class TimeWatch.TWPlayerIntroActor
// 0x00D8 (0x0380 - 0x02A8)
class ATWPlayerIntroActor final : public ALevelSequenceActor
{
public:
	class AFluxPlayerState*                       OwningPlayer;                                      // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debug_CharIndex;                                   // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnIntroCompleted;                                  // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNGDAkComponent*                        NGDAk_PlayerIntro;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        SoundConfig_IntroStart;                            // 0x02D0(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        SoundConfig_IntroEnd;                              // 0x0328(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void BP_StartIntro(class USkeletalMesh* ActiveMesh, const TArray<class UMaterialInterface*>& ActiveMaterials, class ATWMatchIntroActor* MatchIntro);
	void Cosmetic_SetVisibility(bool bNewVisibility);
	void EndIntro();
	void OverrideBindings();
	void StartIntro(class ATWMatchIntroActor* Owning_MatchIntro);

	int32 GetPlayerID() const;
	int32 GetTeamId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlayerIntroActor">();
	}
	static class ATWPlayerIntroActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWPlayerIntroActor>();
	}
};
static_assert(alignof(ATWPlayerIntroActor) == 0x000008, "Wrong alignment on ATWPlayerIntroActor");
static_assert(sizeof(ATWPlayerIntroActor) == 0x000380, "Wrong size on ATWPlayerIntroActor");
static_assert(offsetof(ATWPlayerIntroActor, OwningPlayer) == 0x0002A8, "Member 'ATWPlayerIntroActor::OwningPlayer' has a wrong offset!");
static_assert(offsetof(ATWPlayerIntroActor, Debug_CharIndex) == 0x0002B0, "Member 'ATWPlayerIntroActor::Debug_CharIndex' has a wrong offset!");
static_assert(offsetof(ATWPlayerIntroActor, OnIntroCompleted) == 0x0002B8, "Member 'ATWPlayerIntroActor::OnIntroCompleted' has a wrong offset!");
static_assert(offsetof(ATWPlayerIntroActor, NGDAk_PlayerIntro) == 0x0002C8, "Member 'ATWPlayerIntroActor::NGDAk_PlayerIntro' has a wrong offset!");
static_assert(offsetof(ATWPlayerIntroActor, SoundConfig_IntroStart) == 0x0002D0, "Member 'ATWPlayerIntroActor::SoundConfig_IntroStart' has a wrong offset!");
static_assert(offsetof(ATWPlayerIntroActor, SoundConfig_IntroEnd) == 0x000328, "Member 'ATWPlayerIntroActor::SoundConfig_IntroEnd' has a wrong offset!");

// Class TimeWatch.TWPlayerSkipConfirmation
// 0x0030 (0x02B0 - 0x0280)
class UTWPlayerSkipConfirmation : public UNGDUserWidget
{
public:
	class APlayerState*                           OwningPlayerState;                                 // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_PlayerName;                              // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           RemoteColor;                                       // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           LocalColor;                                        // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class APlayerState* GetOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPlayerSkipConfirmation">();
	}
	static class UTWPlayerSkipConfirmation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPlayerSkipConfirmation>();
	}
};
static_assert(alignof(UTWPlayerSkipConfirmation) == 0x000008, "Wrong alignment on UTWPlayerSkipConfirmation");
static_assert(sizeof(UTWPlayerSkipConfirmation) == 0x0002B0, "Wrong size on UTWPlayerSkipConfirmation");
static_assert(offsetof(UTWPlayerSkipConfirmation, OwningPlayerState) == 0x000280, "Member 'UTWPlayerSkipConfirmation::OwningPlayerState' has a wrong offset!");
static_assert(offsetof(UTWPlayerSkipConfirmation, TextBlock_PlayerName) == 0x000288, "Member 'UTWPlayerSkipConfirmation::TextBlock_PlayerName' has a wrong offset!");
static_assert(offsetof(UTWPlayerSkipConfirmation, RemoteColor) == 0x000290, "Member 'UTWPlayerSkipConfirmation::RemoteColor' has a wrong offset!");
static_assert(offsetof(UTWPlayerSkipConfirmation, LocalColor) == 0x0002A0, "Member 'UTWPlayerSkipConfirmation::LocalColor' has a wrong offset!");

// Class TimeWatch.TWPopupButton
// 0x0008 (0x0268 - 0x0260)
class UTWPopupButton : public UNGDPopupButton
{
public:
	class UTWStandardButtonWidget*                Button_StandardCallBack;                           // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPopupButton">();
	}
	static class UTWPopupButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPopupButton>();
	}
};
static_assert(alignof(UTWPopupButton) == 0x000008, "Wrong alignment on UTWPopupButton");
static_assert(sizeof(UTWPopupButton) == 0x000268, "Wrong size on UTWPopupButton");
static_assert(offsetof(UTWPopupButton, Button_StandardCallBack) == 0x000260, "Member 'UTWPopupButton::Button_StandardCallBack' has a wrong offset!");

// Class TimeWatch.TWPremiumPopup
// 0x0010 (0x07D8 - 0x07C8)
class UTWPremiumPopup : public UTWGenericPopup
{
public:
	class UTextBlock*                             TextBlock_Description;                             // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PopupImage;                                  // 0x07D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWPremiumPopup">();
	}
	static class UTWPremiumPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWPremiumPopup>();
	}
};
static_assert(alignof(UTWPremiumPopup) == 0x000008, "Wrong alignment on UTWPremiumPopup");
static_assert(sizeof(UTWPremiumPopup) == 0x0007D8, "Wrong size on UTWPremiumPopup");
static_assert(offsetof(UTWPremiumPopup, TextBlock_Description) == 0x0007C8, "Member 'UTWPremiumPopup::TextBlock_Description' has a wrong offset!");
static_assert(offsetof(UTWPremiumPopup, Image_PopupImage) == 0x0007D0, "Member 'UTWPremiumPopup::Image_PopupImage' has a wrong offset!");

// Class TimeWatch.TWProjectileGhost
// 0x00A0 (0x02B8 - 0x0218)
class ATWProjectileGhost final : public AActor
{
public:
	uint8                                         Pad_218[0x50];                                     // 0x0218(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATWExplosionGhost>          ExplosionGhostClass;                               // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWExplosionGhost*                      ExplosionGhost;                                    // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ProjectileRoot;                                    // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ProjectileMesh;                                    // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParadoxParticleSystem;                             // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               Trail;                                             // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_Setup(class ATimeWatchCharacter* InstigatorCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWProjectileGhost">();
	}
	static class ATWProjectileGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWProjectileGhost>();
	}
};
static_assert(alignof(ATWProjectileGhost) == 0x000008, "Wrong alignment on ATWProjectileGhost");
static_assert(sizeof(ATWProjectileGhost) == 0x0002B8, "Wrong size on ATWProjectileGhost");
static_assert(offsetof(ATWProjectileGhost, ExplosionGhostClass) == 0x000268, "Member 'ATWProjectileGhost::ExplosionGhostClass' has a wrong offset!");
static_assert(offsetof(ATWProjectileGhost, ExplosionGhost) == 0x000270, "Member 'ATWProjectileGhost::ExplosionGhost' has a wrong offset!");
static_assert(offsetof(ATWProjectileGhost, ProjectileRoot) == 0x000278, "Member 'ATWProjectileGhost::ProjectileRoot' has a wrong offset!");
static_assert(offsetof(ATWProjectileGhost, ProjectileMesh) == 0x000280, "Member 'ATWProjectileGhost::ProjectileMesh' has a wrong offset!");
static_assert(offsetof(ATWProjectileGhost, ParadoxParticleSystem) == 0x000288, "Member 'ATWProjectileGhost::ParadoxParticleSystem' has a wrong offset!");
static_assert(offsetof(ATWProjectileGhost, Trail) == 0x000290, "Member 'ATWProjectileGhost::Trail' has a wrong offset!");

// Class TimeWatch.TWProjectileManager
// 0x0028 (0x0240 - 0x0218)
class ATWProjectileManager final : public AActor
{
public:
	TArray<class ATimeWatchProjectile*>           ActiveInstances;                                   // 0x0218(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UFluxTimelineProjectileManager*         Timeline;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATWProjectilePool*                      ProjectilePool;                                    // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ATimeWatchProjectile* CreateProjectile(TSubclassOf<class ABaseProjectile> InProjectileClass, class AActor* NewOwner, int32 BulletIndex, uint8 VolleyIndex, const struct FTransform& SpawnTransform, const float CookTime, float MuzzleSpeed, float CreationTime);
	int32 RegisterProjectile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWProjectileManager">();
	}
	static class ATWProjectileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWProjectileManager>();
	}
};
static_assert(alignof(ATWProjectileManager) == 0x000008, "Wrong alignment on ATWProjectileManager");
static_assert(sizeof(ATWProjectileManager) == 0x000240, "Wrong size on ATWProjectileManager");
static_assert(offsetof(ATWProjectileManager, ActiveInstances) == 0x000218, "Member 'ATWProjectileManager::ActiveInstances' has a wrong offset!");
static_assert(offsetof(ATWProjectileManager, Timeline) == 0x000228, "Member 'ATWProjectileManager::Timeline' has a wrong offset!");
static_assert(offsetof(ATWProjectileManager, ProjectilePool) == 0x000230, "Member 'ATWProjectileManager::ProjectilePool' has a wrong offset!");

// Class TimeWatch.TWProjectileMovementComponent
// 0x0020 (0x01F0 - 0x01D0)
class UTWProjectileMovementComponent final : public UBaseProjectileComponent
{
public:
	float                                         Drag;                                              // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* Projectile, const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)> OnAcknowledgeProjectileBounce; // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBounceBroadcast(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWProjectileMovementComponent">();
	}
	static class UTWProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWProjectileMovementComponent>();
	}
};
static_assert(alignof(UTWProjectileMovementComponent) == 0x000010, "Wrong alignment on UTWProjectileMovementComponent");
static_assert(sizeof(UTWProjectileMovementComponent) == 0x0001F0, "Wrong size on UTWProjectileMovementComponent");
static_assert(offsetof(UTWProjectileMovementComponent, Drag) == 0x0001D0, "Member 'UTWProjectileMovementComponent::Drag' has a wrong offset!");
static_assert(offsetof(UTWProjectileMovementComponent, OnAcknowledgeProjectileBounce) == 0x0001D8, "Member 'UTWProjectileMovementComponent::OnAcknowledgeProjectileBounce' has a wrong offset!");

// Class TimeWatch.TWProjectilePool
// 0x0050 (0x0268 - 0x0218)
class ATWProjectilePool final : public AActor
{
public:
	TMap<TSubclassOf<class ABaseProjectile>, struct FProjectileCollection> ProjectilePoolMap;        // 0x0218(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWProjectilePool">();
	}
	static class ATWProjectilePool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWProjectilePool>();
	}
};
static_assert(alignof(ATWProjectilePool) == 0x000008, "Wrong alignment on ATWProjectilePool");
static_assert(sizeof(ATWProjectilePool) == 0x000268, "Wrong size on ATWProjectilePool");
static_assert(offsetof(ATWProjectilePool, ProjectilePoolMap) == 0x000218, "Member 'ATWProjectilePool::ProjectilePoolMap' has a wrong offset!");

// Class TimeWatch.TWProjectilePredictionComponent
// 0x0068 (0x0118 - 0x00B0)
class UTWProjectilePredictionComponent final : public UActorComponent
{
public:
	class UStaticMesh*                            EndTrailMesh;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     EndTrailMeshMaterial;                              // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                EndTrailMeshScale;                                 // 0x00C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SplineMesh;                                        // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SplineMeshMaterial;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SplineMeshScale;                                   // 0x00E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TrailEndMeshComp;                                  // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USplineMeshComponent*>           ActiveMeshComponents;                              // 0x00F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USplineMeshComponent*>           SplineMeshCompPool;                                // 0x0108(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool DrawTrail(class UObject* Context, const struct FProjectilePredictionData& PredictionData, struct FPredictProjectilePathResult* PredictResult, EDrawDebugTrace DebugType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWProjectilePredictionComponent">();
	}
	static class UTWProjectilePredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWProjectilePredictionComponent>();
	}
};
static_assert(alignof(UTWProjectilePredictionComponent) == 0x000008, "Wrong alignment on UTWProjectilePredictionComponent");
static_assert(sizeof(UTWProjectilePredictionComponent) == 0x000118, "Wrong size on UTWProjectilePredictionComponent");
static_assert(offsetof(UTWProjectilePredictionComponent, EndTrailMesh) == 0x0000B0, "Member 'UTWProjectilePredictionComponent::EndTrailMesh' has a wrong offset!");
static_assert(offsetof(UTWProjectilePredictionComponent, EndTrailMeshMaterial) == 0x0000B8, "Member 'UTWProjectilePredictionComponent::EndTrailMeshMaterial' has a wrong offset!");
static_assert(offsetof(UTWProjectilePredictionComponent, EndTrailMeshScale) == 0x0000C0, "Member 'UTWProjectilePredictionComponent::EndTrailMeshScale' has a wrong offset!");
static_assert(offsetof(UTWProjectilePredictionComponent, SplineMesh) == 0x0000D0, "Member 'UTWProjectilePredictionComponent::SplineMesh' has a wrong offset!");
static_assert(offsetof(UTWProjectilePredictionComponent, SplineMeshMaterial) == 0x0000D8, "Member 'UTWProjectilePredictionComponent::SplineMeshMaterial' has a wrong offset!");
static_assert(offsetof(UTWProjectilePredictionComponent, SplineMeshScale) == 0x0000E0, "Member 'UTWProjectilePredictionComponent::SplineMeshScale' has a wrong offset!");
static_assert(offsetof(UTWProjectilePredictionComponent, TrailEndMeshComp) == 0x0000F0, "Member 'UTWProjectilePredictionComponent::TrailEndMeshComp' has a wrong offset!");
static_assert(offsetof(UTWProjectilePredictionComponent, ActiveMeshComponents) == 0x0000F8, "Member 'UTWProjectilePredictionComponent::ActiveMeshComponents' has a wrong offset!");
static_assert(offsetof(UTWProjectilePredictionComponent, SplineMeshCompPool) == 0x000108, "Member 'UTWProjectilePredictionComponent::SplineMeshCompPool' has a wrong offset!");

// Class TimeWatch.TWCustomProjectionInterface
// 0x0000 (0x0000 - 0x0000)
class ITWCustomProjectionInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWCustomProjectionInterface">();
	}
	static class ITWCustomProjectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITWCustomProjectionInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITWCustomProjectionInterface) == 0x000001, "Wrong alignment on ITWCustomProjectionInterface");
static_assert(sizeof(ITWCustomProjectionInterface) == 0x000001, "Wrong size on ITWCustomProjectionInterface");

// Class TimeWatch.TWQuickChatSlot
// 0x0010 (0x0248 - 0x0238)
class UTWQuickChatSlot final : public UUserWidgetBase
{
public:
	class UActionLabel*                           ActionLabel;                                       // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_DisplayName;                             // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWQuickChatSlot">();
	}
	static class UTWQuickChatSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWQuickChatSlot>();
	}
};
static_assert(alignof(UTWQuickChatSlot) == 0x000008, "Wrong alignment on UTWQuickChatSlot");
static_assert(sizeof(UTWQuickChatSlot) == 0x000248, "Wrong size on UTWQuickChatSlot");
static_assert(offsetof(UTWQuickChatSlot, ActionLabel) == 0x000238, "Member 'UTWQuickChatSlot::ActionLabel' has a wrong offset!");
static_assert(offsetof(UTWQuickChatSlot, TextBlock_DisplayName) == 0x000240, "Member 'UTWQuickChatSlot::TextBlock_DisplayName' has a wrong offset!");

// Class TimeWatch.TWRadialCloneInfo
// 0x00A8 (0x0328 - 0x0280)
class UTWRadialCloneInfo : public UNGDUserWidget
{
public:
	class ATimeWatchCharacter*                    Owner;                                             // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_CloneOutline;                                // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_CloneColor;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CloneShadow;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_DeactivatedIndex;                            // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CloneNumber;                                 // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_PlayerInfoOverlay;                         // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_Activated;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_Deactivated;                               // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_DeathIndicator;                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UTexture2D*>                CloneIndexTextures;                                // 0x02D0(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EWidgetSize                                   WidgetSize;                                        // 0x0320(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeWidget();
	void SetAsDeactivated(bool bInState);
	void SetCloneColorVisibility(ESlateVisibility NewVisibility);
	void SetCloneIndexText(int32 CloneIndex);
	void SetDeathVisibility(ESlateVisibility NewVisibility);
	void SetOwner(class ATimeWatchCharacter* NewOwner);
	void SetPlayerInfoOverlayScale(const struct FVector2D& NewScale);
	void UpdateWidgetStyle(bool IsPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRadialCloneInfo">();
	}
	static class UTWRadialCloneInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWRadialCloneInfo>();
	}
};
static_assert(alignof(UTWRadialCloneInfo) == 0x000008, "Wrong alignment on UTWRadialCloneInfo");
static_assert(sizeof(UTWRadialCloneInfo) == 0x000328, "Wrong size on UTWRadialCloneInfo");
static_assert(offsetof(UTWRadialCloneInfo, Owner) == 0x000280, "Member 'UTWRadialCloneInfo::Owner' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, Image_CloneOutline) == 0x000288, "Member 'UTWRadialCloneInfo::Image_CloneOutline' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, Image_CloneColor) == 0x000290, "Member 'UTWRadialCloneInfo::Image_CloneColor' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, Image_CloneShadow) == 0x000298, "Member 'UTWRadialCloneInfo::Image_CloneShadow' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, Image_DeactivatedIndex) == 0x0002A0, "Member 'UTWRadialCloneInfo::Image_DeactivatedIndex' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, Image_CloneNumber) == 0x0002A8, "Member 'UTWRadialCloneInfo::Image_CloneNumber' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, Overlay_PlayerInfoOverlay) == 0x0002B0, "Member 'UTWRadialCloneInfo::Overlay_PlayerInfoOverlay' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, Overlay_Activated) == 0x0002B8, "Member 'UTWRadialCloneInfo::Overlay_Activated' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, Overlay_Deactivated) == 0x0002C0, "Member 'UTWRadialCloneInfo::Overlay_Deactivated' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, CanvasPanel_DeathIndicator) == 0x0002C8, "Member 'UTWRadialCloneInfo::CanvasPanel_DeathIndicator' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, CloneIndexTextures) == 0x0002D0, "Member 'UTWRadialCloneInfo::CloneIndexTextures' has a wrong offset!");
static_assert(offsetof(UTWRadialCloneInfo, WidgetSize) == 0x000320, "Member 'UTWRadialCloneInfo::WidgetSize' has a wrong offset!");

// Class TimeWatch.TWRadialHealthBarWidget
// 0x0000 (0x0280 - 0x0280)
class UTWRadialHealthBarWidget final : public UNGDUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRadialHealthBarWidget">();
	}
	static class UTWRadialHealthBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWRadialHealthBarWidget>();
	}
};
static_assert(alignof(UTWRadialHealthBarWidget) == 0x000008, "Wrong alignment on UTWRadialHealthBarWidget");
static_assert(sizeof(UTWRadialHealthBarWidget) == 0x000280, "Wrong size on UTWRadialHealthBarWidget");

// Class TimeWatch.TWReplayHUD
// 0x0000 (0x0528 - 0x0528)
class ATWReplayHUD : public ATimeWatchHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWReplayHUD">();
	}
	static class ATWReplayHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWReplayHUD>();
	}
};
static_assert(alignof(ATWReplayHUD) == 0x000008, "Wrong alignment on ATWReplayHUD");
static_assert(sizeof(ATWReplayHUD) == 0x000528, "Wrong size on ATWReplayHUD");

// Class TimeWatch.TWReverseSoundsDataAsset
// 0x0090 (0x00C0 - 0x0030)
class UTWReverseSoundsDataAsset final : public UDataAsset
{
public:
	struct FNGDSoundSwitch                        ForwardSoundSwitch;                                // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FNGDSoundSwitch                        ReverseSoundSwitch;                                // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class UAkAudioEvent*, struct FReverseSoundConfig> ReversableConfigs;                        // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWReverseSoundsDataAsset">();
	}
	static class UTWReverseSoundsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWReverseSoundsDataAsset>();
	}
};
static_assert(alignof(UTWReverseSoundsDataAsset) == 0x000008, "Wrong alignment on UTWReverseSoundsDataAsset");
static_assert(sizeof(UTWReverseSoundsDataAsset) == 0x0000C0, "Wrong size on UTWReverseSoundsDataAsset");
static_assert(offsetof(UTWReverseSoundsDataAsset, ForwardSoundSwitch) == 0x000030, "Member 'UTWReverseSoundsDataAsset::ForwardSoundSwitch' has a wrong offset!");
static_assert(offsetof(UTWReverseSoundsDataAsset, ReverseSoundSwitch) == 0x000050, "Member 'UTWReverseSoundsDataAsset::ReverseSoundSwitch' has a wrong offset!");
static_assert(offsetof(UTWReverseSoundsDataAsset, ReversableConfigs) == 0x000070, "Member 'UTWReverseSoundsDataAsset::ReversableConfigs' has a wrong offset!");

// Class TimeWatch.TWRewardItemPreviewActor
// 0x0108 (0x0320 - 0x0218)
class ATWRewardItemPreviewActor : public AActor
{
public:
	float                                         SpinningCharacterMouseSpeedFactor;                 // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLerpVelocity;                                   // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220[0x4];                                      // 0x0220(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APlayerController>       LocalPlayerController;                             // 0x0224(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        CustomRootComponent;                               // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SkeletalMeshSceneComponent;                        // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 ItemSkeletalMeshComponent;                         // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UMaterialInstanceDynamic*>  DynamicMaterialInstancesMap;                       // 0x0248(0x0050)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 SelectedItemToPreview;                             // 0x0298(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CharacterStylePosition;                            // 0x02A8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CharacterStyleRotation;                            // 0x02B4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                WeaponStylePosition;                               // 0x02C0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               WeaponStyleRotation;                               // 0x02CC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanRotateItemPreview;                             // 0x02D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCharacterStyle;                                 // 0x02D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDBackendReward                      CurrentLoadedItem;                                 // 0x02E0(0x0028)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x18];                                     // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindPlayerInput();
	void BP_CosmeticStartVanishAnimation();
	void BP_SetMouseXInput(float InValue);
	void BP_SetupItem(const class UTWItemDataAsset* InItemData);
	void LoadItemPreview(struct FNGDBackendReward* InItemToPreview);
	void LoadItemPreviewBySKU(const class FString& InItemToPreview);
	void OnFireButtonDown();
	void OnFireButtonUp();
	void OnItemPreviewLoadCompleted();
	void OnYawInput(float InValue);
	void SetScalarParameterOnDynamicMaterials(class FName InParameterName, float InValue);
	void SwapMeshes();
	void UnbindPlayerInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRewardItemPreviewActor">();
	}
	static class ATWRewardItemPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWRewardItemPreviewActor>();
	}
};
static_assert(alignof(ATWRewardItemPreviewActor) == 0x000008, "Wrong alignment on ATWRewardItemPreviewActor");
static_assert(sizeof(ATWRewardItemPreviewActor) == 0x000320, "Wrong size on ATWRewardItemPreviewActor");
static_assert(offsetof(ATWRewardItemPreviewActor, SpinningCharacterMouseSpeedFactor) == 0x000218, "Member 'ATWRewardItemPreviewActor::SpinningCharacterMouseSpeedFactor' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, MaxLerpVelocity) == 0x00021C, "Member 'ATWRewardItemPreviewActor::MaxLerpVelocity' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, LocalPlayerController) == 0x000224, "Member 'ATWRewardItemPreviewActor::LocalPlayerController' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, CustomRootComponent) == 0x000230, "Member 'ATWRewardItemPreviewActor::CustomRootComponent' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, SkeletalMeshSceneComponent) == 0x000238, "Member 'ATWRewardItemPreviewActor::SkeletalMeshSceneComponent' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, ItemSkeletalMeshComponent) == 0x000240, "Member 'ATWRewardItemPreviewActor::ItemSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, DynamicMaterialInstancesMap) == 0x000248, "Member 'ATWRewardItemPreviewActor::DynamicMaterialInstancesMap' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, SelectedItemToPreview) == 0x000298, "Member 'ATWRewardItemPreviewActor::SelectedItemToPreview' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, CharacterStylePosition) == 0x0002A8, "Member 'ATWRewardItemPreviewActor::CharacterStylePosition' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, CharacterStyleRotation) == 0x0002B4, "Member 'ATWRewardItemPreviewActor::CharacterStyleRotation' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, WeaponStylePosition) == 0x0002C0, "Member 'ATWRewardItemPreviewActor::WeaponStylePosition' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, WeaponStyleRotation) == 0x0002CC, "Member 'ATWRewardItemPreviewActor::WeaponStyleRotation' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, bCanRotateItemPreview) == 0x0002D8, "Member 'ATWRewardItemPreviewActor::bCanRotateItemPreview' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, bIsCharacterStyle) == 0x0002D9, "Member 'ATWRewardItemPreviewActor::bIsCharacterStyle' has a wrong offset!");
static_assert(offsetof(ATWRewardItemPreviewActor, CurrentLoadedItem) == 0x0002E0, "Member 'ATWRewardItemPreviewActor::CurrentLoadedItem' has a wrong offset!");

// Class TimeWatch.TWRewardPopup
// 0x0078 (0x0840 - 0x07C8)
class UTWRewardPopup : public UTWGenericPopup
{
public:
	class UTextBlock*                             Popup_Title;                                       // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Popup_Description;                                 // 0x07D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_ItemContainer;                       // 0x07D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         FontInfo;                                          // 0x07E0(0x0050)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWRewardsDataAsset*                    RewardsDataAsset;                                  // 0x0830(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWRewardWidget>            RewardItemClass;                                   // 0x0838(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void LoadItems(const TArray<struct FNGDBackendReward>& PendingRewards);
	void SetDescription(const class FText& Description);
	void SetTitle(const class FText& Title);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRewardPopup">();
	}
	static class UTWRewardPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWRewardPopup>();
	}
};
static_assert(alignof(UTWRewardPopup) == 0x000008, "Wrong alignment on UTWRewardPopup");
static_assert(sizeof(UTWRewardPopup) == 0x000840, "Wrong size on UTWRewardPopup");
static_assert(offsetof(UTWRewardPopup, Popup_Title) == 0x0007C8, "Member 'UTWRewardPopup::Popup_Title' has a wrong offset!");
static_assert(offsetof(UTWRewardPopup, Popup_Description) == 0x0007D0, "Member 'UTWRewardPopup::Popup_Description' has a wrong offset!");
static_assert(offsetof(UTWRewardPopup, HorizontalBox_ItemContainer) == 0x0007D8, "Member 'UTWRewardPopup::HorizontalBox_ItemContainer' has a wrong offset!");
static_assert(offsetof(UTWRewardPopup, FontInfo) == 0x0007E0, "Member 'UTWRewardPopup::FontInfo' has a wrong offset!");
static_assert(offsetof(UTWRewardPopup, RewardsDataAsset) == 0x000830, "Member 'UTWRewardPopup::RewardsDataAsset' has a wrong offset!");
static_assert(offsetof(UTWRewardPopup, RewardItemClass) == 0x000838, "Member 'UTWRewardPopup::RewardItemClass' has a wrong offset!");

// Class TimeWatch.TWRewardPopupHUDState
// 0x0000 (0x0270 - 0x0270)
class UTWRewardPopupHUDState : public UNGDPopupHUDState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRewardPopupHUDState">();
	}
	static class UTWRewardPopupHUDState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWRewardPopupHUDState>();
	}
};
static_assert(alignof(UTWRewardPopupHUDState) == 0x000008, "Wrong alignment on UTWRewardPopupHUDState");
static_assert(sizeof(UTWRewardPopupHUDState) == 0x000270, "Wrong size on UTWRewardPopupHUDState");

// Class TimeWatch.TWRewardsDataAsset
// 0x01C0 (0x01F0 - 0x0030)
class UTWRewardsDataAsset final : public UDataAsset
{
public:
	TMap<ENGDBackendItemRarity, struct FTWRewardRarityConfig> RewardRarityConfig;                    // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           DevRarityColor;                                    // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DevOutlineColor;                                   // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevOutlineThickness;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevOutlineThicknessReduced;                        // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DevRarityText;                                     // 0x00A8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTWRewardConfig                        RewardCoinsConfig;                                 // 0x00C0(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTWRewardConfig                        RewardXPConfig;                                    // 0x0158(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRewardsDataAsset">();
	}
	static class UTWRewardsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWRewardsDataAsset>();
	}
};
static_assert(alignof(UTWRewardsDataAsset) == 0x000008, "Wrong alignment on UTWRewardsDataAsset");
static_assert(sizeof(UTWRewardsDataAsset) == 0x0001F0, "Wrong size on UTWRewardsDataAsset");
static_assert(offsetof(UTWRewardsDataAsset, RewardRarityConfig) == 0x000030, "Member 'UTWRewardsDataAsset::RewardRarityConfig' has a wrong offset!");
static_assert(offsetof(UTWRewardsDataAsset, DevRarityColor) == 0x000080, "Member 'UTWRewardsDataAsset::DevRarityColor' has a wrong offset!");
static_assert(offsetof(UTWRewardsDataAsset, DevOutlineColor) == 0x000090, "Member 'UTWRewardsDataAsset::DevOutlineColor' has a wrong offset!");
static_assert(offsetof(UTWRewardsDataAsset, DevOutlineThickness) == 0x0000A0, "Member 'UTWRewardsDataAsset::DevOutlineThickness' has a wrong offset!");
static_assert(offsetof(UTWRewardsDataAsset, DevOutlineThicknessReduced) == 0x0000A4, "Member 'UTWRewardsDataAsset::DevOutlineThicknessReduced' has a wrong offset!");
static_assert(offsetof(UTWRewardsDataAsset, DevRarityText) == 0x0000A8, "Member 'UTWRewardsDataAsset::DevRarityText' has a wrong offset!");
static_assert(offsetof(UTWRewardsDataAsset, RewardCoinsConfig) == 0x0000C0, "Member 'UTWRewardsDataAsset::RewardCoinsConfig' has a wrong offset!");
static_assert(offsetof(UTWRewardsDataAsset, RewardXPConfig) == 0x000158, "Member 'UTWRewardsDataAsset::RewardXPConfig' has a wrong offset!");

// Class TimeWatch.TWRewardWidget
// 0x00D8 (0x0358 - 0x0280)
class UTWRewardWidget : public UNGDUserWidget
{
public:
	uint8                                         Pad_280[0x28];                                     // 0x0280(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     BackgroundGradient;                                // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Image_RewardBackground;                            // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_RewardStyle;                                 // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_ButtonSelected;                              // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_RewardImage;                                 // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_LockedImage;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_OwnedImage;                                  // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_RewardAmount;                            // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           ProgressBar_RewardProgress;                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_RewardLevel;                                  // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_RewardWidget;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_RareShine;                                 // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_EpicShine;                                 // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_LegendaryShine;                            // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWTagWidget*                           Tag_FreeItem;                                      // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTWRewardWidget* RewardWidget)> OnItemClicked;               // 0x0328(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTWRewardWidget* RewardWidget)> OnItemHovered;               // 0x0338(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTWRewardWidget* RewardWidget)> OnItemUnhovered;             // 0x0348(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void OnRewardWidgetClicked();
	void OnRewardWidgetHovered();
	void OnRewardWidgetUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRewardWidget">();
	}
	static class UTWRewardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWRewardWidget>();
	}
};
static_assert(alignof(UTWRewardWidget) == 0x000008, "Wrong alignment on UTWRewardWidget");
static_assert(sizeof(UTWRewardWidget) == 0x000358, "Wrong size on UTWRewardWidget");
static_assert(offsetof(UTWRewardWidget, BackgroundGradient) == 0x0002A8, "Member 'UTWRewardWidget::BackgroundGradient' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Image_RewardBackground) == 0x0002B8, "Member 'UTWRewardWidget::Image_RewardBackground' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Image_RewardStyle) == 0x0002C0, "Member 'UTWRewardWidget::Image_RewardStyle' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Image_ButtonSelected) == 0x0002C8, "Member 'UTWRewardWidget::Image_ButtonSelected' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Image_RewardImage) == 0x0002D0, "Member 'UTWRewardWidget::Image_RewardImage' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Image_LockedImage) == 0x0002D8, "Member 'UTWRewardWidget::Image_LockedImage' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Image_OwnedImage) == 0x0002E0, "Member 'UTWRewardWidget::Image_OwnedImage' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, TextBlock_RewardAmount) == 0x0002E8, "Member 'UTWRewardWidget::TextBlock_RewardAmount' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, ProgressBar_RewardProgress) == 0x0002F0, "Member 'UTWRewardWidget::ProgressBar_RewardProgress' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Text_RewardLevel) == 0x0002F8, "Member 'UTWRewardWidget::Text_RewardLevel' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Button_RewardWidget) == 0x000300, "Member 'UTWRewardWidget::Button_RewardWidget' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Overlay_RareShine) == 0x000308, "Member 'UTWRewardWidget::Overlay_RareShine' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Overlay_EpicShine) == 0x000310, "Member 'UTWRewardWidget::Overlay_EpicShine' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Overlay_LegendaryShine) == 0x000318, "Member 'UTWRewardWidget::Overlay_LegendaryShine' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, Tag_FreeItem) == 0x000320, "Member 'UTWRewardWidget::Tag_FreeItem' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, OnItemClicked) == 0x000328, "Member 'UTWRewardWidget::OnItemClicked' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, OnItemHovered) == 0x000338, "Member 'UTWRewardWidget::OnItemHovered' has a wrong offset!");
static_assert(offsetof(UTWRewardWidget, OnItemUnhovered) == 0x000348, "Member 'UTWRewardWidget::OnItemUnhovered' has a wrong offset!");

// Class TimeWatch.TWRewindablePhysics
// 0x0000 (0x0000 - 0x0000)
class ITWRewindablePhysics final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRewindablePhysics">();
	}
	static class ITWRewindablePhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITWRewindablePhysics>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITWRewindablePhysics) == 0x000001, "Wrong alignment on ITWRewindablePhysics");
static_assert(sizeof(ITWRewindablePhysics) == 0x000001, "Wrong size on ITWRewindablePhysics");

// Class TimeWatch.TWRewindableStaticActor
// 0x0038 (0x0250 - 0x0218)
class ATWRewindableStaticActor final : public AActor
{
public:
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      RewindCollider;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HitRegistrationCollider;                           // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDRewindComponent*                    RewindComponent;                                   // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDPostUpdateWorkComponent*            NGDPostUpdateWorkComponent;                        // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPostUpdateWorkTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWRewindableStaticActor">();
	}
	static class ATWRewindableStaticActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWRewindableStaticActor>();
	}
};
static_assert(alignof(ATWRewindableStaticActor) == 0x000008, "Wrong alignment on ATWRewindableStaticActor");
static_assert(sizeof(ATWRewindableStaticActor) == 0x000250, "Wrong size on ATWRewindableStaticActor");
static_assert(offsetof(ATWRewindableStaticActor, Mesh) == 0x000228, "Member 'ATWRewindableStaticActor::Mesh' has a wrong offset!");
static_assert(offsetof(ATWRewindableStaticActor, RewindCollider) == 0x000230, "Member 'ATWRewindableStaticActor::RewindCollider' has a wrong offset!");
static_assert(offsetof(ATWRewindableStaticActor, HitRegistrationCollider) == 0x000238, "Member 'ATWRewindableStaticActor::HitRegistrationCollider' has a wrong offset!");
static_assert(offsetof(ATWRewindableStaticActor, RewindComponent) == 0x000240, "Member 'ATWRewindableStaticActor::RewindComponent' has a wrong offset!");
static_assert(offsetof(ATWRewindableStaticActor, NGDPostUpdateWorkComponent) == 0x000248, "Member 'ATWRewindableStaticActor::NGDPostUpdateWorkComponent' has a wrong offset!");

// Class TimeWatch.TWScoreboardWidget
// 0x0058 (0x02D8 - 0x0280)
class UTWScoreboardWidget : public UNGDUserWidget
{
public:
	TSubclassOf<class UTWScoreWidget>             ScoreWidgetTemplate;                               // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreSlotSizeX;                                    // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreSlotSizeY;                                    // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreSlotPadding;                                  // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         HorizontalBox_LeftScoreBox;                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_RightScoreBox;                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ModeObjective;                                // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWScoreWidget*>                 LeftScoreWidgets;                                  // 0x02B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWScoreWidget*>                 RightScoreWidgets;                                 // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateScore();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWScoreboardWidget">();
	}
	static class UTWScoreboardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWScoreboardWidget>();
	}
};
static_assert(alignof(UTWScoreboardWidget) == 0x000008, "Wrong alignment on UTWScoreboardWidget");
static_assert(sizeof(UTWScoreboardWidget) == 0x0002D8, "Wrong size on UTWScoreboardWidget");
static_assert(offsetof(UTWScoreboardWidget, ScoreWidgetTemplate) == 0x000280, "Member 'UTWScoreboardWidget::ScoreWidgetTemplate' has a wrong offset!");
static_assert(offsetof(UTWScoreboardWidget, ScoreSlotSizeX) == 0x000288, "Member 'UTWScoreboardWidget::ScoreSlotSizeX' has a wrong offset!");
static_assert(offsetof(UTWScoreboardWidget, ScoreSlotSizeY) == 0x00028C, "Member 'UTWScoreboardWidget::ScoreSlotSizeY' has a wrong offset!");
static_assert(offsetof(UTWScoreboardWidget, ScoreSlotPadding) == 0x000290, "Member 'UTWScoreboardWidget::ScoreSlotPadding' has a wrong offset!");
static_assert(offsetof(UTWScoreboardWidget, HorizontalBox_LeftScoreBox) == 0x000298, "Member 'UTWScoreboardWidget::HorizontalBox_LeftScoreBox' has a wrong offset!");
static_assert(offsetof(UTWScoreboardWidget, HorizontalBox_RightScoreBox) == 0x0002A0, "Member 'UTWScoreboardWidget::HorizontalBox_RightScoreBox' has a wrong offset!");
static_assert(offsetof(UTWScoreboardWidget, Text_ModeObjective) == 0x0002A8, "Member 'UTWScoreboardWidget::Text_ModeObjective' has a wrong offset!");
static_assert(offsetof(UTWScoreboardWidget, LeftScoreWidgets) == 0x0002B0, "Member 'UTWScoreboardWidget::LeftScoreWidgets' has a wrong offset!");
static_assert(offsetof(UTWScoreboardWidget, RightScoreWidgets) == 0x0002C0, "Member 'UTWScoreboardWidget::RightScoreWidgets' has a wrong offset!");

// Class TimeWatch.TWScoreCheckboxWidget
// 0x0000 (0x0280 - 0x0280)
class UTWScoreCheckboxWidget final : public UNGDUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWScoreCheckboxWidget">();
	}
	static class UTWScoreCheckboxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWScoreCheckboxWidget>();
	}
};
static_assert(alignof(UTWScoreCheckboxWidget) == 0x000008, "Wrong alignment on UTWScoreCheckboxWidget");
static_assert(sizeof(UTWScoreCheckboxWidget) == 0x000280, "Wrong size on UTWScoreCheckboxWidget");

// Class TimeWatch.TWScoreWidget
// 0x0048 (0x02C8 - 0x0280)
class UTWScoreWidget : public UNGDUserWidget
{
public:
	struct FLinearColor                           BackgroundScoreColor;                              // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     LinearGradientBaseMaterial;                        // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Image_FillScore;                                   // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_OutlineScore;                                // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWScoreWidget">();
	}
	static class UTWScoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWScoreWidget>();
	}
};
static_assert(alignof(UTWScoreWidget) == 0x000008, "Wrong alignment on UTWScoreWidget");
static_assert(sizeof(UTWScoreWidget) == 0x0002C8, "Wrong size on UTWScoreWidget");
static_assert(offsetof(UTWScoreWidget, BackgroundScoreColor) == 0x000280, "Member 'UTWScoreWidget::BackgroundScoreColor' has a wrong offset!");
static_assert(offsetof(UTWScoreWidget, LinearGradientBaseMaterial) == 0x000290, "Member 'UTWScoreWidget::LinearGradientBaseMaterial' has a wrong offset!");
static_assert(offsetof(UTWScoreWidget, Image_FillScore) == 0x0002B8, "Member 'UTWScoreWidget::Image_FillScore' has a wrong offset!");
static_assert(offsetof(UTWScoreWidget, Image_OutlineScore) == 0x0002C0, "Member 'UTWScoreWidget::Image_OutlineScore' has a wrong offset!");

// Class TimeWatch.TWScreenshotSkeletalMeshData
// 0x0040 (0x0070 - 0x0030)
class UTWScreenshotSkeletalMeshData final : public UDataAsset
{
public:
	class FString                                 ID;                                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  Meshes;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScreenshotStyleDataAsset>      MeshStyles;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScreenshotWeaponStyleDataAsset> WeaponStyles;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWScreenshotSkeletalMeshData">();
	}
	static class UTWScreenshotSkeletalMeshData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWScreenshotSkeletalMeshData>();
	}
};
static_assert(alignof(UTWScreenshotSkeletalMeshData) == 0x000008, "Wrong alignment on UTWScreenshotSkeletalMeshData");
static_assert(sizeof(UTWScreenshotSkeletalMeshData) == 0x000070, "Wrong size on UTWScreenshotSkeletalMeshData");
static_assert(offsetof(UTWScreenshotSkeletalMeshData, ID) == 0x000030, "Member 'UTWScreenshotSkeletalMeshData::ID' has a wrong offset!");
static_assert(offsetof(UTWScreenshotSkeletalMeshData, Meshes) == 0x000040, "Member 'UTWScreenshotSkeletalMeshData::Meshes' has a wrong offset!");
static_assert(offsetof(UTWScreenshotSkeletalMeshData, MeshStyles) == 0x000050, "Member 'UTWScreenshotSkeletalMeshData::MeshStyles' has a wrong offset!");
static_assert(offsetof(UTWScreenshotSkeletalMeshData, WeaponStyles) == 0x000060, "Member 'UTWScreenshotSkeletalMeshData::WeaponStyles' has a wrong offset!");

// Class TimeWatch.TWSelectedWeaponInfo
// 0x0028 (0x02A8 - 0x0280)
class UTWSelectedWeaponInfo : public UNGDUserWidget
{
public:
	class UImage*                                 Image_WeaponIcon;                                  // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_CurrentAmmo;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TotalAmmo;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_Reload;                                // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATemporalWeapon*                        Weapon;                                            // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnWeaponReloadEnd();
	void BP_OnWeaponReloadStart();
	void BP_OnWeaponSet();
	class ATemporalWeapon* GetWeapon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSelectedWeaponInfo">();
	}
	static class UTWSelectedWeaponInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWSelectedWeaponInfo>();
	}
};
static_assert(alignof(UTWSelectedWeaponInfo) == 0x000008, "Wrong alignment on UTWSelectedWeaponInfo");
static_assert(sizeof(UTWSelectedWeaponInfo) == 0x0002A8, "Wrong size on UTWSelectedWeaponInfo");
static_assert(offsetof(UTWSelectedWeaponInfo, Image_WeaponIcon) == 0x000280, "Member 'UTWSelectedWeaponInfo::Image_WeaponIcon' has a wrong offset!");
static_assert(offsetof(UTWSelectedWeaponInfo, Text_CurrentAmmo) == 0x000288, "Member 'UTWSelectedWeaponInfo::Text_CurrentAmmo' has a wrong offset!");
static_assert(offsetof(UTWSelectedWeaponInfo, Text_TotalAmmo) == 0x000290, "Member 'UTWSelectedWeaponInfo::Text_TotalAmmo' has a wrong offset!");
static_assert(offsetof(UTWSelectedWeaponInfo, ProgressBar_Reload) == 0x000298, "Member 'UTWSelectedWeaponInfo::ProgressBar_Reload' has a wrong offset!");
static_assert(offsetof(UTWSelectedWeaponInfo, Weapon) == 0x0002A0, "Member 'UTWSelectedWeaponInfo::Weapon' has a wrong offset!");

// Class TimeWatch.TWSinglePlayerGameMode
// 0x0000 (0x0470 - 0x0470)
class ATWSinglePlayerGameMode final : public ATimeWatchGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSinglePlayerGameMode">();
	}
	static class ATWSinglePlayerGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWSinglePlayerGameMode>();
	}
};
static_assert(alignof(ATWSinglePlayerGameMode) == 0x000008, "Wrong alignment on ATWSinglePlayerGameMode");
static_assert(sizeof(ATWSinglePlayerGameMode) == 0x000470, "Wrong size on ATWSinglePlayerGameMode");

// Class TimeWatch.TWSkeletalMeshComponent
// 0x0020 (0x0AC0 - 0x0AA0)
class UTWSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	struct FProjectionParameters                  CustomProjection;                                  // 0x0AA0(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB8[0x8];                                      // 0x0AB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSkeletalMeshComponent">();
	}
	static class UTWSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWSkeletalMeshComponent>();
	}
};
static_assert(alignof(UTWSkeletalMeshComponent) == 0x000010, "Wrong alignment on UTWSkeletalMeshComponent");
static_assert(sizeof(UTWSkeletalMeshComponent) == 0x000AC0, "Wrong size on UTWSkeletalMeshComponent");
static_assert(offsetof(UTWSkeletalMeshComponent, CustomProjection) == 0x000AA0, "Member 'UTWSkeletalMeshComponent::CustomProjection' has a wrong offset!");

// Class TimeWatch.TWSkinPreviewActor
// 0x0158 (0x0370 - 0x0218)
class ATWSkinPreviewActor : public AActor
{
public:
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWStylesDataAsset*                     SwapStyle;                                         // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTWCharacterDataAsset*                  CurrentLoadedCharacter;                            // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTWStylesDataAsset*                     CurrentLoadedStyle;                                // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpinningCharacterMouseSpeedFactor;                 // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLerpVelocity;                                   // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSelectCharacterEvent;                            // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlayerController>       LocalPlayerController;                             // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        CustomRootComponent;                               // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SkeletalMeshSceneComponent;                        // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkinSkeletalMeshComponent;                         // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MirroredSkeletalMeshComponent;                     // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UMaterialInstanceDynamic*>  DynamicMaterialInstancesMap;                       // 0x0280(0x0050)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTWStylesDataAsset*                     SelectedStyle;                                     // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCharacterSelectionEntry               ExpoRandomEntry;                                   // 0x02D8(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCharacterSelectionEntry               SelectedEntry;                                     // 0x0300(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldLogAssetLoad;                               // 0x0328(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x2];                                      // 0x0329(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldPlayPreviewAnimation;                       // 0x032B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x44];                                     // 0x032C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindPlayerInput();
	void BP_CosmeticStartVanishAnimation();
	void BP_SetMouseXInput(float InValue);
	void BP_SetupCharacterOutfit(const class UTWStylesDataAsset* InStyleDataAsset);
	void ConfigureExpoRandomCustomization();
	void ExpoRandomCustomization(int32 Limit);
	bool GetPreviewAnimationPlayStatus();
	void LoadCharacterCustomization(const struct FCharacterSelectionEntry& CharacterSelectionEntry);
	void OnCharacterCustomizationLoadCompleted();
	void OnFireButtonDown();
	void OnFireButtonUp();
	void OnInventoryUpdateCompleted(bool bWasSuccessful, const class FString& ErrorString);
	void OnRandomCustomizationComplete();
	void OnYawInput(float InValue);
	void SetScalarParameterOnDynamicMaterials(class FName InParameterName, float InValue);
	void SwapMeshes();
	void UnbindPlayerInput();

	class UTexture2D* GetCharacterBGImage() const;
	class FString GetCharacterFriendlyName() const;
	struct FRotator GetSkinRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSkinPreviewActor">();
	}
	static class ATWSkinPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWSkinPreviewActor>();
	}
};
static_assert(alignof(ATWSkinPreviewActor) == 0x000008, "Wrong alignment on ATWSkinPreviewActor");
static_assert(sizeof(ATWSkinPreviewActor) == 0x000370, "Wrong size on ATWSkinPreviewActor");
static_assert(offsetof(ATWSkinPreviewActor, SwapStyle) == 0x000228, "Member 'ATWSkinPreviewActor::SwapStyle' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, CurrentLoadedCharacter) == 0x000230, "Member 'ATWSkinPreviewActor::CurrentLoadedCharacter' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, CurrentLoadedStyle) == 0x000238, "Member 'ATWSkinPreviewActor::CurrentLoadedStyle' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, SpinningCharacterMouseSpeedFactor) == 0x000240, "Member 'ATWSkinPreviewActor::SpinningCharacterMouseSpeedFactor' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, MaxLerpVelocity) == 0x000244, "Member 'ATWSkinPreviewActor::MaxLerpVelocity' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, OnSelectCharacterEvent) == 0x000248, "Member 'ATWSkinPreviewActor::OnSelectCharacterEvent' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, LocalPlayerController) == 0x000258, "Member 'ATWSkinPreviewActor::LocalPlayerController' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, CustomRootComponent) == 0x000260, "Member 'ATWSkinPreviewActor::CustomRootComponent' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, SkeletalMeshSceneComponent) == 0x000268, "Member 'ATWSkinPreviewActor::SkeletalMeshSceneComponent' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, SkinSkeletalMeshComponent) == 0x000270, "Member 'ATWSkinPreviewActor::SkinSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, MirroredSkeletalMeshComponent) == 0x000278, "Member 'ATWSkinPreviewActor::MirroredSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, DynamicMaterialInstancesMap) == 0x000280, "Member 'ATWSkinPreviewActor::DynamicMaterialInstancesMap' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, SelectedStyle) == 0x0002D0, "Member 'ATWSkinPreviewActor::SelectedStyle' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, ExpoRandomEntry) == 0x0002D8, "Member 'ATWSkinPreviewActor::ExpoRandomEntry' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, SelectedEntry) == 0x000300, "Member 'ATWSkinPreviewActor::SelectedEntry' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, bShouldLogAssetLoad) == 0x000328, "Member 'ATWSkinPreviewActor::bShouldLogAssetLoad' has a wrong offset!");
static_assert(offsetof(ATWSkinPreviewActor, bShouldPlayPreviewAnimation) == 0x00032B, "Member 'ATWSkinPreviewActor::bShouldPlayPreviewAnimation' has a wrong offset!");

// Class TimeWatch.TWSkinPreviewCameraComponent
// 0x0000 (0x08A0 - 0x08A0)
class UTWSkinPreviewCameraComponent final : public UCineCameraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSkinPreviewCameraComponent">();
	}
	static class UTWSkinPreviewCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWSkinPreviewCameraComponent>();
	}
};
static_assert(alignof(UTWSkinPreviewCameraComponent) == 0x000010, "Wrong alignment on UTWSkinPreviewCameraComponent");
static_assert(sizeof(UTWSkinPreviewCameraComponent) == 0x0008A0, "Wrong size on UTWSkinPreviewCameraComponent");

// Class TimeWatch.TWSpectatorPawn
// 0x00C8 (0x0368 - 0x02A0)
class ATWSpectatorPawn final : public ASpectatorPawn
{
public:
	uint8                                         Pad_2A0[0x4];                                      // 0x02A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementSmoothening;                               // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseLookSmoothening;                              // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x18];                                     // 0x02AC(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PadLookInputScalar;                                // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWAutoSpectateComponent*               AutoSpectateComponent;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Sprint_SpeedScalar;                                // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeedVariation;                                 // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Sprint_BaseAccelerationScalar;                     // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAccelerationVariation;                          // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Sprint_BaseDecelerationScalar;                     // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDecelerationVariation;                          // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Sprint_BaseTurningBoostScalar;                     // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTurningBoostScalarVariation;                    // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TPDesiredDistanceToViewTarget;                     // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToViewTargetSpeed;                         // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinMouseScrollScalar;                              // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMouseScrollScalar;                              // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseScrollSpeed;                                  // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimeWatchMovementComponent*            LastSpectatedCharMoveComp;                         // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketToSpectateOnRagdoll;                         // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x32];                                     // 0x0318(0x0032)(Fixing Size After Last Property [ Dumper-7 ])
	ESpectatorModes                               CurrentSpectatorMode;                              // 0x034A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34B[0x5];                                      // 0x034B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                CurrentViewTargetWeapon;                           // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATimeWatchCharacter*                    CurrentSpectatedTWCharacter;                       // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStateChange(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void SpectatorLookSmooth(float NewSmooth);
	void SpectatorMoveSmooth(float NewSmooth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSpectatorPawn">();
	}
	static class ATWSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWSpectatorPawn>();
	}
};
static_assert(alignof(ATWSpectatorPawn) == 0x000008, "Wrong alignment on ATWSpectatorPawn");
static_assert(sizeof(ATWSpectatorPawn) == 0x000368, "Wrong size on ATWSpectatorPawn");
static_assert(offsetof(ATWSpectatorPawn, MovementSmoothening) == 0x0002A4, "Member 'ATWSpectatorPawn::MovementSmoothening' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, MouseLookSmoothening) == 0x0002A8, "Member 'ATWSpectatorPawn::MouseLookSmoothening' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, PadLookInputScalar) == 0x0002C4, "Member 'ATWSpectatorPawn::PadLookInputScalar' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, AutoSpectateComponent) == 0x0002C8, "Member 'ATWSpectatorPawn::AutoSpectateComponent' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, Sprint_SpeedScalar) == 0x0002D0, "Member 'ATWSpectatorPawn::Sprint_SpeedScalar' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, MaxSpeedVariation) == 0x0002D4, "Member 'ATWSpectatorPawn::MaxSpeedVariation' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, Sprint_BaseAccelerationScalar) == 0x0002D8, "Member 'ATWSpectatorPawn::Sprint_BaseAccelerationScalar' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, MaxAccelerationVariation) == 0x0002DC, "Member 'ATWSpectatorPawn::MaxAccelerationVariation' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, Sprint_BaseDecelerationScalar) == 0x0002E0, "Member 'ATWSpectatorPawn::Sprint_BaseDecelerationScalar' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, MaxDecelerationVariation) == 0x0002E4, "Member 'ATWSpectatorPawn::MaxDecelerationVariation' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, Sprint_BaseTurningBoostScalar) == 0x0002E8, "Member 'ATWSpectatorPawn::Sprint_BaseTurningBoostScalar' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, MaxTurningBoostScalarVariation) == 0x0002EC, "Member 'ATWSpectatorPawn::MaxTurningBoostScalarVariation' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, TPDesiredDistanceToViewTarget) == 0x0002F0, "Member 'ATWSpectatorPawn::TPDesiredDistanceToViewTarget' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, DistanceToViewTargetSpeed) == 0x0002F4, "Member 'ATWSpectatorPawn::DistanceToViewTargetSpeed' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, MinMouseScrollScalar) == 0x0002F8, "Member 'ATWSpectatorPawn::MinMouseScrollScalar' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, MaxMouseScrollScalar) == 0x0002FC, "Member 'ATWSpectatorPawn::MaxMouseScrollScalar' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, MouseScrollSpeed) == 0x000300, "Member 'ATWSpectatorPawn::MouseScrollSpeed' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, LastSpectatedCharMoveComp) == 0x000308, "Member 'ATWSpectatorPawn::LastSpectatedCharMoveComp' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, SocketToSpectateOnRagdoll) == 0x000310, "Member 'ATWSpectatorPawn::SocketToSpectateOnRagdoll' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, CurrentSpectatorMode) == 0x00034A, "Member 'ATWSpectatorPawn::CurrentSpectatorMode' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, CurrentViewTargetWeapon) == 0x000350, "Member 'ATWSpectatorPawn::CurrentViewTargetWeapon' has a wrong offset!");
static_assert(offsetof(ATWSpectatorPawn, CurrentSpectatedTWCharacter) == 0x000358, "Member 'ATWSpectatorPawn::CurrentSpectatedTWCharacter' has a wrong offset!");

// Class TimeWatch.TWStaticMeshComponent
// 0x0020 (0x0490 - 0x0470)
class UTWStaticMeshComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjectionParameters                  CustomProjection;                                  // 0x0470(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWStaticMeshComponent">();
	}
	static class UTWStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWStaticMeshComponent>();
	}
};
static_assert(alignof(UTWStaticMeshComponent) == 0x000010, "Wrong alignment on UTWStaticMeshComponent");
static_assert(sizeof(UTWStaticMeshComponent) == 0x000490, "Wrong size on UTWStaticMeshComponent");
static_assert(offsetof(UTWStaticMeshComponent, CustomProjection) == 0x000470, "Member 'UTWStaticMeshComponent::CustomProjection' has a wrong offset!");

// Class TimeWatch.TWStoreGlobals
// 0x00A0 (0x00C8 - 0x0028)
class UTWStoreGlobals : public UObject
{
public:
	class UTWCharacterDataAsset*                  DefaultCharacterDataAsset;                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWCharacterDataAsset*>          AvailableCharactersData;                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWWeaponDataAsset*>             DefaultLoadoutDataAssets;                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWWeaponDataAsset*>             PlayableWeaponsData;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWPlayerTitleDataAsset*>        PlayerTitlesData;                                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UTWItemDataAsset*>  GameItems;                                         // 0x0070(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UObject*                                ContextCache;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWStoreGlobals">();
	}
	static class UTWStoreGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWStoreGlobals>();
	}
};
static_assert(alignof(UTWStoreGlobals) == 0x000008, "Wrong alignment on UTWStoreGlobals");
static_assert(sizeof(UTWStoreGlobals) == 0x0000C8, "Wrong size on UTWStoreGlobals");
static_assert(offsetof(UTWStoreGlobals, DefaultCharacterDataAsset) == 0x000028, "Member 'UTWStoreGlobals::DefaultCharacterDataAsset' has a wrong offset!");
static_assert(offsetof(UTWStoreGlobals, AvailableCharactersData) == 0x000030, "Member 'UTWStoreGlobals::AvailableCharactersData' has a wrong offset!");
static_assert(offsetof(UTWStoreGlobals, DefaultLoadoutDataAssets) == 0x000040, "Member 'UTWStoreGlobals::DefaultLoadoutDataAssets' has a wrong offset!");
static_assert(offsetof(UTWStoreGlobals, PlayableWeaponsData) == 0x000050, "Member 'UTWStoreGlobals::PlayableWeaponsData' has a wrong offset!");
static_assert(offsetof(UTWStoreGlobals, PlayerTitlesData) == 0x000060, "Member 'UTWStoreGlobals::PlayerTitlesData' has a wrong offset!");
static_assert(offsetof(UTWStoreGlobals, GameItems) == 0x000070, "Member 'UTWStoreGlobals::GameItems' has a wrong offset!");
static_assert(offsetof(UTWStoreGlobals, ContextCache) == 0x0000C0, "Member 'UTWStoreGlobals::ContextCache' has a wrong offset!");

// Class TimeWatch.TWStyleButtonWidget
// 0x00C0 (0x17F8 - 0x1738)
class UTWStyleButtonWidget : public UTWCustomizationButtonWidget
{
public:
	class UImage*                                 Image_Selected;                                    // 0x1738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Quark;                                       // 0x1740(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_RarityColor;                                 // 0x1748(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_SeasonalIcon;                                // 0x1750(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWTagWidget*                           Tag_FreeItem;                                      // 0x1758(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_Price;                                        // 0x1760(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1768[0x30];                                    // 0x1768(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWItemDataAsset*                       StyleData;                                         // 0x1798(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EButtonStyle, struct FLinearColor>       ButtonColorsMap;                                   // 0x17A0(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_17F0[0x8];                                     // 0x17F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStyleButtonClicked();
	void OnStyleButtonFocusChanged(bool IsFocused);
	void OnStyleButtonHovered();
	void OnStyleButtonRightClicked();
	void OnStyleButtonUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWStyleButtonWidget">();
	}
	static class UTWStyleButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWStyleButtonWidget>();
	}
};
static_assert(alignof(UTWStyleButtonWidget) == 0x000008, "Wrong alignment on UTWStyleButtonWidget");
static_assert(sizeof(UTWStyleButtonWidget) == 0x0017F8, "Wrong size on UTWStyleButtonWidget");
static_assert(offsetof(UTWStyleButtonWidget, Image_Selected) == 0x001738, "Member 'UTWStyleButtonWidget::Image_Selected' has a wrong offset!");
static_assert(offsetof(UTWStyleButtonWidget, Image_Quark) == 0x001740, "Member 'UTWStyleButtonWidget::Image_Quark' has a wrong offset!");
static_assert(offsetof(UTWStyleButtonWidget, Image_RarityColor) == 0x001748, "Member 'UTWStyleButtonWidget::Image_RarityColor' has a wrong offset!");
static_assert(offsetof(UTWStyleButtonWidget, Image_SeasonalIcon) == 0x001750, "Member 'UTWStyleButtonWidget::Image_SeasonalIcon' has a wrong offset!");
static_assert(offsetof(UTWStyleButtonWidget, Tag_FreeItem) == 0x001758, "Member 'UTWStyleButtonWidget::Tag_FreeItem' has a wrong offset!");
static_assert(offsetof(UTWStyleButtonWidget, Text_Price) == 0x001760, "Member 'UTWStyleButtonWidget::Text_Price' has a wrong offset!");
static_assert(offsetof(UTWStyleButtonWidget, StyleData) == 0x001798, "Member 'UTWStyleButtonWidget::StyleData' has a wrong offset!");
static_assert(offsetof(UTWStyleButtonWidget, ButtonColorsMap) == 0x0017A0, "Member 'UTWStyleButtonWidget::ButtonColorsMap' has a wrong offset!");

// Class TimeWatch.TWStylesDataAsset
// 0x0110 (0x01D0 - 0x00C0)
class UTWStylesDataAsset final : public UTWItemDataAsset
{
public:
	class FString                                 StyleIdentifier;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UI_StyleNameDisplay;                               // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             UI_StyleImage;                                     // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UI_VersusScreenLeftImage;                          // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UI_VersusScreenRigthImage;                         // 0x0118(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATimeWatchCharacter>        CharacterClass;                                    // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              PreviewAnimBp;                                     // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStyleEntry                            FPStyle;                                           // 0x0150(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FStyleEntry                            TPStyle;                                           // 0x0190(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWStylesDataAsset">();
	}
	static class UTWStylesDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWStylesDataAsset>();
	}
};
static_assert(alignof(UTWStylesDataAsset) == 0x000008, "Wrong alignment on UTWStylesDataAsset");
static_assert(sizeof(UTWStylesDataAsset) == 0x0001D0, "Wrong size on UTWStylesDataAsset");
static_assert(offsetof(UTWStylesDataAsset, StyleIdentifier) == 0x0000C0, "Member 'UTWStylesDataAsset::StyleIdentifier' has a wrong offset!");
static_assert(offsetof(UTWStylesDataAsset, UI_StyleNameDisplay) == 0x0000D0, "Member 'UTWStylesDataAsset::UI_StyleNameDisplay' has a wrong offset!");
static_assert(offsetof(UTWStylesDataAsset, UI_StyleImage) == 0x0000E8, "Member 'UTWStylesDataAsset::UI_StyleImage' has a wrong offset!");
static_assert(offsetof(UTWStylesDataAsset, UI_VersusScreenLeftImage) == 0x0000F0, "Member 'UTWStylesDataAsset::UI_VersusScreenLeftImage' has a wrong offset!");
static_assert(offsetof(UTWStylesDataAsset, UI_VersusScreenRigthImage) == 0x000118, "Member 'UTWStylesDataAsset::UI_VersusScreenRigthImage' has a wrong offset!");
static_assert(offsetof(UTWStylesDataAsset, CharacterClass) == 0x000140, "Member 'UTWStylesDataAsset::CharacterClass' has a wrong offset!");
static_assert(offsetof(UTWStylesDataAsset, PreviewAnimBp) == 0x000148, "Member 'UTWStylesDataAsset::PreviewAnimBp' has a wrong offset!");
static_assert(offsetof(UTWStylesDataAsset, FPStyle) == 0x000150, "Member 'UTWStylesDataAsset::FPStyle' has a wrong offset!");
static_assert(offsetof(UTWStylesDataAsset, TPStyle) == 0x000190, "Member 'UTWStylesDataAsset::TPStyle' has a wrong offset!");

// Class TimeWatch.TWSwitchInteractionsAuditor
// 0x0010 (0x00C0 - 0x00B0)
class UTWSwitchInteractionsAuditor final : public UActorComponent
{
public:
	TArray<struct FSwitchInteractionData>         InteractionArr;                                    // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWSwitchInteractionsAuditor">();
	}
	static class UTWSwitchInteractionsAuditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWSwitchInteractionsAuditor>();
	}
};
static_assert(alignof(UTWSwitchInteractionsAuditor) == 0x000008, "Wrong alignment on UTWSwitchInteractionsAuditor");
static_assert(sizeof(UTWSwitchInteractionsAuditor) == 0x0000C0, "Wrong size on UTWSwitchInteractionsAuditor");
static_assert(offsetof(UTWSwitchInteractionsAuditor, InteractionArr) == 0x0000B0, "Member 'UTWSwitchInteractionsAuditor::InteractionArr' has a wrong offset!");

// Class TimeWatch.TWTabWidget
// 0x0050 (0x02D0 - 0x0280)
class UTWTabWidget : public UNGDUserWidget
{
public:
	struct FLinearColor                           SelectedTextColor;                                 // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectedTextColor;                               // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   TitleText;                                         // 0x02A0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Selection;                                   // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TabTitle;                                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_Selection;                                  // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTabWidget">();
	}
	static class UTWTabWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTabWidget>();
	}
};
static_assert(alignof(UTWTabWidget) == 0x000008, "Wrong alignment on UTWTabWidget");
static_assert(sizeof(UTWTabWidget) == 0x0002D0, "Wrong size on UTWTabWidget");
static_assert(offsetof(UTWTabWidget, SelectedTextColor) == 0x000280, "Member 'UTWTabWidget::SelectedTextColor' has a wrong offset!");
static_assert(offsetof(UTWTabWidget, UnselectedTextColor) == 0x000290, "Member 'UTWTabWidget::UnselectedTextColor' has a wrong offset!");
static_assert(offsetof(UTWTabWidget, TitleText) == 0x0002A0, "Member 'UTWTabWidget::TitleText' has a wrong offset!");
static_assert(offsetof(UTWTabWidget, Image_Selection) == 0x0002B8, "Member 'UTWTabWidget::Image_Selection' has a wrong offset!");
static_assert(offsetof(UTWTabWidget, Text_TabTitle) == 0x0002C0, "Member 'UTWTabWidget::Text_TabTitle' has a wrong offset!");
static_assert(offsetof(UTWTabWidget, Button_Selection) == 0x0002C8, "Member 'UTWTabWidget::Button_Selection' has a wrong offset!");

// Class TimeWatch.TWTagWidget
// 0x0028 (0x02A8 - 0x0280)
class UTWTagWidget : public UNGDUserWidget
{
public:
	class FText                                   TitleText;                                         // 0x0280(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Selection;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TagTitle;                                     // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTagWidget">();
	}
	static class UTWTagWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTagWidget>();
	}
};
static_assert(alignof(UTWTagWidget) == 0x000008, "Wrong alignment on UTWTagWidget");
static_assert(sizeof(UTWTagWidget) == 0x0002A8, "Wrong size on UTWTagWidget");
static_assert(offsetof(UTWTagWidget, TitleText) == 0x000280, "Member 'UTWTagWidget::TitleText' has a wrong offset!");
static_assert(offsetof(UTWTagWidget, Image_Selection) == 0x000298, "Member 'UTWTagWidget::Image_Selection' has a wrong offset!");
static_assert(offsetof(UTWTagWidget, Text_TagTitle) == 0x0002A0, "Member 'UTWTagWidget::Text_TagTitle' has a wrong offset!");

// Class TimeWatch.TWTemporalEmitter
// 0x0060 (0x0110 - 0x00B0)
class UTWTemporalEmitter : public UActorComponent
{
public:
	bool                                          bIsLocal;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x00C0(0x0030)(Edit, BlueprintVisible, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mesh;                                              // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStaticMeshComponent*                 MeshComp;                                          // 0x00F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         QuailitySettings;                                  // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0xF];                                      // 0x0101(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTemporalEmitter">();
	}
	static class UTWTemporalEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTemporalEmitter>();
	}
};
static_assert(alignof(UTWTemporalEmitter) == 0x000010, "Wrong alignment on UTWTemporalEmitter");
static_assert(sizeof(UTWTemporalEmitter) == 0x000110, "Wrong size on UTWTemporalEmitter");
static_assert(offsetof(UTWTemporalEmitter, bIsLocal) == 0x0000B0, "Member 'UTWTemporalEmitter::bIsLocal' has a wrong offset!");
static_assert(offsetof(UTWTemporalEmitter, RelativeTransform) == 0x0000C0, "Member 'UTWTemporalEmitter::RelativeTransform' has a wrong offset!");
static_assert(offsetof(UTWTemporalEmitter, Mesh) == 0x0000F0, "Member 'UTWTemporalEmitter::Mesh' has a wrong offset!");
static_assert(offsetof(UTWTemporalEmitter, MeshComp) == 0x0000F8, "Member 'UTWTemporalEmitter::MeshComp' has a wrong offset!");
static_assert(offsetof(UTWTemporalEmitter, QuailitySettings) == 0x000100, "Member 'UTWTemporalEmitter::QuailitySettings' has a wrong offset!");

// Class TimeWatch.TWTimelineCloneInfo
// 0x0018 (0x0298 - 0x0280)
class UTWTimelineCloneInfo : public UNGDUserWidget
{
public:
	class UImage*                                 Image_CloneCircle;                                 // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_CloneNumber;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     GradientBaseMaterial;                              // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTimelineCloneInfo">();
	}
	static class UTWTimelineCloneInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTimelineCloneInfo>();
	}
};
static_assert(alignof(UTWTimelineCloneInfo) == 0x000008, "Wrong alignment on UTWTimelineCloneInfo");
static_assert(sizeof(UTWTimelineCloneInfo) == 0x000298, "Wrong size on UTWTimelineCloneInfo");
static_assert(offsetof(UTWTimelineCloneInfo, Image_CloneCircle) == 0x000280, "Member 'UTWTimelineCloneInfo::Image_CloneCircle' has a wrong offset!");
static_assert(offsetof(UTWTimelineCloneInfo, Text_CloneNumber) == 0x000288, "Member 'UTWTimelineCloneInfo::Text_CloneNumber' has a wrong offset!");
static_assert(offsetof(UTWTimelineCloneInfo, GradientBaseMaterial) == 0x000290, "Member 'UTWTimelineCloneInfo::GradientBaseMaterial' has a wrong offset!");

// Class TimeWatch.TWTimelinesWidget
// 0x00D8 (0x0358 - 0x0280)
class UTWTimelinesWidget : public UNGDUserWidget
{
public:
	class UProgressBar*                           ProgressBar_CurrentTimeline;                       // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PastTimelineLeft;                            // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PastTimelineRight;                           // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_PastTimelineLeft;                          // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_PastTimelineRight;                         // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_FutureTimelineLeft;                        // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_FutureTimelineRight;                       // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_TimelineContainer;                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWTimelineCloneInfo>       CloneInfoTemplate;                                 // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     LinearGradientBaseMaterial;                        // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CurrentTimelineGradientBaseMaterial;               // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NoScoreColor;                                      // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CurrentTimeline_NoScoreColor1;                     // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CurrentTimeline_NoScoreColor2;                     // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UTWTimelineCloneInfo*>      CloneInfoWidgets;                                  // 0x0308(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnTeamAdvantageChanged();
	void RefreshTimelinesColor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTimelinesWidget">();
	}
	static class UTWTimelinesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTimelinesWidget>();
	}
};
static_assert(alignof(UTWTimelinesWidget) == 0x000008, "Wrong alignment on UTWTimelinesWidget");
static_assert(sizeof(UTWTimelinesWidget) == 0x000358, "Wrong size on UTWTimelinesWidget");
static_assert(offsetof(UTWTimelinesWidget, ProgressBar_CurrentTimeline) == 0x000280, "Member 'UTWTimelinesWidget::ProgressBar_CurrentTimeline' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, Image_PastTimelineLeft) == 0x000288, "Member 'UTWTimelinesWidget::Image_PastTimelineLeft' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, Image_PastTimelineRight) == 0x000290, "Member 'UTWTimelinesWidget::Image_PastTimelineRight' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, Overlay_PastTimelineLeft) == 0x000298, "Member 'UTWTimelinesWidget::Overlay_PastTimelineLeft' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, Overlay_PastTimelineRight) == 0x0002A0, "Member 'UTWTimelinesWidget::Overlay_PastTimelineRight' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, Overlay_FutureTimelineLeft) == 0x0002A8, "Member 'UTWTimelinesWidget::Overlay_FutureTimelineLeft' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, Overlay_FutureTimelineRight) == 0x0002B0, "Member 'UTWTimelinesWidget::Overlay_FutureTimelineRight' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, CanvasPanel_TimelineContainer) == 0x0002B8, "Member 'UTWTimelinesWidget::CanvasPanel_TimelineContainer' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, CloneInfoTemplate) == 0x0002C0, "Member 'UTWTimelinesWidget::CloneInfoTemplate' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, LinearGradientBaseMaterial) == 0x0002C8, "Member 'UTWTimelinesWidget::LinearGradientBaseMaterial' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, CurrentTimelineGradientBaseMaterial) == 0x0002D0, "Member 'UTWTimelinesWidget::CurrentTimelineGradientBaseMaterial' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, NoScoreColor) == 0x0002D8, "Member 'UTWTimelinesWidget::NoScoreColor' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, CurrentTimeline_NoScoreColor1) == 0x0002E8, "Member 'UTWTimelinesWidget::CurrentTimeline_NoScoreColor1' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, CurrentTimeline_NoScoreColor2) == 0x0002F8, "Member 'UTWTimelinesWidget::CurrentTimeline_NoScoreColor2' has a wrong offset!");
static_assert(offsetof(UTWTimelinesWidget, CloneInfoWidgets) == 0x000308, "Member 'UTWTimelinesWidget::CloneInfoWidgets' has a wrong offset!");

// Class TimeWatch.TWTooltipListenerComponent
// 0x0010 (0x00C0 - 0x00B0)
class UTWTooltipListenerComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class FText Title, class FText Description, const class FString& NotificationID, int32 Priority, float Duration, float NotificationExpirationMax, TSubclassOf<class UWidgetTipNotification> DefaultWidgetClassOverride)> ListenerRuleCompleteDelegate; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void BP_BroadcastListenerRuleComplete(const class FText& Title, const class FText& Description, const class FString& NotificationID, int32 Priority, float Duration, float NotificationExpirationMax, TSubclassOf<class UWidgetTipNotification> DefaultWidgetClassOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTooltipListenerComponent">();
	}
	static class UTWTooltipListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTooltipListenerComponent>();
	}
};
static_assert(alignof(UTWTooltipListenerComponent) == 0x000008, "Wrong alignment on UTWTooltipListenerComponent");
static_assert(sizeof(UTWTooltipListenerComponent) == 0x0000C0, "Wrong size on UTWTooltipListenerComponent");
static_assert(offsetof(UTWTooltipListenerComponent, ListenerRuleCompleteDelegate) == 0x0000B0, "Member 'UTWTooltipListenerComponent::ListenerRuleCompleteDelegate' has a wrong offset!");

// Class TimeWatch.TWTournamentRankWidget
// 0x00A8 (0x02E0 - 0x0238)
class UTWTournamentRankWidget : public UUserWidgetBase
{
public:
	class UWidgetAnimation*                       Anim_PresentMedal;                                 // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Anim_PromoteFadeOut;                               // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Anim_PromoteFadeIn;                                // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_CurrentRankMedal;                            // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CurrentRankText;                         // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CurrentRankIcon;                             // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_NextRankIcon;                                // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_TournamentPoints;                      // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CurrentTournamentPointsText;             // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWLeagueDataAsset*                     LeaguesData;                                       // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             Delegate_OnPresentMedalFinished;                   // 0x0298(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             Delegate_OnMedalFadeOutFinished;                   // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             Delegate_OnMedalFadeInStarted;                     // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             Delegate_OnMedalFadeInFinished;                    // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTournamentRankWidget">();
	}
	static class UTWTournamentRankWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTournamentRankWidget>();
	}
};
static_assert(alignof(UTWTournamentRankWidget) == 0x000008, "Wrong alignment on UTWTournamentRankWidget");
static_assert(sizeof(UTWTournamentRankWidget) == 0x0002E0, "Wrong size on UTWTournamentRankWidget");
static_assert(offsetof(UTWTournamentRankWidget, Anim_PresentMedal) == 0x000238, "Member 'UTWTournamentRankWidget::Anim_PresentMedal' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Anim_PromoteFadeOut) == 0x000240, "Member 'UTWTournamentRankWidget::Anim_PromoteFadeOut' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Anim_PromoteFadeIn) == 0x000248, "Member 'UTWTournamentRankWidget::Anim_PromoteFadeIn' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Image_CurrentRankMedal) == 0x000250, "Member 'UTWTournamentRankWidget::Image_CurrentRankMedal' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, TextBlock_CurrentRankText) == 0x000258, "Member 'UTWTournamentRankWidget::TextBlock_CurrentRankText' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Image_CurrentRankIcon) == 0x000260, "Member 'UTWTournamentRankWidget::Image_CurrentRankIcon' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Image_NextRankIcon) == 0x000268, "Member 'UTWTournamentRankWidget::Image_NextRankIcon' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, ProgressBar_TournamentPoints) == 0x000270, "Member 'UTWTournamentRankWidget::ProgressBar_TournamentPoints' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, TextBlock_CurrentTournamentPointsText) == 0x000278, "Member 'UTWTournamentRankWidget::TextBlock_CurrentTournamentPointsText' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, LeaguesData) == 0x000280, "Member 'UTWTournamentRankWidget::LeaguesData' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Delegate_OnPresentMedalFinished) == 0x000298, "Member 'UTWTournamentRankWidget::Delegate_OnPresentMedalFinished' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Delegate_OnMedalFadeOutFinished) == 0x0002A8, "Member 'UTWTournamentRankWidget::Delegate_OnMedalFadeOutFinished' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Delegate_OnMedalFadeInStarted) == 0x0002B8, "Member 'UTWTournamentRankWidget::Delegate_OnMedalFadeInStarted' has a wrong offset!");
static_assert(offsetof(UTWTournamentRankWidget, Delegate_OnMedalFadeInFinished) == 0x0002C8, "Member 'UTWTournamentRankWidget::Delegate_OnMedalFadeInFinished' has a wrong offset!");

// Class TimeWatch.TWTrailComponent
// 0x0070 (0x0260 - 0x01F0)
class UTWTrailComponent final : public USceneComponent
{
public:
	class UStaticMesh*                            TrailMesh;                                         // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineMeshAxis                               TrailMeshAxis;                                     // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              TrailMaterial;                                     // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBounceTime;                                     // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineMeshScale;                                   // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleMaxLength;                                   // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleMaxAngleDegrees;                             // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    TrackedProjetile;                                  // 0x0220(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineMeshComponent*                   SplineStartCut;                                    // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineMeshComponent*                   SplineEndCut;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTrailPoint>                    Points;                                            // 0x0238(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x18];                                     // 0x0248(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentTime(float Time);
	void SetTrackedProjectile(class UPrimitiveComponent* InProjectile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTrailComponent">();
	}
	static class UTWTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTrailComponent>();
	}
};
static_assert(alignof(UTWTrailComponent) == 0x000010, "Wrong alignment on UTWTrailComponent");
static_assert(sizeof(UTWTrailComponent) == 0x000260, "Wrong size on UTWTrailComponent");
static_assert(offsetof(UTWTrailComponent, TrailMesh) == 0x0001F0, "Member 'UTWTrailComponent::TrailMesh' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, TrailMeshAxis) == 0x0001F8, "Member 'UTWTrailComponent::TrailMeshAxis' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, TrailMaterial) == 0x000200, "Member 'UTWTrailComponent::TrailMaterial' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, MinBounceTime) == 0x000208, "Member 'UTWTrailComponent::MinBounceTime' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, SplineMeshScale) == 0x00020C, "Member 'UTWTrailComponent::SplineMeshScale' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, SampleMaxLength) == 0x000210, "Member 'UTWTrailComponent::SampleMaxLength' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, SampleMaxAngleDegrees) == 0x000214, "Member 'UTWTrailComponent::SampleMaxAngleDegrees' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, LifeTime) == 0x000218, "Member 'UTWTrailComponent::LifeTime' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, TrackedProjetile) == 0x000220, "Member 'UTWTrailComponent::TrackedProjetile' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, SplineStartCut) == 0x000228, "Member 'UTWTrailComponent::SplineStartCut' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, SplineEndCut) == 0x000230, "Member 'UTWTrailComponent::SplineEndCut' has a wrong offset!");
static_assert(offsetof(UTWTrailComponent, Points) == 0x000238, "Member 'UTWTrailComponent::Points' has a wrong offset!");

// Class TimeWatch.TWTutorialEntryWidget
// 0x0068 (0x02E8 - 0x0280)
class UTWTutorialEntryWidget : public UNGDUserWidget
{
public:
	TMulticastInlineDelegate<void(class UTWTutorialEntryWidget* TutorialEntryClicked)> OnEntryClicked; // 0x0280(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UTWCustomizationButtonWidget*           Button_Trigger;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Tutorial_Icon;                                     // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Tutorial_Title;                                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TutorialCompleted_Image;                           // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TutorialLocked_Image;                              // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectedTextColor;                                 // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectedTextColor;                               // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnEntryInitialized();
	void OnClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTutorialEntryWidget">();
	}
	static class UTWTutorialEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWTutorialEntryWidget>();
	}
};
static_assert(alignof(UTWTutorialEntryWidget) == 0x000008, "Wrong alignment on UTWTutorialEntryWidget");
static_assert(sizeof(UTWTutorialEntryWidget) == 0x0002E8, "Wrong size on UTWTutorialEntryWidget");
static_assert(offsetof(UTWTutorialEntryWidget, OnEntryClicked) == 0x000280, "Member 'UTWTutorialEntryWidget::OnEntryClicked' has a wrong offset!");
static_assert(offsetof(UTWTutorialEntryWidget, Button_Trigger) == 0x000290, "Member 'UTWTutorialEntryWidget::Button_Trigger' has a wrong offset!");
static_assert(offsetof(UTWTutorialEntryWidget, Tutorial_Icon) == 0x000298, "Member 'UTWTutorialEntryWidget::Tutorial_Icon' has a wrong offset!");
static_assert(offsetof(UTWTutorialEntryWidget, Tutorial_Title) == 0x0002A0, "Member 'UTWTutorialEntryWidget::Tutorial_Title' has a wrong offset!");
static_assert(offsetof(UTWTutorialEntryWidget, TutorialCompleted_Image) == 0x0002A8, "Member 'UTWTutorialEntryWidget::TutorialCompleted_Image' has a wrong offset!");
static_assert(offsetof(UTWTutorialEntryWidget, TutorialLocked_Image) == 0x0002B0, "Member 'UTWTutorialEntryWidget::TutorialLocked_Image' has a wrong offset!");
static_assert(offsetof(UTWTutorialEntryWidget, SelectedTextColor) == 0x0002B8, "Member 'UTWTutorialEntryWidget::SelectedTextColor' has a wrong offset!");
static_assert(offsetof(UTWTutorialEntryWidget, UnselectedTextColor) == 0x0002C8, "Member 'UTWTutorialEntryWidget::UnselectedTextColor' has a wrong offset!");

// Class TimeWatch.TWTutorialHUD
// 0x0000 (0x0528 - 0x0528)
class ATWTutorialHUD final : public ATimeWatchHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTutorialHUD">();
	}
	static class ATWTutorialHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWTutorialHUD>();
	}
};
static_assert(alignof(ATWTutorialHUD) == 0x000008, "Wrong alignment on ATWTutorialHUD");
static_assert(sizeof(ATWTutorialHUD) == 0x000528, "Wrong size on ATWTutorialHUD");

// Class TimeWatch.TWTutorialTooltipManager
// 0x00D0 (0x02E8 - 0x0218)
class ATWTutorialTooltipManager : public AActor
{
public:
	TMulticastInlineDelegate<void()>              ReviveDelegate;                                    // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              DesyncDelegate;                                    // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              ScoredKillDelegate;                                // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              RoundStartedDelegate;                              // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FriendlyFireDelegate;                              // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 SelectedWeapon)> SelectedWeaponDelegate;                     // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 CurrentRound)> RoundFinishedDelegate;                        // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool EmptyClip)> EmptyClipDelegate;                                // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EGameModeType GameModeType)> CurrentGameModeDelegate;              // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool PlayerScored)> RoundScoreDelegate;                            // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 CurrentLoop)> LoopFinishedDelegate;                          // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ETWCauseOfDeath CauseOfDeath)> PlayerKilledDelegate;               // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ETWBasicPlayerAction BasicPlayerActionUse)> BasicPlayerAction;     // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnListenerRuleComplete(const class FText& Title, const class FText& Description, const class FString& NotificationID, int32 Priority, float Duration, float NotificationExpirationMax, TSubclassOf<class UWidgetTipNotification> DefaultWidgetClassOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWTutorialTooltipManager">();
	}
	static class ATWTutorialTooltipManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWTutorialTooltipManager>();
	}
};
static_assert(alignof(ATWTutorialTooltipManager) == 0x000008, "Wrong alignment on ATWTutorialTooltipManager");
static_assert(sizeof(ATWTutorialTooltipManager) == 0x0002E8, "Wrong size on ATWTutorialTooltipManager");
static_assert(offsetof(ATWTutorialTooltipManager, ReviveDelegate) == 0x000218, "Member 'ATWTutorialTooltipManager::ReviveDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, DesyncDelegate) == 0x000228, "Member 'ATWTutorialTooltipManager::DesyncDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, ScoredKillDelegate) == 0x000238, "Member 'ATWTutorialTooltipManager::ScoredKillDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, RoundStartedDelegate) == 0x000248, "Member 'ATWTutorialTooltipManager::RoundStartedDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, FriendlyFireDelegate) == 0x000258, "Member 'ATWTutorialTooltipManager::FriendlyFireDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, SelectedWeaponDelegate) == 0x000268, "Member 'ATWTutorialTooltipManager::SelectedWeaponDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, RoundFinishedDelegate) == 0x000278, "Member 'ATWTutorialTooltipManager::RoundFinishedDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, EmptyClipDelegate) == 0x000288, "Member 'ATWTutorialTooltipManager::EmptyClipDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, CurrentGameModeDelegate) == 0x000298, "Member 'ATWTutorialTooltipManager::CurrentGameModeDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, RoundScoreDelegate) == 0x0002A8, "Member 'ATWTutorialTooltipManager::RoundScoreDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, LoopFinishedDelegate) == 0x0002B8, "Member 'ATWTutorialTooltipManager::LoopFinishedDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, PlayerKilledDelegate) == 0x0002C8, "Member 'ATWTutorialTooltipManager::PlayerKilledDelegate' has a wrong offset!");
static_assert(offsetof(ATWTutorialTooltipManager, BasicPlayerAction) == 0x0002D8, "Member 'ATWTutorialTooltipManager::BasicPlayerAction' has a wrong offset!");

// Class TimeWatch.TWVideoWidget
// 0x0028 (0x02A8 - 0x0280)
class UTWVideoWidget final : public UNGDUserWidget
{
public:
	class UMediaPlayer*                           MediaPlayer;                                       // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaSource*                           MediaSource;                                       // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0290(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayVideo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWVideoWidget">();
	}
	static class UTWVideoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWVideoWidget>();
	}
};
static_assert(alignof(UTWVideoWidget) == 0x000008, "Wrong alignment on UTWVideoWidget");
static_assert(sizeof(UTWVideoWidget) == 0x0002A8, "Wrong size on UTWVideoWidget");
static_assert(offsetof(UTWVideoWidget, MediaPlayer) == 0x000280, "Member 'UTWVideoWidget::MediaPlayer' has a wrong offset!");
static_assert(offsetof(UTWVideoWidget, MediaSource) == 0x000288, "Member 'UTWVideoWidget::MediaSource' has a wrong offset!");
static_assert(offsetof(UTWVideoWidget, Key) == 0x000290, "Member 'UTWVideoWidget::Key' has a wrong offset!");

// Class TimeWatch.TWWeaponDataAsset
// 0x00A0 (0x0160 - 0x00C0)
class UTWWeaponDataAsset final : public UTWItemDataAsset
{
public:
	struct FTWWeaponEntry                         WeaponEntry;                                       // 0x00C0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTWWeaponStyleDataAsset*                DefaultStyleDataAsset;                             // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTWWeaponStyleDataAsset*>        AvailableStyles;                                   // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                PreviewActorWorldPosition;                         // 0x0130(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RewardTrackPreviewActorWorldPosition;              // 0x013C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RewardTrackPreviewActorFullPreviewPosition;        // 0x0148(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DailyStorePreviewActorWorldPosition;               // 0x0154(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWWeaponDataAsset">();
	}
	static class UTWWeaponDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWWeaponDataAsset>();
	}
};
static_assert(alignof(UTWWeaponDataAsset) == 0x000008, "Wrong alignment on UTWWeaponDataAsset");
static_assert(sizeof(UTWWeaponDataAsset) == 0x000160, "Wrong size on UTWWeaponDataAsset");
static_assert(offsetof(UTWWeaponDataAsset, WeaponEntry) == 0x0000C0, "Member 'UTWWeaponDataAsset::WeaponEntry' has a wrong offset!");
static_assert(offsetof(UTWWeaponDataAsset, DefaultStyleDataAsset) == 0x000118, "Member 'UTWWeaponDataAsset::DefaultStyleDataAsset' has a wrong offset!");
static_assert(offsetof(UTWWeaponDataAsset, AvailableStyles) == 0x000120, "Member 'UTWWeaponDataAsset::AvailableStyles' has a wrong offset!");
static_assert(offsetof(UTWWeaponDataAsset, PreviewActorWorldPosition) == 0x000130, "Member 'UTWWeaponDataAsset::PreviewActorWorldPosition' has a wrong offset!");
static_assert(offsetof(UTWWeaponDataAsset, RewardTrackPreviewActorWorldPosition) == 0x00013C, "Member 'UTWWeaponDataAsset::RewardTrackPreviewActorWorldPosition' has a wrong offset!");
static_assert(offsetof(UTWWeaponDataAsset, RewardTrackPreviewActorFullPreviewPosition) == 0x000148, "Member 'UTWWeaponDataAsset::RewardTrackPreviewActorFullPreviewPosition' has a wrong offset!");
static_assert(offsetof(UTWWeaponDataAsset, DailyStorePreviewActorWorldPosition) == 0x000154, "Member 'UTWWeaponDataAsset::DailyStorePreviewActorWorldPosition' has a wrong offset!");

// Class TimeWatch.TWWeaponSelectionSlot
// 0x0020 (0x02A0 - 0x0280)
class UTWWeaponSelectionSlot : public UNGDUserWidget
{
public:
	class UOverlay*                               Overlay_ConstantScale;                             // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActionLabel*                           Label_Keybind;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_WeaponName;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_WeaponImage;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_SetDesiredStatus(bool bIsDesiredWeapon);
	void SetDesiredStatus(bool bIsDesiredWeapon);
	void SetWeaponImage(class UTexture2D* NewWeaponImage, bool bMatchSize);
	void SetWeaponImageVisibility(ESlateVisibility InVisibility);
	void SetWeaponName(const class FString& WeaponName);
	void SetWeaponNumber(const int32 WeaponNumber);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWWeaponSelectionSlot">();
	}
	static class UTWWeaponSelectionSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWWeaponSelectionSlot>();
	}
};
static_assert(alignof(UTWWeaponSelectionSlot) == 0x000008, "Wrong alignment on UTWWeaponSelectionSlot");
static_assert(sizeof(UTWWeaponSelectionSlot) == 0x0002A0, "Wrong size on UTWWeaponSelectionSlot");
static_assert(offsetof(UTWWeaponSelectionSlot, Overlay_ConstantScale) == 0x000280, "Member 'UTWWeaponSelectionSlot::Overlay_ConstantScale' has a wrong offset!");
static_assert(offsetof(UTWWeaponSelectionSlot, Label_Keybind) == 0x000288, "Member 'UTWWeaponSelectionSlot::Label_Keybind' has a wrong offset!");
static_assert(offsetof(UTWWeaponSelectionSlot, Text_WeaponName) == 0x000290, "Member 'UTWWeaponSelectionSlot::Text_WeaponName' has a wrong offset!");
static_assert(offsetof(UTWWeaponSelectionSlot, Image_WeaponImage) == 0x000298, "Member 'UTWWeaponSelectionSlot::Image_WeaponImage' has a wrong offset!");

// Class TimeWatch.TWWeaponSkinPreviewActor
// 0x0030 (0x0248 - 0x0218)
class ATWWeaponSkinPreviewActor : public AActor
{
public:
	float                                         SpinningCharacterMouseSpeedFactor;                 // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlayerController>       LocalPlayerController;                             // 0x021C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        CustomRootComponent;                               // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SkeletalMeshSceneComponent;                        // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkinSkeletalMeshComponent;                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindPlayerInput();
	void OnFireButtonDown();
	void OnFireButtonUp();
	void OnYawInput(float InValue);
	void UnbindPlayerInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWWeaponSkinPreviewActor">();
	}
	static class ATWWeaponSkinPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATWWeaponSkinPreviewActor>();
	}
};
static_assert(alignof(ATWWeaponSkinPreviewActor) == 0x000008, "Wrong alignment on ATWWeaponSkinPreviewActor");
static_assert(sizeof(ATWWeaponSkinPreviewActor) == 0x000248, "Wrong size on ATWWeaponSkinPreviewActor");
static_assert(offsetof(ATWWeaponSkinPreviewActor, SpinningCharacterMouseSpeedFactor) == 0x000218, "Member 'ATWWeaponSkinPreviewActor::SpinningCharacterMouseSpeedFactor' has a wrong offset!");
static_assert(offsetof(ATWWeaponSkinPreviewActor, LocalPlayerController) == 0x00021C, "Member 'ATWWeaponSkinPreviewActor::LocalPlayerController' has a wrong offset!");
static_assert(offsetof(ATWWeaponSkinPreviewActor, CustomRootComponent) == 0x000228, "Member 'ATWWeaponSkinPreviewActor::CustomRootComponent' has a wrong offset!");
static_assert(offsetof(ATWWeaponSkinPreviewActor, SkeletalMeshSceneComponent) == 0x000230, "Member 'ATWWeaponSkinPreviewActor::SkeletalMeshSceneComponent' has a wrong offset!");
static_assert(offsetof(ATWWeaponSkinPreviewActor, SkinSkeletalMeshComponent) == 0x000238, "Member 'ATWWeaponSkinPreviewActor::SkinSkeletalMeshComponent' has a wrong offset!");

// Class TimeWatch.TWWeaponStyleDataAsset
// 0x0050 (0x0110 - 0x00C0)
class UTWWeaponStyleDataAsset final : public UTWItemDataAsset
{
public:
	struct FTWWeaponStyleEntry                    StyleEntry;                                        // 0x00C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TWWeaponStyleDataAsset">();
	}
	static class UTWWeaponStyleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTWWeaponStyleDataAsset>();
	}
};
static_assert(alignof(UTWWeaponStyleDataAsset) == 0x000008, "Wrong alignment on UTWWeaponStyleDataAsset");
static_assert(sizeof(UTWWeaponStyleDataAsset) == 0x000110, "Wrong size on UTWWeaponStyleDataAsset");
static_assert(offsetof(UTWWeaponStyleDataAsset, StyleEntry) == 0x0000C0, "Member 'UTWWeaponStyleDataAsset::StyleEntry' has a wrong offset!");

// Class TimeWatch.WCPlaybookInfoOverlay
// 0x0018 (0x0260 - 0x0248)
class UWCPlaybookInfoOverlay : public UNGDWidgetContainer
{
public:
	class UImage*                                 Image_Icon;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Title;                                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeOverlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WCPlaybookInfoOverlay">();
	}
	static class UWCPlaybookInfoOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWCPlaybookInfoOverlay>();
	}
};
static_assert(alignof(UWCPlaybookInfoOverlay) == 0x000008, "Wrong alignment on UWCPlaybookInfoOverlay");
static_assert(sizeof(UWCPlaybookInfoOverlay) == 0x000260, "Wrong size on UWCPlaybookInfoOverlay");
static_assert(offsetof(UWCPlaybookInfoOverlay, Image_Icon) == 0x000248, "Member 'UWCPlaybookInfoOverlay::Image_Icon' has a wrong offset!");
static_assert(offsetof(UWCPlaybookInfoOverlay, Text_Title) == 0x000250, "Member 'UWCPlaybookInfoOverlay::Text_Title' has a wrong offset!");
static_assert(offsetof(UWCPlaybookInfoOverlay, Text_Description) == 0x000258, "Member 'UWCPlaybookInfoOverlay::Text_Description' has a wrong offset!");

// Class TimeWatch.WeaponSelectionComponent
// 0x0020 (0x00D0 - 0x00B0)
class UWeaponSelectionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ATimeWatchCharacter*                    OwnerCharacter;                                    // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATimeWatchHUD*                          PlayerHud;                                         // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetContainerWeaponStatus*           WeaponSelectionWidget;                             // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnGameStateChange(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnHUDReset(class UWidgetContainerWeaponStatus* InWeaponSelectionWidget);

	int32 GetCurrentWeaponSlotIndex() const;
	int32 GetHoldsteredWeaponSlotIndex() const;
	bool HasSelectedWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSelectionComponent">();
	}
	static class UWeaponSelectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSelectionComponent>();
	}
};
static_assert(alignof(UWeaponSelectionComponent) == 0x000008, "Wrong alignment on UWeaponSelectionComponent");
static_assert(sizeof(UWeaponSelectionComponent) == 0x0000D0, "Wrong size on UWeaponSelectionComponent");
static_assert(offsetof(UWeaponSelectionComponent, OwnerCharacter) == 0x0000B8, "Member 'UWeaponSelectionComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UWeaponSelectionComponent, PlayerHud) == 0x0000C0, "Member 'UWeaponSelectionComponent::PlayerHud' has a wrong offset!");
static_assert(offsetof(UWeaponSelectionComponent, WeaponSelectionWidget) == 0x0000C8, "Member 'UWeaponSelectionComponent::WeaponSelectionWidget' has a wrong offset!");

// Class TimeWatch.WidgetContainer2DCompasses
// 0x00F8 (0x0340 - 0x0248)
class UWidgetContainer2DCompasses : public UNGDWidgetContainer
{
public:
	class UCanvasPanel*                           RootCanvas;                                        // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UTW2DCompass>, struct FWidgetInstancesData> CompassesInstancesData;       // 0x0250(0x0050)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTW2DCompass>               PingCompassClass;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTW2DCompass>               CaptureCompassClass;                               // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTW2DCompass>               HealthpackCompassClass;                            // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTW2DCompass>               ExplosionCompassClass;                             // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTW2DCompass>               RevivedCloneCompassClass;                          // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AActor>, struct FExplosionFeedbackConfig> ExplosionFeedbackConfigMap;     // 0x02C8(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         RevivedFeedbackDuration;                           // 0x0318(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTWActorCompass*>                ExplosionInstances;                                // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWActorCompass*>                RevivedClonesInstances;                            // 0x0330(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	class UTW2DCompass* AddCompassInstance(TSubclassOf<class UTW2DCompass> CompassClass);
	TArray<class UTW2DCompass*> GetCompassInstances(TSubclassOf<class UTW2DCompass> CompassClass);
	void OnPingAdded(const struct FPingMarker& NewPing);
	void OnPingRemoved(int32 PingID);
	void OnRevivedCloneEventReceived(class UTimeWatchEvent* Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainer2DCompasses">();
	}
	static class UWidgetContainer2DCompasses* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainer2DCompasses>();
	}
};
static_assert(alignof(UWidgetContainer2DCompasses) == 0x000008, "Wrong alignment on UWidgetContainer2DCompasses");
static_assert(sizeof(UWidgetContainer2DCompasses) == 0x000340, "Wrong size on UWidgetContainer2DCompasses");
static_assert(offsetof(UWidgetContainer2DCompasses, RootCanvas) == 0x000248, "Member 'UWidgetContainer2DCompasses::RootCanvas' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, CompassesInstancesData) == 0x000250, "Member 'UWidgetContainer2DCompasses::CompassesInstancesData' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, PingCompassClass) == 0x0002A0, "Member 'UWidgetContainer2DCompasses::PingCompassClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, CaptureCompassClass) == 0x0002A8, "Member 'UWidgetContainer2DCompasses::CaptureCompassClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, HealthpackCompassClass) == 0x0002B0, "Member 'UWidgetContainer2DCompasses::HealthpackCompassClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, ExplosionCompassClass) == 0x0002B8, "Member 'UWidgetContainer2DCompasses::ExplosionCompassClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, RevivedCloneCompassClass) == 0x0002C0, "Member 'UWidgetContainer2DCompasses::RevivedCloneCompassClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, ExplosionFeedbackConfigMap) == 0x0002C8, "Member 'UWidgetContainer2DCompasses::ExplosionFeedbackConfigMap' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, RevivedFeedbackDuration) == 0x000318, "Member 'UWidgetContainer2DCompasses::RevivedFeedbackDuration' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, ExplosionInstances) == 0x000320, "Member 'UWidgetContainer2DCompasses::ExplosionInstances' has a wrong offset!");
static_assert(offsetof(UWidgetContainer2DCompasses, RevivedClonesInstances) == 0x000330, "Member 'UWidgetContainer2DCompasses::RevivedClonesInstances' has a wrong offset!");

// Class TimeWatch.WidgetContainerCharSelection
// 0x0218 (0x0460 - 0x0248)
class UWidgetContainerCharSelection : public UNGDWidgetContainer
{
public:
	class UHorizontalBox*                         HorizontalBox_CharacterButtons;                    // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_TeammateInfo;                          // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ScreenTimer;                                  // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_GameModeType;                                 // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_GameModeExplanation;                          // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_CharacterName;                                // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_MapName;                                      // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TeammateName;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TeammateCharacterName;                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_QueueType;                                    // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_ScreenState;                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LocalPlayerName;                              // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_TeammateAbilityIcon;                         // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_GameModeIcon;                                // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_TimeLeft;                              // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_SelectCharacter;                              // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<float, float>                            AspectRatioToBackgroundDistance;                   // 0x02C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LocalPlayerAbilityDescription;                // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LocalPlayerAbilityIcon;                      // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LocalPlayerAbilityName;                       // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWCharacterButtonWidget>   CharacterButtonWidgetClass;                        // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWMatchQueuesDataAsset*                MatchQueuesDataAsset;                              // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATWSkinPreviewActor>        PreviewActorBP;                                    // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     BGActorBP;                                         // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CharacterButtonWidth;                              // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CharacterButtonHeigth;                             // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTeamNameLength;                                 // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                CharacterButtonsPadding;                           // 0x035C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreviewerFOV;                                      // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocalPlayerPreviewOffsetPosition;                  // 0x0374(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RemotePlayerPreviewOffsetPosition;                 // 0x0380(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UTWCharacterButtonWidget*> AvailableCharactersButtons;                 // 0x0390(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         CharacterButtonsNavigation;                        // 0x03E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentCharacterIndex;                             // 0x03F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWCharacterDataAsset*                  CurrentlyShownCharacterData;                       // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWCharacterDataAsset*                  CurrentSelectedCharacterData;                      // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWSkinPreviewActor*                    LocalPlayerSkinPreviewActor;                       // 0x0408(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWSkinPreviewActor*                    RemotePlayerSkinPreviewActor;                      // 0x0410(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 BackgroundActor;                                   // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFluxPlayerState*                       RemotePlayer;                                      // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWCameraViewTargetPoint*               CameraViewTarget;                                  // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x2C];                                     // 0x0430(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigationCooldown;                                // 0x045C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleKeySelect();
	void HandleNavigation(float Value);
	void OnCharacterHovered(const class UTWCharacterDataAsset* HoveredCharacterData);
	void OnCharacterUnhovered(const class UTWCharacterDataAsset* UnhoveredCharacterData);
	void OnRemotePlayerCustomizationChanged();
	void OnSelectCharacter(const class UTWCharacterDataAsset* SelectedCharacterData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerCharSelection">();
	}
	static class UWidgetContainerCharSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerCharSelection>();
	}
};
static_assert(alignof(UWidgetContainerCharSelection) == 0x000008, "Wrong alignment on UWidgetContainerCharSelection");
static_assert(sizeof(UWidgetContainerCharSelection) == 0x000460, "Wrong size on UWidgetContainerCharSelection");
static_assert(offsetof(UWidgetContainerCharSelection, HorizontalBox_CharacterButtons) == 0x000248, "Member 'UWidgetContainerCharSelection::HorizontalBox_CharacterButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, VerticalBox_TeammateInfo) == 0x000250, "Member 'UWidgetContainerCharSelection::VerticalBox_TeammateInfo' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_ScreenTimer) == 0x000258, "Member 'UWidgetContainerCharSelection::Text_ScreenTimer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_GameModeType) == 0x000260, "Member 'UWidgetContainerCharSelection::Text_GameModeType' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_GameModeExplanation) == 0x000268, "Member 'UWidgetContainerCharSelection::Text_GameModeExplanation' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_CharacterName) == 0x000270, "Member 'UWidgetContainerCharSelection::Text_CharacterName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_MapName) == 0x000278, "Member 'UWidgetContainerCharSelection::Text_MapName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_TeammateName) == 0x000280, "Member 'UWidgetContainerCharSelection::Text_TeammateName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_TeammateCharacterName) == 0x000288, "Member 'UWidgetContainerCharSelection::Text_TeammateCharacterName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_QueueType) == 0x000290, "Member 'UWidgetContainerCharSelection::Text_QueueType' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, WidgetSwitcher_ScreenState) == 0x000298, "Member 'UWidgetContainerCharSelection::WidgetSwitcher_ScreenState' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_LocalPlayerName) == 0x0002A0, "Member 'UWidgetContainerCharSelection::Text_LocalPlayerName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Image_TeammateAbilityIcon) == 0x0002A8, "Member 'UWidgetContainerCharSelection::Image_TeammateAbilityIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Image_GameModeIcon) == 0x0002B0, "Member 'UWidgetContainerCharSelection::Image_GameModeIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, ProgressBar_TimeLeft) == 0x0002B8, "Member 'UWidgetContainerCharSelection::ProgressBar_TimeLeft' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_SelectCharacter) == 0x0002C0, "Member 'UWidgetContainerCharSelection::Text_SelectCharacter' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, AspectRatioToBackgroundDistance) == 0x0002C8, "Member 'UWidgetContainerCharSelection::AspectRatioToBackgroundDistance' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_LocalPlayerAbilityDescription) == 0x000318, "Member 'UWidgetContainerCharSelection::Text_LocalPlayerAbilityDescription' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Image_LocalPlayerAbilityIcon) == 0x000320, "Member 'UWidgetContainerCharSelection::Image_LocalPlayerAbilityIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, Text_LocalPlayerAbilityName) == 0x000328, "Member 'UWidgetContainerCharSelection::Text_LocalPlayerAbilityName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CharacterButtonWidgetClass) == 0x000330, "Member 'UWidgetContainerCharSelection::CharacterButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, MatchQueuesDataAsset) == 0x000338, "Member 'UWidgetContainerCharSelection::MatchQueuesDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, PreviewActorBP) == 0x000340, "Member 'UWidgetContainerCharSelection::PreviewActorBP' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, BGActorBP) == 0x000348, "Member 'UWidgetContainerCharSelection::BGActorBP' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CharacterButtonWidth) == 0x000350, "Member 'UWidgetContainerCharSelection::CharacterButtonWidth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CharacterButtonHeigth) == 0x000354, "Member 'UWidgetContainerCharSelection::CharacterButtonHeigth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, MaxTeamNameLength) == 0x000358, "Member 'UWidgetContainerCharSelection::MaxTeamNameLength' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CharacterButtonsPadding) == 0x00035C, "Member 'UWidgetContainerCharSelection::CharacterButtonsPadding' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, PreviewerFOV) == 0x000370, "Member 'UWidgetContainerCharSelection::PreviewerFOV' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, LocalPlayerPreviewOffsetPosition) == 0x000374, "Member 'UWidgetContainerCharSelection::LocalPlayerPreviewOffsetPosition' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, RemotePlayerPreviewOffsetPosition) == 0x000380, "Member 'UWidgetContainerCharSelection::RemotePlayerPreviewOffsetPosition' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, AvailableCharactersButtons) == 0x000390, "Member 'UWidgetContainerCharSelection::AvailableCharactersButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CharacterButtonsNavigation) == 0x0003E0, "Member 'UWidgetContainerCharSelection::CharacterButtonsNavigation' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CurrentCharacterIndex) == 0x0003F0, "Member 'UWidgetContainerCharSelection::CurrentCharacterIndex' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CurrentlyShownCharacterData) == 0x0003F8, "Member 'UWidgetContainerCharSelection::CurrentlyShownCharacterData' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CurrentSelectedCharacterData) == 0x000400, "Member 'UWidgetContainerCharSelection::CurrentSelectedCharacterData' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, LocalPlayerSkinPreviewActor) == 0x000408, "Member 'UWidgetContainerCharSelection::LocalPlayerSkinPreviewActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, RemotePlayerSkinPreviewActor) == 0x000410, "Member 'UWidgetContainerCharSelection::RemotePlayerSkinPreviewActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, BackgroundActor) == 0x000418, "Member 'UWidgetContainerCharSelection::BackgroundActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, RemotePlayer) == 0x000420, "Member 'UWidgetContainerCharSelection::RemotePlayer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, CameraViewTarget) == 0x000428, "Member 'UWidgetContainerCharSelection::CameraViewTarget' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCharSelection, NavigationCooldown) == 0x00045C, "Member 'UWidgetContainerCharSelection::NavigationCooldown' has a wrong offset!");

// Class TimeWatch.WidgetContainerClonesOnPoint
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerClonesOnPoint : public UNGDWidgetContainer
{
public:
	class UTWClonesOnPointWidget*                 ClonesOnPointWidget;                               // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerClonesOnPoint">();
	}
	static class UWidgetContainerClonesOnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerClonesOnPoint>();
	}
};
static_assert(alignof(UWidgetContainerClonesOnPoint) == 0x000008, "Wrong alignment on UWidgetContainerClonesOnPoint");
static_assert(sizeof(UWidgetContainerClonesOnPoint) == 0x000250, "Wrong size on UWidgetContainerClonesOnPoint");
static_assert(offsetof(UWidgetContainerClonesOnPoint, ClonesOnPointWidget) == 0x000248, "Member 'UWidgetContainerClonesOnPoint::ClonesOnPointWidget' has a wrong offset!");

// Class TimeWatch.WidgetContainerCooldownCounter
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerCooldownCounter : public UNGDWidgetContainer
{
public:
	class UCanvasPanel*                           CanvasPanel_CooldownCounterCanvas;                 // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerCooldownCounter">();
	}
	static class UWidgetContainerCooldownCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerCooldownCounter>();
	}
};
static_assert(alignof(UWidgetContainerCooldownCounter) == 0x000008, "Wrong alignment on UWidgetContainerCooldownCounter");
static_assert(sizeof(UWidgetContainerCooldownCounter) == 0x000250, "Wrong size on UWidgetContainerCooldownCounter");
static_assert(offsetof(UWidgetContainerCooldownCounter, CanvasPanel_CooldownCounterCanvas) == 0x000248, "Member 'UWidgetContainerCooldownCounter::CanvasPanel_CooldownCounterCanvas' has a wrong offset!");

// Class TimeWatch.WidgetContainerCornerPlayerProfile
// 0x0060 (0x02A8 - 0x0248)
class UWidgetContainerCornerPlayerProfile : public UNGDWidgetContainer
{
public:
	class UTWRewardsDataAsset*                    RewardsDataAsset;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxAllowedUsernameLength;                          // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextBlock_UserNameText;                            // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_LevelText;                               // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_PlayerTitle;                             // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_XPRadialProgressBar;                         // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ProfileImage;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PartyHostIcon;                                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_UserCredits;                             // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_FriendList;                                 // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_Options;                                    // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFriendListButtonClicked();
	void OnOptionsClicked();
	void OnPartyStatusUpdate(const bool bPartyStructureChanged);
	void OnPlayerDataUpdateComplete(bool bWasSuccessful, const class FString& ErrorString);
	void SetButtonsVisibility(ESlateVisibility InVisibility);
	void SetUserAvatar();
	void SetUserLevel(int32 InCurrentXP);
	void SetUsername(const class FString& Name_0);
	void SetXPBarProgress(int32 InCurrentXP);
	void UpdatePlayerData(const class FString& InUserName, int32 InPlayerXP);
	void UpdatePlayerTitleText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerCornerPlayerProfile">();
	}
	static class UWidgetContainerCornerPlayerProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerCornerPlayerProfile>();
	}
};
static_assert(alignof(UWidgetContainerCornerPlayerProfile) == 0x000008, "Wrong alignment on UWidgetContainerCornerPlayerProfile");
static_assert(sizeof(UWidgetContainerCornerPlayerProfile) == 0x0002A8, "Wrong size on UWidgetContainerCornerPlayerProfile");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, RewardsDataAsset) == 0x000248, "Member 'UWidgetContainerCornerPlayerProfile::RewardsDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, MaxAllowedUsernameLength) == 0x000250, "Member 'UWidgetContainerCornerPlayerProfile::MaxAllowedUsernameLength' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, TextBlock_UserNameText) == 0x000258, "Member 'UWidgetContainerCornerPlayerProfile::TextBlock_UserNameText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, TextBlock_LevelText) == 0x000260, "Member 'UWidgetContainerCornerPlayerProfile::TextBlock_LevelText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, TextBlock_PlayerTitle) == 0x000268, "Member 'UWidgetContainerCornerPlayerProfile::TextBlock_PlayerTitle' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, Image_XPRadialProgressBar) == 0x000270, "Member 'UWidgetContainerCornerPlayerProfile::Image_XPRadialProgressBar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, Image_ProfileImage) == 0x000278, "Member 'UWidgetContainerCornerPlayerProfile::Image_ProfileImage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, PartyHostIcon) == 0x000280, "Member 'UWidgetContainerCornerPlayerProfile::PartyHostIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, TextBlock_UserCredits) == 0x000288, "Member 'UWidgetContainerCornerPlayerProfile::TextBlock_UserCredits' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, Button_FriendList) == 0x000290, "Member 'UWidgetContainerCornerPlayerProfile::Button_FriendList' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCornerPlayerProfile, Button_Options) == 0x000298, "Member 'UWidgetContainerCornerPlayerProfile::Button_Options' has a wrong offset!");

// Class TimeWatch.WidgetContainerCredits
// 0x0000 (0x0248 - 0x0248)
class UWidgetContainerCredits : public UNGDWidgetContainer
{
public:
	void GoToMainMenu();
	void OnBackButtonPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerCredits">();
	}
	static class UWidgetContainerCredits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerCredits>();
	}
};
static_assert(alignof(UWidgetContainerCredits) == 0x000008, "Wrong alignment on UWidgetContainerCredits");
static_assert(sizeof(UWidgetContainerCredits) == 0x000248, "Wrong size on UWidgetContainerCredits");

// Class TimeWatch.WidgetContainerCrosshair
// 0x0010 (0x0258 - 0x0248)
class UWidgetContainerCrosshair : public UNGDWidgetContainer
{
public:
	class UNGDCrosshairWidget*                    WeaponCrosshairWidget;                             // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasPanel_CrosshairCanvas;                       // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerCrosshair">();
	}
	static class UWidgetContainerCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerCrosshair>();
	}
};
static_assert(alignof(UWidgetContainerCrosshair) == 0x000008, "Wrong alignment on UWidgetContainerCrosshair");
static_assert(sizeof(UWidgetContainerCrosshair) == 0x000258, "Wrong size on UWidgetContainerCrosshair");
static_assert(offsetof(UWidgetContainerCrosshair, WeaponCrosshairWidget) == 0x000248, "Member 'UWidgetContainerCrosshair::WeaponCrosshairWidget' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCrosshair, CanvasPanel_CrosshairCanvas) == 0x000250, "Member 'UWidgetContainerCrosshair::CanvasPanel_CrosshairCanvas' has a wrong offset!");

// Class TimeWatch.WidgetContainerCustomization
// 0x0308 (0x0550 - 0x0248)
class UWidgetContainerCustomization : public UNGDWidgetContainer
{
public:
	float                                         CharacterButtonWidth;                              // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterButtonHeigth;                             // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StyleButtonWidth;                                  // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StyleButtonHeigth;                                 // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWRewardsDataAsset*                    RewardsDataAsset;                                  // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWSkinPreviewActor*                    SkinPreviewActor;                                  // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LobbyTitleName;                                    // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENGDBackendItemRarity, struct FRarityInfo> RarityConfig;                                    // 0x0280(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWCharacterButtonWidget>   CharacterButtonWidgetClass;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWStyleButtonWidget>       StyleButtonWidgetClass;                            // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWAbilityDescriptionWidget> AbilityDescriptionWidgetClass;                    // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWLeagueDataAsset*                     LeagueDataAsset;                                   // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UTWCharacterButtonWidget*> AvailableCharactersButtons;                 // 0x02F0(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UTWStyleButtonWidget*> AvailableStylesButtons;                         // 0x0340(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FWidgetNavigationData                  BorderButtonsRightNavigationData;                  // 0x0390(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FWidgetNavigationData                  BorderButtonsDownNavigationData;                   // 0x03B4(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_PriceText;                               // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_TabButtons;                          // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_SkinsTab;                                   // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGridPanel*                             GridPanel_CharacterSelectionPanel;                 // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ScreenName;                              // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ItemName;                                // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Requirement;                             // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         TextBlock_OutfitRarity;                            // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CharacterDescription;                    // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_CharacterSelectionScroll;                // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_ContextualAction;                           // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_StylesScroll;                            // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_PassiveAbilities;                      // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_TabSwitcher;                        // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECustomizationFlowState                       CurrentFlowState;                                  // 0x0448(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextBlock_RightClickAction;                        // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightClick;                                  // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_VersusPreview;                               // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_VersusPreviewL;                              // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_Background;                            // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPremiumBannerWidget*                 PremiumBannerWidget;                               // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLoadingCustomization;                           // 0x0488(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBuyingItem;                                     // 0x0489(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48A[0x2];                                      // 0x048A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterGridMaxColumnCount;                       // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTWCharacterDataAsset*>          CharacterDataAssets;                               // 0x04A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UTWCharacterDataAsset*                  CurrentSelectedCharacterData;                      // 0x04B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTWStylesDataAsset*                     CurrentStyleData;                                  // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCharacterSelectionEntry               CurrentLoadedEntry;                                // 0x04C0(0x0028)(NativeAccessSpecifierPrivate)
	struct FCharacterSelectionEntry               PinnedEntry;                                       // 0x04E8(0x0028)(NativeAccessSpecifierPrivate)
	struct FCharacterSelectionEntry               ActiveEntry;                                       // 0x0510(0x0028)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SkinLoadTimerHandle;                               // 0x0548(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_OnActiveWidgetChanged(ECustomizationFlowState State);
	void BP_OnBuyItemSuccess();
	void BP_OnSkinsTabButtonClicked();
	void BuyCharacter();
	void BuyStyle();
	void CustomizeSelection();
	void DebugShowVersusPreviews();
	void EquipStyleItem();
	void FirstLoadCompleteChecker();
	void GoToCharacterSelection();
	void GoToMainMenu();
	void InitializeCharacterSelectionWidget();
	void InitializeSkinPreviewActor();
	void OnBackButtonClicked();
	void OnBackgroundHovered();
	void OnBackgroundPressed();
	void OnBuyCharacterClicked();
	void OnBuyCharacterComplete(bool bWasSuccessful, const class FString& ErrorString, const class FString& SKU, int32 newCoinsAmmount);
	void OnBuyStyleClicked();
	void OnBuyStyleComplete(bool bWasSuccessful, const class FString& ErrorString, const class FString& SKU, int32 newCoinsAmmount);
	void OnCharacterClicked(const class UTWCharacterDataAsset* SelectedCharacterData);
	void OnCharacterHovered(const class UTWCharacterDataAsset* HoveredCharacterData);
	void OnCharacterRightClick(const class UTWCharacterDataAsset* SelectedCharacterData);
	void OnFirstLoadComplete();
	void OnSkinsTabButtonClicked();
	void OnStyleAsyncLoadComplete();
	void OnStyleClicked(const class UTWItemDataAsset* SelectedStyleData);
	void OnStyleHovered(const class UTWItemDataAsset* SelectedStyleData);
	void OnUnlockPremiumButtonClicked();
	void OpenPremiumPopup();
	void RefreshAvailableCharacterSelections();
	void RefreshAvailableStylesSelection();
	void SetFlowState(ECustomizationFlowState NewState);
	void TryEquipCurrentItem();
	void TryEquipItem(const class UTWItemDataAsset* SelectedStyleData);
	void TryUnlockItem();

	class AMainMenuHUD* GetMainMenuHud() const;
	bool IsApplyStyleButtonEnabled() const;
	bool IsApplyStyleButtonVisible() const;
	bool IsCustomizeCharacterButtonEnabled() const;
	bool IsSetActiveCharacterButtonEnabled() const;
	bool IsSetActiveCharacterButtonVisible() const;
	bool IsStylesTabButtonEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerCustomization">();
	}
	static class UWidgetContainerCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerCustomization>();
	}
};
static_assert(alignof(UWidgetContainerCustomization) == 0x000008, "Wrong alignment on UWidgetContainerCustomization");
static_assert(sizeof(UWidgetContainerCustomization) == 0x000550, "Wrong size on UWidgetContainerCustomization");
static_assert(offsetof(UWidgetContainerCustomization, CharacterButtonWidth) == 0x000248, "Member 'UWidgetContainerCustomization::CharacterButtonWidth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CharacterButtonHeigth) == 0x00024C, "Member 'UWidgetContainerCustomization::CharacterButtonHeigth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, StyleButtonWidth) == 0x000250, "Member 'UWidgetContainerCustomization::StyleButtonWidth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, StyleButtonHeigth) == 0x000254, "Member 'UWidgetContainerCustomization::StyleButtonHeigth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, RewardsDataAsset) == 0x000258, "Member 'UWidgetContainerCustomization::RewardsDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, SkinPreviewActor) == 0x000260, "Member 'UWidgetContainerCustomization::SkinPreviewActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, LobbyTitleName) == 0x000268, "Member 'UWidgetContainerCustomization::LobbyTitleName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, RarityConfig) == 0x000280, "Member 'UWidgetContainerCustomization::RarityConfig' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CharacterButtonWidgetClass) == 0x0002D0, "Member 'UWidgetContainerCustomization::CharacterButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, StyleButtonWidgetClass) == 0x0002D8, "Member 'UWidgetContainerCustomization::StyleButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, AbilityDescriptionWidgetClass) == 0x0002E0, "Member 'UWidgetContainerCustomization::AbilityDescriptionWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, LeagueDataAsset) == 0x0002E8, "Member 'UWidgetContainerCustomization::LeagueDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, AvailableCharactersButtons) == 0x0002F0, "Member 'UWidgetContainerCustomization::AvailableCharactersButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, AvailableStylesButtons) == 0x000340, "Member 'UWidgetContainerCustomization::AvailableStylesButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, BorderButtonsRightNavigationData) == 0x000390, "Member 'UWidgetContainerCustomization::BorderButtonsRightNavigationData' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, BorderButtonsDownNavigationData) == 0x0003B4, "Member 'UWidgetContainerCustomization::BorderButtonsDownNavigationData' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, TextBlock_PriceText) == 0x0003D8, "Member 'UWidgetContainerCustomization::TextBlock_PriceText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, HorizontalBox_TabButtons) == 0x0003E0, "Member 'UWidgetContainerCustomization::HorizontalBox_TabButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, Button_SkinsTab) == 0x0003E8, "Member 'UWidgetContainerCustomization::Button_SkinsTab' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, GridPanel_CharacterSelectionPanel) == 0x0003F0, "Member 'UWidgetContainerCustomization::GridPanel_CharacterSelectionPanel' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, TextBlock_ScreenName) == 0x0003F8, "Member 'UWidgetContainerCustomization::TextBlock_ScreenName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, TextBlock_ItemName) == 0x000400, "Member 'UWidgetContainerCustomization::TextBlock_ItemName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, TextBlock_Requirement) == 0x000408, "Member 'UWidgetContainerCustomization::TextBlock_Requirement' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, TextBlock_OutfitRarity) == 0x000410, "Member 'UWidgetContainerCustomization::TextBlock_OutfitRarity' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, TextBlock_CharacterDescription) == 0x000418, "Member 'UWidgetContainerCustomization::TextBlock_CharacterDescription' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, ScrollBox_CharacterSelectionScroll) == 0x000420, "Member 'UWidgetContainerCustomization::ScrollBox_CharacterSelectionScroll' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, Button_ContextualAction) == 0x000428, "Member 'UWidgetContainerCustomization::Button_ContextualAction' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, ScrollBox_StylesScroll) == 0x000430, "Member 'UWidgetContainerCustomization::ScrollBox_StylesScroll' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, VerticalBox_PassiveAbilities) == 0x000438, "Member 'UWidgetContainerCustomization::VerticalBox_PassiveAbilities' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, WidgetSwitcher_TabSwitcher) == 0x000440, "Member 'UWidgetContainerCustomization::WidgetSwitcher_TabSwitcher' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CurrentFlowState) == 0x000448, "Member 'UWidgetContainerCustomization::CurrentFlowState' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, TextBlock_RightClickAction) == 0x000450, "Member 'UWidgetContainerCustomization::TextBlock_RightClickAction' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, Image_RightClick) == 0x000458, "Member 'UWidgetContainerCustomization::Image_RightClick' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, Button_BackButton) == 0x000460, "Member 'UWidgetContainerCustomization::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, Image_VersusPreview) == 0x000468, "Member 'UWidgetContainerCustomization::Image_VersusPreview' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, Image_VersusPreviewL) == 0x000470, "Member 'UWidgetContainerCustomization::Image_VersusPreviewL' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CanvasPanel_Background) == 0x000478, "Member 'UWidgetContainerCustomization::CanvasPanel_Background' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, PremiumBannerWidget) == 0x000480, "Member 'UWidgetContainerCustomization::PremiumBannerWidget' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, bIsLoadingCustomization) == 0x000488, "Member 'UWidgetContainerCustomization::bIsLoadingCustomization' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, bIsBuyingItem) == 0x000489, "Member 'UWidgetContainerCustomization::bIsBuyingItem' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CharacterGridMaxColumnCount) == 0x00048C, "Member 'UWidgetContainerCustomization::CharacterGridMaxColumnCount' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CharacterDataAssets) == 0x0004A0, "Member 'UWidgetContainerCustomization::CharacterDataAssets' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CurrentSelectedCharacterData) == 0x0004B0, "Member 'UWidgetContainerCustomization::CurrentSelectedCharacterData' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CurrentStyleData) == 0x0004B8, "Member 'UWidgetContainerCustomization::CurrentStyleData' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, CurrentLoadedEntry) == 0x0004C0, "Member 'UWidgetContainerCustomization::CurrentLoadedEntry' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, PinnedEntry) == 0x0004E8, "Member 'UWidgetContainerCustomization::PinnedEntry' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, ActiveEntry) == 0x000510, "Member 'UWidgetContainerCustomization::ActiveEntry' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomization, SkinLoadTimerHandle) == 0x000548, "Member 'UWidgetContainerCustomization::SkinLoadTimerHandle' has a wrong offset!");

// Class TimeWatch.WidgetContainerCustomMatch
// 0x00C8 (0x0310 - 0x0248)
class UWidgetContainerCustomMatch : public UNGDWidgetContainer
{
public:
	TMap<class FString, class UTWFriendRowWidget*> FriendRowMap;                                     // 0x0248(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWFriendRowWidget>         PlayerRowWidgetClass;                              // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_GridsContainer;                            // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_PreviousPageButton;                         // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_NextPageButton;                             // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_ChallengeButton;                            // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ChallengedName;                          // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGridPanel*>                     GridPanelArray;                                    // 0x02D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x4];                                      // 0x02E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxColumnsPerGrid;                                 // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRowsPerColumn;                                  // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x24];                                     // 0x02EC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNewGridPanel();
	void OnBackButtonClicked();
	void OnChallengeClicked();
	void OnFriendSelected(const class FString& FriendID, const class FString& FriendName);
	void OnLobbyCreated(const class FString& LobbyID);
	void OnNextPageButtonClicked();
	void OnPreviousPageButtonClicked();

	int32 GetCurrentPageIndex() const;
	int32 GetTotalPagesAmount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerCustomMatch">();
	}
	static class UWidgetContainerCustomMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerCustomMatch>();
	}
};
static_assert(alignof(UWidgetContainerCustomMatch) == 0x000008, "Wrong alignment on UWidgetContainerCustomMatch");
static_assert(sizeof(UWidgetContainerCustomMatch) == 0x000310, "Wrong size on UWidgetContainerCustomMatch");
static_assert(offsetof(UWidgetContainerCustomMatch, FriendRowMap) == 0x000248, "Member 'UWidgetContainerCustomMatch::FriendRowMap' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, PlayerRowWidgetClass) == 0x000298, "Member 'UWidgetContainerCustomMatch::PlayerRowWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, Overlay_GridsContainer) == 0x0002A0, "Member 'UWidgetContainerCustomMatch::Overlay_GridsContainer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, Button_PreviousPageButton) == 0x0002A8, "Member 'UWidgetContainerCustomMatch::Button_PreviousPageButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, Button_NextPageButton) == 0x0002B0, "Member 'UWidgetContainerCustomMatch::Button_NextPageButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, Button_BackButton) == 0x0002B8, "Member 'UWidgetContainerCustomMatch::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, Button_ChallengeButton) == 0x0002C0, "Member 'UWidgetContainerCustomMatch::Button_ChallengeButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, TextBlock_ChallengedName) == 0x0002C8, "Member 'UWidgetContainerCustomMatch::TextBlock_ChallengedName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, GridPanelArray) == 0x0002D0, "Member 'UWidgetContainerCustomMatch::GridPanelArray' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, MaxColumnsPerGrid) == 0x0002E4, "Member 'UWidgetContainerCustomMatch::MaxColumnsPerGrid' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatch, MaxRowsPerColumn) == 0x0002E8, "Member 'UWidgetContainerCustomMatch::MaxRowsPerColumn' has a wrong offset!");

// Class TimeWatch.WidgetContainerCustomMatchLobby
// 0x0010 (0x0258 - 0x0248)
class UWidgetContainerCustomMatchLobby final : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_LobbyStatusText;                         // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBackButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerCustomMatchLobby">();
	}
	static class UWidgetContainerCustomMatchLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerCustomMatchLobby>();
	}
};
static_assert(alignof(UWidgetContainerCustomMatchLobby) == 0x000008, "Wrong alignment on UWidgetContainerCustomMatchLobby");
static_assert(sizeof(UWidgetContainerCustomMatchLobby) == 0x000258, "Wrong size on UWidgetContainerCustomMatchLobby");
static_assert(offsetof(UWidgetContainerCustomMatchLobby, Button_BackButton) == 0x000248, "Member 'UWidgetContainerCustomMatchLobby::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerCustomMatchLobby, TextBlock_LobbyStatusText) == 0x000250, "Member 'UWidgetContainerCustomMatchLobby::TextBlock_LobbyStatusText' has a wrong offset!");

// Class TimeWatch.WidgetContainerDailyBoost
// 0x00F8 (0x0340 - 0x0248)
class UWidgetContainerDailyBoost : public UNGDWidgetContainer
{
public:
	struct FLinearColor                           SpecialColor;                                      // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IncompleteColor;                                   // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCircularThrobber*                      CircularThrobber_Loading;                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_ItemsContainer;                      // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Canvas_BoostStatus;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RichText_ConditionToReward;                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDailyBoostItemWidget>      DailyBoostItemClass;                               // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ERewardConditionType, class FText>       RewardsConditionText;                              // 0x0290(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FString>            JsonRewardTypeImageName;                           // 0x02E0(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FString                                 ExtraParameters;                                   // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerDataUpdateComplete(bool bWasSuccessful, const class FString& ErrorString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerDailyBoost">();
	}
	static class UWidgetContainerDailyBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerDailyBoost>();
	}
};
static_assert(alignof(UWidgetContainerDailyBoost) == 0x000008, "Wrong alignment on UWidgetContainerDailyBoost");
static_assert(sizeof(UWidgetContainerDailyBoost) == 0x000340, "Wrong size on UWidgetContainerDailyBoost");
static_assert(offsetof(UWidgetContainerDailyBoost, SpecialColor) == 0x000248, "Member 'UWidgetContainerDailyBoost::SpecialColor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, IncompleteColor) == 0x000258, "Member 'UWidgetContainerDailyBoost::IncompleteColor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, CircularThrobber_Loading) == 0x000268, "Member 'UWidgetContainerDailyBoost::CircularThrobber_Loading' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, HorizontalBox_ItemsContainer) == 0x000270, "Member 'UWidgetContainerDailyBoost::HorizontalBox_ItemsContainer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, Canvas_BoostStatus) == 0x000278, "Member 'UWidgetContainerDailyBoost::Canvas_BoostStatus' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, RichText_ConditionToReward) == 0x000280, "Member 'UWidgetContainerDailyBoost::RichText_ConditionToReward' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, DailyBoostItemClass) == 0x000288, "Member 'UWidgetContainerDailyBoost::DailyBoostItemClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, RewardsConditionText) == 0x000290, "Member 'UWidgetContainerDailyBoost::RewardsConditionText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, JsonRewardTypeImageName) == 0x0002E0, "Member 'UWidgetContainerDailyBoost::JsonRewardTypeImageName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDailyBoost, ExtraParameters) == 0x000330, "Member 'UWidgetContainerDailyBoost::ExtraParameters' has a wrong offset!");

// Class TimeWatch.WidgetContainerDeathFeedback
// 0x0020 (0x0268 - 0x0248)
class UWidgetContainerDeathFeedback : public UNGDWidgetContainer
{
public:
	float                                         DeathFeedbackTimeLimit;                            // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextBlock_GhostModeMessage;                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_DeathFeedbackMessage;                    // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerDeathFeedback">();
	}
	static class UWidgetContainerDeathFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerDeathFeedback>();
	}
};
static_assert(alignof(UWidgetContainerDeathFeedback) == 0x000008, "Wrong alignment on UWidgetContainerDeathFeedback");
static_assert(sizeof(UWidgetContainerDeathFeedback) == 0x000268, "Wrong size on UWidgetContainerDeathFeedback");
static_assert(offsetof(UWidgetContainerDeathFeedback, DeathFeedbackTimeLimit) == 0x000248, "Member 'UWidgetContainerDeathFeedback::DeathFeedbackTimeLimit' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDeathFeedback, TextBlock_GhostModeMessage) == 0x000250, "Member 'UWidgetContainerDeathFeedback::TextBlock_GhostModeMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDeathFeedback, TextBlock_DeathFeedbackMessage) == 0x000258, "Member 'UWidgetContainerDeathFeedback::TextBlock_DeathFeedbackMessage' has a wrong offset!");

// Class TimeWatch.WidgetContainerDeathMatchScore
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerDeathMatchScore : public UNGDWidgetContainer
{
public:
	class UTWDeathMatchKillsWidget*               DeathMatchKillsWidget;                             // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerDeathMatchScore">();
	}
	static class UWidgetContainerDeathMatchScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerDeathMatchScore>();
	}
};
static_assert(alignof(UWidgetContainerDeathMatchScore) == 0x000008, "Wrong alignment on UWidgetContainerDeathMatchScore");
static_assert(sizeof(UWidgetContainerDeathMatchScore) == 0x000250, "Wrong size on UWidgetContainerDeathMatchScore");
static_assert(offsetof(UWidgetContainerDeathMatchScore, DeathMatchKillsWidget) == 0x000248, "Member 'UWidgetContainerDeathMatchScore::DeathMatchKillsWidget' has a wrong offset!");

// Class TimeWatch.WidgetContainerDeathsSummary
// 0x0018 (0x0260 - 0x0248)
class UWidgetContainerDeathsSummary : public UNGDWidgetContainer
{
public:
	TSubclassOf<class UTWDeathFeedRow>            DeathFeedRowClass;                                 // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathFeedRowHeight;                                // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOfFeeds;                                  // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_SummaryBox;                            // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnGenericEventReceived(class UTimeWatchEvent* Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerDeathsSummary">();
	}
	static class UWidgetContainerDeathsSummary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerDeathsSummary>();
	}
};
static_assert(alignof(UWidgetContainerDeathsSummary) == 0x000008, "Wrong alignment on UWidgetContainerDeathsSummary");
static_assert(sizeof(UWidgetContainerDeathsSummary) == 0x000260, "Wrong size on UWidgetContainerDeathsSummary");
static_assert(offsetof(UWidgetContainerDeathsSummary, DeathFeedRowClass) == 0x000248, "Member 'UWidgetContainerDeathsSummary::DeathFeedRowClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDeathsSummary, DeathFeedRowHeight) == 0x000250, "Member 'UWidgetContainerDeathsSummary::DeathFeedRowHeight' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDeathsSummary, MaxNumberOfFeeds) == 0x000254, "Member 'UWidgetContainerDeathsSummary::MaxNumberOfFeeds' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDeathsSummary, VerticalBox_SummaryBox) == 0x000258, "Member 'UWidgetContainerDeathsSummary::VerticalBox_SummaryBox' has a wrong offset!");

// Class TimeWatch.WidgetContainerDominationScore
// 0x0040 (0x0288 - 0x0248)
class UWidgetContainerDominationScore final : public UNGDWidgetContainer
{
public:
	TArray<class ADominationAreaVolume*>          DominationPoints;                                  // 0x0248(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           DominationPointsNames;                             // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDominationScorePoint>      DominationScorePointClass;                         // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScorePointXSize;                                   // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScorePointYSize;                                   // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_DominationPoints;                    // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RetrieveDominationPoints();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerDominationScore">();
	}
	static class UWidgetContainerDominationScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerDominationScore>();
	}
};
static_assert(alignof(UWidgetContainerDominationScore) == 0x000008, "Wrong alignment on UWidgetContainerDominationScore");
static_assert(sizeof(UWidgetContainerDominationScore) == 0x000288, "Wrong size on UWidgetContainerDominationScore");
static_assert(offsetof(UWidgetContainerDominationScore, DominationPoints) == 0x000248, "Member 'UWidgetContainerDominationScore::DominationPoints' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDominationScore, DominationPointsNames) == 0x000258, "Member 'UWidgetContainerDominationScore::DominationPointsNames' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDominationScore, DominationScorePointClass) == 0x000268, "Member 'UWidgetContainerDominationScore::DominationScorePointClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDominationScore, ScorePointXSize) == 0x000270, "Member 'UWidgetContainerDominationScore::ScorePointXSize' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDominationScore, ScorePointYSize) == 0x000274, "Member 'UWidgetContainerDominationScore::ScorePointYSize' has a wrong offset!");
static_assert(offsetof(UWidgetContainerDominationScore, HorizontalBox_DominationPoints) == 0x000278, "Member 'UWidgetContainerDominationScore::HorizontalBox_DominationPoints' has a wrong offset!");

// Class TimeWatch.WidgetContainerFluxStateIcon
// 0x0018 (0x0260 - 0x0248)
class UWidgetContainerFluxStateIcon : public UNGDWidgetContainer
{
public:
	TArray<class FText>                           LoopsNames;                                        // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LoopName;                                     // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnStateChanged(EFluxCapacitorStates NewState);
	void PlayCycleNameAnimation();
	void PlayForwardAnimation();
	void PlayReverseAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerFluxStateIcon">();
	}
	static class UWidgetContainerFluxStateIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerFluxStateIcon>();
	}
};
static_assert(alignof(UWidgetContainerFluxStateIcon) == 0x000008, "Wrong alignment on UWidgetContainerFluxStateIcon");
static_assert(sizeof(UWidgetContainerFluxStateIcon) == 0x000260, "Wrong size on UWidgetContainerFluxStateIcon");
static_assert(offsetof(UWidgetContainerFluxStateIcon, LoopsNames) == 0x000248, "Member 'UWidgetContainerFluxStateIcon::LoopsNames' has a wrong offset!");
static_assert(offsetof(UWidgetContainerFluxStateIcon, Text_LoopName) == 0x000258, "Member 'UWidgetContainerFluxStateIcon::Text_LoopName' has a wrong offset!");

// Class TimeWatch.WidgetContainerFriendList
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerFriendList : public UNGDWidgetContainer
{
public:
	class UFriendsListWidget*                     Widget_FriendList;                                 // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerFriendList">();
	}
	static class UWidgetContainerFriendList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerFriendList>();
	}
};
static_assert(alignof(UWidgetContainerFriendList) == 0x000008, "Wrong alignment on UWidgetContainerFriendList");
static_assert(sizeof(UWidgetContainerFriendList) == 0x000250, "Wrong size on UWidgetContainerFriendList");
static_assert(offsetof(UWidgetContainerFriendList, Widget_FriendList) == 0x000248, "Member 'UWidgetContainerFriendList::Widget_FriendList' has a wrong offset!");

// Class TimeWatch.WidgetContainerGameEnded
// 0x0068 (0x02B0 - 0x0248)
class UWidgetContainerGameEnded final : public UNGDWidgetContainer
{
public:
	class FText                                   VictoryMessage;                                    // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DefeatMessage;                                     // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ForfeitMessage;                                    // 0x0278(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_MatchResultText;                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_EndConditionText;                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_VictoryBG;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_DefeatBG;                                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerGameEnded">();
	}
	static class UWidgetContainerGameEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerGameEnded>();
	}
};
static_assert(alignof(UWidgetContainerGameEnded) == 0x000008, "Wrong alignment on UWidgetContainerGameEnded");
static_assert(sizeof(UWidgetContainerGameEnded) == 0x0002B0, "Wrong size on UWidgetContainerGameEnded");
static_assert(offsetof(UWidgetContainerGameEnded, VictoryMessage) == 0x000248, "Member 'UWidgetContainerGameEnded::VictoryMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameEnded, DefeatMessage) == 0x000260, "Member 'UWidgetContainerGameEnded::DefeatMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameEnded, ForfeitMessage) == 0x000278, "Member 'UWidgetContainerGameEnded::ForfeitMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameEnded, TextBlock_MatchResultText) == 0x000290, "Member 'UWidgetContainerGameEnded::TextBlock_MatchResultText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameEnded, TextBlock_EndConditionText) == 0x000298, "Member 'UWidgetContainerGameEnded::TextBlock_EndConditionText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameEnded, Image_VictoryBG) == 0x0002A0, "Member 'UWidgetContainerGameEnded::Image_VictoryBG' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameEnded, Image_DefeatBG) == 0x0002A8, "Member 'UWidgetContainerGameEnded::Image_DefeatBG' has a wrong offset!");

// Class TimeWatch.WidgetContainerGameplayFeedback
// 0x0038 (0x0280 - 0x0248)
class UWidgetContainerGameplayFeedback : public UNGDWidgetContainer
{
public:
	class UPeripheralDamageWidget*                PeripheralDamageWidget_Right;                      // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPeripheralDamageWidget*                PeripheralDamageWidget_Left;                       // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPeripheralDamageWidget*                PeripheralDamageWidget_Top;                        // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPeripheralDamageWidget*                PeripheralDamageWidget_Bottom;                     // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            PeripheralDamageIntensityCurve;                    // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LowHealth;                                   // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PeripheralDamageDuration;                          // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShowLowHealthAt;                                   // 0x027C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerGameplayFeedback">();
	}
	static class UWidgetContainerGameplayFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerGameplayFeedback>();
	}
};
static_assert(alignof(UWidgetContainerGameplayFeedback) == 0x000008, "Wrong alignment on UWidgetContainerGameplayFeedback");
static_assert(sizeof(UWidgetContainerGameplayFeedback) == 0x000280, "Wrong size on UWidgetContainerGameplayFeedback");
static_assert(offsetof(UWidgetContainerGameplayFeedback, PeripheralDamageWidget_Right) == 0x000248, "Member 'UWidgetContainerGameplayFeedback::PeripheralDamageWidget_Right' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameplayFeedback, PeripheralDamageWidget_Left) == 0x000250, "Member 'UWidgetContainerGameplayFeedback::PeripheralDamageWidget_Left' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameplayFeedback, PeripheralDamageWidget_Top) == 0x000258, "Member 'UWidgetContainerGameplayFeedback::PeripheralDamageWidget_Top' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameplayFeedback, PeripheralDamageWidget_Bottom) == 0x000260, "Member 'UWidgetContainerGameplayFeedback::PeripheralDamageWidget_Bottom' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameplayFeedback, PeripheralDamageIntensityCurve) == 0x000268, "Member 'UWidgetContainerGameplayFeedback::PeripheralDamageIntensityCurve' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameplayFeedback, Image_LowHealth) == 0x000270, "Member 'UWidgetContainerGameplayFeedback::Image_LowHealth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameplayFeedback, PeripheralDamageDuration) == 0x000278, "Member 'UWidgetContainerGameplayFeedback::PeripheralDamageDuration' has a wrong offset!");
static_assert(offsetof(UWidgetContainerGameplayFeedback, ShowLowHealthAt) == 0x00027C, "Member 'UWidgetContainerGameplayFeedback::ShowLowHealthAt' has a wrong offset!");

// Class TimeWatch.WidgetContainerGetReady
// 0x0000 (0x0248 - 0x0248)
class UWidgetContainerGetReady final : public UNGDWidgetContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerGetReady">();
	}
	static class UWidgetContainerGetReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerGetReady>();
	}
};
static_assert(alignof(UWidgetContainerGetReady) == 0x000008, "Wrong alignment on UWidgetContainerGetReady");
static_assert(sizeof(UWidgetContainerGetReady) == 0x000248, "Wrong size on UWidgetContainerGetReady");

// Class TimeWatch.WidgetContainerInGameMenu
// 0x0048 (0x0290 - 0x0248)
class UWidgetContainerInGameMenu : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_ResumeButton;                               // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_OptionsButton;                              // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_LeaveGameButton;                            // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_CreditsButton;                              // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_RedeemCodeButton;                           // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_ExitToDesktopButton;                        // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackButtonClicked();
	void OnContinueInSkipChallengePopup();
	void OnCreditsClicked();
	void OnExitToDesktopClicked();
	void OnLeaveGameButtonClicked();
	void OnOptionsButtonClicked();
	void OnRedeemCodeClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerInGameMenu">();
	}
	static class UWidgetContainerInGameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerInGameMenu>();
	}
};
static_assert(alignof(UWidgetContainerInGameMenu) == 0x000008, "Wrong alignment on UWidgetContainerInGameMenu");
static_assert(sizeof(UWidgetContainerInGameMenu) == 0x000290, "Wrong size on UWidgetContainerInGameMenu");
static_assert(offsetof(UWidgetContainerInGameMenu, Button_ResumeButton) == 0x000248, "Member 'UWidgetContainerInGameMenu::Button_ResumeButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerInGameMenu, Button_OptionsButton) == 0x000250, "Member 'UWidgetContainerInGameMenu::Button_OptionsButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerInGameMenu, Button_LeaveGameButton) == 0x000258, "Member 'UWidgetContainerInGameMenu::Button_LeaveGameButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerInGameMenu, Button_CreditsButton) == 0x000260, "Member 'UWidgetContainerInGameMenu::Button_CreditsButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerInGameMenu, Button_RedeemCodeButton) == 0x000268, "Member 'UWidgetContainerInGameMenu::Button_RedeemCodeButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerInGameMenu, Button_ExitToDesktopButton) == 0x000270, "Member 'UWidgetContainerInGameMenu::Button_ExitToDesktopButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerInGameMenu, Button_BackButton) == 0x000278, "Member 'UWidgetContainerInGameMenu::Button_BackButton' has a wrong offset!");

// Class TimeWatch.WidgetContainerIntroUserNames
// 0x0020 (0x0268 - 0x0248)
class UWidgetContainerIntroUserNames final : public UNGDWidgetContainer
{
public:
	class UTextBlock*                             Text_LeftPlayerA;                                  // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LeftPlayerB;                                  // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RightPlayerA;                                 // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RightPlayerB;                                 // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerIntroUserNames">();
	}
	static class UWidgetContainerIntroUserNames* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerIntroUserNames>();
	}
};
static_assert(alignof(UWidgetContainerIntroUserNames) == 0x000008, "Wrong alignment on UWidgetContainerIntroUserNames");
static_assert(sizeof(UWidgetContainerIntroUserNames) == 0x000268, "Wrong size on UWidgetContainerIntroUserNames");
static_assert(offsetof(UWidgetContainerIntroUserNames, Text_LeftPlayerA) == 0x000248, "Member 'UWidgetContainerIntroUserNames::Text_LeftPlayerA' has a wrong offset!");
static_assert(offsetof(UWidgetContainerIntroUserNames, Text_LeftPlayerB) == 0x000250, "Member 'UWidgetContainerIntroUserNames::Text_LeftPlayerB' has a wrong offset!");
static_assert(offsetof(UWidgetContainerIntroUserNames, Text_RightPlayerA) == 0x000258, "Member 'UWidgetContainerIntroUserNames::Text_RightPlayerA' has a wrong offset!");
static_assert(offsetof(UWidgetContainerIntroUserNames, Text_RightPlayerB) == 0x000260, "Member 'UWidgetContainerIntroUserNames::Text_RightPlayerB' has a wrong offset!");

// Class TimeWatch.WidgetContainerKillConfirmation
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerKillConfirmation : public UNGDWidgetContainer
{
public:
	class UImage*                                 Image_Skull;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEnemyKilled(class ATimeWatchCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerKillConfirmation">();
	}
	static class UWidgetContainerKillConfirmation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerKillConfirmation>();
	}
};
static_assert(alignof(UWidgetContainerKillConfirmation) == 0x000008, "Wrong alignment on UWidgetContainerKillConfirmation");
static_assert(sizeof(UWidgetContainerKillConfirmation) == 0x000250, "Wrong size on UWidgetContainerKillConfirmation");
static_assert(offsetof(UWidgetContainerKillConfirmation, Image_Skull) == 0x000248, "Member 'UWidgetContainerKillConfirmation::Image_Skull' has a wrong offset!");

// Class TimeWatch.WidgetContainerLeaderboardSlot
// 0x0038 (0x0280 - 0x0248)
class UWidgetContainerLeaderboardSlot : public UNGDWidgetContainer
{
public:
	int32                                         MaxPlayerNameLength;                               // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextBlock_Rank;                                    // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Name;                                    // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Elo;                                     // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Dominance;                               // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Wins;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Losses;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetupLeaderboardSlot(int32 rank, const class FString& Name_0, int32 Elo, float Dominance, int32 Wins, int32 Losses);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerLeaderboardSlot">();
	}
	static class UWidgetContainerLeaderboardSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerLeaderboardSlot>();
	}
};
static_assert(alignof(UWidgetContainerLeaderboardSlot) == 0x000008, "Wrong alignment on UWidgetContainerLeaderboardSlot");
static_assert(sizeof(UWidgetContainerLeaderboardSlot) == 0x000280, "Wrong size on UWidgetContainerLeaderboardSlot");
static_assert(offsetof(UWidgetContainerLeaderboardSlot, MaxPlayerNameLength) == 0x000248, "Member 'UWidgetContainerLeaderboardSlot::MaxPlayerNameLength' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeaderboardSlot, TextBlock_Rank) == 0x000250, "Member 'UWidgetContainerLeaderboardSlot::TextBlock_Rank' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeaderboardSlot, TextBlock_Name) == 0x000258, "Member 'UWidgetContainerLeaderboardSlot::TextBlock_Name' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeaderboardSlot, TextBlock_Elo) == 0x000260, "Member 'UWidgetContainerLeaderboardSlot::TextBlock_Elo' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeaderboardSlot, TextBlock_Dominance) == 0x000268, "Member 'UWidgetContainerLeaderboardSlot::TextBlock_Dominance' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeaderboardSlot, TextBlock_Wins) == 0x000270, "Member 'UWidgetContainerLeaderboardSlot::TextBlock_Wins' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeaderboardSlot, TextBlock_Losses) == 0x000278, "Member 'UWidgetContainerLeaderboardSlot::TextBlock_Losses' has a wrong offset!");

// Class TimeWatch.WidgetContainerLeagueStatus
// 0x0048 (0x0290 - 0x0248)
class UWidgetContainerLeagueStatus : public UNGDWidgetContainer
{
public:
	class UTWLeagueDataAsset*                     LeagueDataAsset;                                   // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxItemsToDisplay;                                 // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ItemsPerRow;                                       // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWLeagueStatusItemWidget>  TWLeagueStatusItemWidgetClass;                     // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_NoLeague;                              // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Canvas_LeagueStatus;                               // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCircularThrobber*                      CircularThrobber_Loading;                          // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeagueIcon;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LeagueName;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      GridPanel_ItemsContainer;                          // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerLeagueStatus">();
	}
	static class UWidgetContainerLeagueStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerLeagueStatus>();
	}
};
static_assert(alignof(UWidgetContainerLeagueStatus) == 0x000008, "Wrong alignment on UWidgetContainerLeagueStatus");
static_assert(sizeof(UWidgetContainerLeagueStatus) == 0x000290, "Wrong size on UWidgetContainerLeagueStatus");
static_assert(offsetof(UWidgetContainerLeagueStatus, LeagueDataAsset) == 0x000248, "Member 'UWidgetContainerLeagueStatus::LeagueDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, MaxItemsToDisplay) == 0x000250, "Member 'UWidgetContainerLeagueStatus::MaxItemsToDisplay' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, ItemsPerRow) == 0x000254, "Member 'UWidgetContainerLeagueStatus::ItemsPerRow' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, TWLeagueStatusItemWidgetClass) == 0x000258, "Member 'UWidgetContainerLeagueStatus::TWLeagueStatusItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, VerticalBox_NoLeague) == 0x000260, "Member 'UWidgetContainerLeagueStatus::VerticalBox_NoLeague' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, Canvas_LeagueStatus) == 0x000268, "Member 'UWidgetContainerLeagueStatus::Canvas_LeagueStatus' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, CircularThrobber_Loading) == 0x000270, "Member 'UWidgetContainerLeagueStatus::CircularThrobber_Loading' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, Image_LeagueIcon) == 0x000278, "Member 'UWidgetContainerLeagueStatus::Image_LeagueIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, Text_LeagueName) == 0x000280, "Member 'UWidgetContainerLeagueStatus::Text_LeagueName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLeagueStatus, GridPanel_ItemsContainer) == 0x000288, "Member 'UWidgetContainerLeagueStatus::GridPanel_ItemsContainer' has a wrong offset!");

// Class TimeWatch.WidgetContainerLobbyMatchSettings
// 0x0120 (0x0368 - 0x0248)
class UWidgetContainerLobbyMatchSettings : public UNGDWidgetContainer
{
public:
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpinner*                               Spinner_Map;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNativeSliderSetting*                   Slider_LoopLength;                                 // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpinner*                               Spinner_PlayersSetup;                              // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpinner*                               Spinner_MatchPoints;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpinner*                               Spinner_ClonesCount;                               // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpinner*                               Spinner_HealthPackMode;                            // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpinner*                               Spinner_HealingMode;                               // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpinner*                               Spinner_WeaponMode;                                // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpinner*                               Spinner_OvertimeMode;                              // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpinner*                               Spinner_PassiveAbilitiesMode;                      // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_StartMatch;                                 // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_MapBackground;                               // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_Team1Slots;                            // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_Team2Slots;                            // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_SpectatorsSlots;                       // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_CantStartMatchReason;                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_GameModeName;                                 // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_SwitchTeam;                                 // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_ToggleSpectate;                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_HealingMode;                               // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWLevelEntry*>                  PlayableLevels;                                    // 0x0300(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      UnlockPremiumPopup;                                // 0x0310(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x20];                                     // 0x0348(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloneCountSelectionChanged(const class FString& Value);
	void HealingModeChanged(const class FString& Value);
	void HealthPackModeChanged(const class FString& Value);
	void LoopLengthSliderReleased();
	void MapSelectionChanged(const class FString& Value);
	void MatchScoreSelectionChanged(const class FString& Value);
	void OnBackButtonClicked();
	void OnMatchmakingTypeChange(ETWMatchmakingType MatchmakingType);
	void OnPartyDataUpdated(const bool bPartyStructureChanged);
	void OvertimeModeChanged(const class FString& Value);
	void PassiveAbilitiesModeChanged(const class FString& Value);
	void PlayersSetupChanged(const class FString& Value);
	void StartMatchButtonClicked();
	void SwitchTeam();
	void ToggleMatchSettingsSpinnerInteractable(class USpinner* Spinner, bool bInteractable);
	void ToggleSpectate();
	void WeaponModeChanged(const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerLobbyMatchSettings">();
	}
	static class UWidgetContainerLobbyMatchSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerLobbyMatchSettings>();
	}
};
static_assert(alignof(UWidgetContainerLobbyMatchSettings) == 0x000008, "Wrong alignment on UWidgetContainerLobbyMatchSettings");
static_assert(sizeof(UWidgetContainerLobbyMatchSettings) == 0x000368, "Wrong size on UWidgetContainerLobbyMatchSettings");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Button_BackButton) == 0x000258, "Member 'UWidgetContainerLobbyMatchSettings::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_Map) == 0x000260, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_Map' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Slider_LoopLength) == 0x000268, "Member 'UWidgetContainerLobbyMatchSettings::Slider_LoopLength' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_PlayersSetup) == 0x000270, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_PlayersSetup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_MatchPoints) == 0x000278, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_MatchPoints' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_ClonesCount) == 0x000280, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_ClonesCount' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_HealthPackMode) == 0x000288, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_HealthPackMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_HealingMode) == 0x000290, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_HealingMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_WeaponMode) == 0x000298, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_WeaponMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_OvertimeMode) == 0x0002A0, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_OvertimeMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Spinner_PassiveAbilitiesMode) == 0x0002A8, "Member 'UWidgetContainerLobbyMatchSettings::Spinner_PassiveAbilitiesMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Button_StartMatch) == 0x0002B0, "Member 'UWidgetContainerLobbyMatchSettings::Button_StartMatch' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Image_MapBackground) == 0x0002B8, "Member 'UWidgetContainerLobbyMatchSettings::Image_MapBackground' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, VerticalBox_Team1Slots) == 0x0002C0, "Member 'UWidgetContainerLobbyMatchSettings::VerticalBox_Team1Slots' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, VerticalBox_Team2Slots) == 0x0002C8, "Member 'UWidgetContainerLobbyMatchSettings::VerticalBox_Team2Slots' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, VerticalBox_SpectatorsSlots) == 0x0002D0, "Member 'UWidgetContainerLobbyMatchSettings::VerticalBox_SpectatorsSlots' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Text_CantStartMatchReason) == 0x0002D8, "Member 'UWidgetContainerLobbyMatchSettings::Text_CantStartMatchReason' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Text_GameModeName) == 0x0002E0, "Member 'UWidgetContainerLobbyMatchSettings::Text_GameModeName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Button_SwitchTeam) == 0x0002E8, "Member 'UWidgetContainerLobbyMatchSettings::Button_SwitchTeam' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Button_ToggleSpectate) == 0x0002F0, "Member 'UWidgetContainerLobbyMatchSettings::Button_ToggleSpectate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, Overlay_HealingMode) == 0x0002F8, "Member 'UWidgetContainerLobbyMatchSettings::Overlay_HealingMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, PlayableLevels) == 0x000300, "Member 'UWidgetContainerLobbyMatchSettings::PlayableLevels' has a wrong offset!");
static_assert(offsetof(UWidgetContainerLobbyMatchSettings, UnlockPremiumPopup) == 0x000310, "Member 'UWidgetContainerLobbyMatchSettings::UnlockPremiumPopup' has a wrong offset!");

// Class TimeWatch.WidgetContainerMainMenu
// 0x0110 (0x0358 - 0x0248)
class UWidgetContainerMainMenu : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_Customize;                                  // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_Store;                                      // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_WeaponCustomization;                        // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_PlayerProfile;                              // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_RewardTrack;                                // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_Tutorials;                                  // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWPremiumBannerWidget*                 PremiumBannerWidget;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Button_LocalServer;                                // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_StartListenServer;                          // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_NetworkStatus;                                // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_GameVersion;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCircularThrobber*                      CircularThrobber_Loading;                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWSkinPreviewActor*                    SkinPreviewActor;                                  // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      WelcomePopup;                                      // 0x02B0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      DailyBoostPopup;                                   // 0x02E8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      RankedUnlockedPopup;                               // 0x0320(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void EnableMainMenuButtons(bool bEnable);
	void GoToCustomizeOptions();
	void GoToPlayerProfile();
	void GoToRewardTrack();
	void GoToStore();
	void GoToTutorials();
	void OnListenServerButtonClicked();
	void OnLocalServerButtonClicked();
	void OnMatchmakingChange(ETWMatchmakingType MatchmakingType);
	void OnPartyDataUpdated(const bool bPartyStructureChanged);
	void OnUnlockPremiumButtonClicked();
	void OnWeaponCustomizationButtonClicked();
	void OpenPremiumPopup(const class FText& PopupTitle);
	void QuickCustomize();
	void QuitGame();
	void SetNetWorkStatus(const class FText& Version);
	void SetVersion(const class FString& Version);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMainMenu">();
	}
	static class UWidgetContainerMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMainMenu>();
	}
};
static_assert(alignof(UWidgetContainerMainMenu) == 0x000008, "Wrong alignment on UWidgetContainerMainMenu");
static_assert(sizeof(UWidgetContainerMainMenu) == 0x000358, "Wrong size on UWidgetContainerMainMenu");
static_assert(offsetof(UWidgetContainerMainMenu, Button_Customize) == 0x000248, "Member 'UWidgetContainerMainMenu::Button_Customize' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Button_Store) == 0x000250, "Member 'UWidgetContainerMainMenu::Button_Store' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Button_WeaponCustomization) == 0x000258, "Member 'UWidgetContainerMainMenu::Button_WeaponCustomization' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Button_PlayerProfile) == 0x000260, "Member 'UWidgetContainerMainMenu::Button_PlayerProfile' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Button_RewardTrack) == 0x000268, "Member 'UWidgetContainerMainMenu::Button_RewardTrack' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Button_Tutorials) == 0x000270, "Member 'UWidgetContainerMainMenu::Button_Tutorials' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, PremiumBannerWidget) == 0x000278, "Member 'UWidgetContainerMainMenu::PremiumBannerWidget' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Button_LocalServer) == 0x000280, "Member 'UWidgetContainerMainMenu::Button_LocalServer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Button_StartListenServer) == 0x000288, "Member 'UWidgetContainerMainMenu::Button_StartListenServer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Text_NetworkStatus) == 0x000290, "Member 'UWidgetContainerMainMenu::Text_NetworkStatus' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, Text_GameVersion) == 0x000298, "Member 'UWidgetContainerMainMenu::Text_GameVersion' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, CircularThrobber_Loading) == 0x0002A0, "Member 'UWidgetContainerMainMenu::CircularThrobber_Loading' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, SkinPreviewActor) == 0x0002A8, "Member 'UWidgetContainerMainMenu::SkinPreviewActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, WelcomePopup) == 0x0002B0, "Member 'UWidgetContainerMainMenu::WelcomePopup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, DailyBoostPopup) == 0x0002E8, "Member 'UWidgetContainerMainMenu::DailyBoostPopup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMainMenu, RankedUnlockedPopup) == 0x000320, "Member 'UWidgetContainerMainMenu::RankedUnlockedPopup' has a wrong offset!");

// Class TimeWatch.WidgetContainerMatchHistorySlot
// 0x0140 (0x03C0 - 0x0280)
class UWidgetContainerMatchHistorySlot : public UNGDUserWidget
{
public:
	class UTextBlock*                             TextBlock_GameMode;                                // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_Map;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_GameDuration;                            // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_GameDate;                                // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_GameResult;                              // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_PlayersData;                             // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_PlayReplay;                                 // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_KeepReplay;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerNamesText_MaxCharCount;                      // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0xEC];                                     // 0x02C4(0x00EC)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetContainerReplays*                WidgetContainerOwner;                              // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KeepReplay();
	void PlayReplay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMatchHistorySlot">();
	}
	static class UWidgetContainerMatchHistorySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMatchHistorySlot>();
	}
};
static_assert(alignof(UWidgetContainerMatchHistorySlot) == 0x000008, "Wrong alignment on UWidgetContainerMatchHistorySlot");
static_assert(sizeof(UWidgetContainerMatchHistorySlot) == 0x0003C0, "Wrong size on UWidgetContainerMatchHistorySlot");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, TextBlock_GameMode) == 0x000280, "Member 'UWidgetContainerMatchHistorySlot::TextBlock_GameMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, TextBlock_Map) == 0x000288, "Member 'UWidgetContainerMatchHistorySlot::TextBlock_Map' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, TextBlock_GameDuration) == 0x000290, "Member 'UWidgetContainerMatchHistorySlot::TextBlock_GameDuration' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, TextBlock_GameDate) == 0x000298, "Member 'UWidgetContainerMatchHistorySlot::TextBlock_GameDate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, TextBlock_GameResult) == 0x0002A0, "Member 'UWidgetContainerMatchHistorySlot::TextBlock_GameResult' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, TextBlock_PlayersData) == 0x0002A8, "Member 'UWidgetContainerMatchHistorySlot::TextBlock_PlayersData' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, Button_PlayReplay) == 0x0002B0, "Member 'UWidgetContainerMatchHistorySlot::Button_PlayReplay' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, Button_KeepReplay) == 0x0002B8, "Member 'UWidgetContainerMatchHistorySlot::Button_KeepReplay' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, PlayerNamesText_MaxCharCount) == 0x0002C0, "Member 'UWidgetContainerMatchHistorySlot::PlayerNamesText_MaxCharCount' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchHistorySlot, WidgetContainerOwner) == 0x0003B0, "Member 'UWidgetContainerMatchHistorySlot::WidgetContainerOwner' has a wrong offset!");

// Class TimeWatch.WidgetContainerMatchmaking
// 0x0088 (0x02D0 - 0x0248)
class UWidgetContainerMatchmaking : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_Cancel;                                     // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_Status;                                       // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CurrentTimeMinutes;                      // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CurrentTimeSeconds;                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        OnMatchFoundAudio;                                 // 0x0268(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableWidget();
	void EnableWidget();
	void OnCancelButtonPressed();
	void OnGameSessionPollComplete(bool bWasSuccessful, const class FString& Status, const class FString& PlayerSessionId, const class FString& IpAddress, int32 Port, const class FString& ErrorString);
	void OnMatchmakingChange(ETWMatchmakingType MatchmakingType);
	void OnMatchmakingPollComplete(bool bWasSuccessful, const class FString& Status, const class FString& PlayerSessionId, const class FString& IpAddress, int32 Port, const class FString& ErrorString);
	void OnMatchmakingStarted(ETWMatchmakingType MatchmakingType);
	void OnMatchmakingStopComplete(bool bWasSuccessful, const class FString& ErrorString);
	void OnMatchmakingStopped(ETWMatchmakingType MatchmakingType);

	bool IsMatchmakingCancelable() const;
	bool IsMatchmakingStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMatchmaking">();
	}
	static class UWidgetContainerMatchmaking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMatchmaking>();
	}
};
static_assert(alignof(UWidgetContainerMatchmaking) == 0x000008, "Wrong alignment on UWidgetContainerMatchmaking");
static_assert(sizeof(UWidgetContainerMatchmaking) == 0x0002D0, "Wrong size on UWidgetContainerMatchmaking");
static_assert(offsetof(UWidgetContainerMatchmaking, Button_Cancel) == 0x000248, "Member 'UWidgetContainerMatchmaking::Button_Cancel' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchmaking, Text_Status) == 0x000250, "Member 'UWidgetContainerMatchmaking::Text_Status' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchmaking, TextBlock_CurrentTimeMinutes) == 0x000258, "Member 'UWidgetContainerMatchmaking::TextBlock_CurrentTimeMinutes' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchmaking, TextBlock_CurrentTimeSeconds) == 0x000260, "Member 'UWidgetContainerMatchmaking::TextBlock_CurrentTimeSeconds' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchmaking, OnMatchFoundAudio) == 0x000268, "Member 'UWidgetContainerMatchmaking::OnMatchFoundAudio' has a wrong offset!");

// Class TimeWatch.WidgetContainerMatchOptions
// 0x0078 (0x02C0 - 0x0248)
class UWidgetContainerMatchOptions : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_Ready;                                      // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_PlaySelection;                              // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_PlaySelectionArrow;                          // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETWMatchQueueType, struct FMatchOptionData> MatchQueuesData;                                // 0x0260(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         CancelCooldownTime;                                // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0xC];                                      // 0x02B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_StartMatchCancelledAnim();
	void OnPartyDataUpdated(const bool bPartyStructureChanged);
	void OnPlaySelectionButtonClicked();
	void OnReadyButtonClicked();
	void UpdateButtonsStates(ETWMatchmakingType InMatchmakingType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMatchOptions">();
	}
	static class UWidgetContainerMatchOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMatchOptions>();
	}
};
static_assert(alignof(UWidgetContainerMatchOptions) == 0x000008, "Wrong alignment on UWidgetContainerMatchOptions");
static_assert(sizeof(UWidgetContainerMatchOptions) == 0x0002C0, "Wrong size on UWidgetContainerMatchOptions");
static_assert(offsetof(UWidgetContainerMatchOptions, Button_Ready) == 0x000248, "Member 'UWidgetContainerMatchOptions::Button_Ready' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchOptions, Button_PlaySelection) == 0x000250, "Member 'UWidgetContainerMatchOptions::Button_PlaySelection' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchOptions, Image_PlaySelectionArrow) == 0x000258, "Member 'UWidgetContainerMatchOptions::Image_PlaySelectionArrow' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchOptions, MatchQueuesData) == 0x000260, "Member 'UWidgetContainerMatchOptions::MatchQueuesData' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchOptions, CancelCooldownTime) == 0x0002B0, "Member 'UWidgetContainerMatchOptions::CancelCooldownTime' has a wrong offset!");

// Class TimeWatch.WidgetContainerMatchResultFeedback
// 0x0000 (0x0248 - 0x0248)
class UWidgetContainerMatchResultFeedback final : public UNGDWidgetContainer
{
public:
	void PlayDefeatAnimation();
	void PlaySpectatorBlueWinsAnimation();
	void PlaySpectatorRedWinsAnimation();
	void PlayVictoryAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMatchResultFeedback">();
	}
	static class UWidgetContainerMatchResultFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMatchResultFeedback>();
	}
};
static_assert(alignof(UWidgetContainerMatchResultFeedback) == 0x000008, "Wrong alignment on UWidgetContainerMatchResultFeedback");
static_assert(sizeof(UWidgetContainerMatchResultFeedback) == 0x000248, "Wrong size on UWidgetContainerMatchResultFeedback");

// Class TimeWatch.WidgetContainerMatchScore
// 0x00D8 (0x0320 - 0x0248)
class UWidgetContainerMatchScore final : public UNGDWidgetContainer
{
public:
	struct FLinearColor                           LocalColor;                                        // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           RemoteColor;                                       // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           WhiteColor;                                        // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Color_Team0;                                       // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Color_Team1;                                       // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchScoreData                        Data;                                              // 0x0298(0x0078)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_OwnerName;                                    // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_EnemyName;                                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FillPlayerNames(const class FString& Team0, const class FString& Team1);
	void FillRoundAndLoopText(int32 Round, int32 Loop);
	void SetPoints_BP();
	void UpdateScore();

	class ATimeWatchCharacter* GetTWCharacter() const;
	class ATimeWatchGameState* GetTWGameState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMatchScore">();
	}
	static class UWidgetContainerMatchScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMatchScore>();
	}
};
static_assert(alignof(UWidgetContainerMatchScore) == 0x000008, "Wrong alignment on UWidgetContainerMatchScore");
static_assert(sizeof(UWidgetContainerMatchScore) == 0x000320, "Wrong size on UWidgetContainerMatchScore");
static_assert(offsetof(UWidgetContainerMatchScore, LocalColor) == 0x000248, "Member 'UWidgetContainerMatchScore::LocalColor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchScore, RemoteColor) == 0x000258, "Member 'UWidgetContainerMatchScore::RemoteColor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchScore, WhiteColor) == 0x000268, "Member 'UWidgetContainerMatchScore::WhiteColor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchScore, Color_Team0) == 0x000278, "Member 'UWidgetContainerMatchScore::Color_Team0' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchScore, Color_Team1) == 0x000288, "Member 'UWidgetContainerMatchScore::Color_Team1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchScore, Data) == 0x000298, "Member 'UWidgetContainerMatchScore::Data' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchScore, Text_OwnerName) == 0x000310, "Member 'UWidgetContainerMatchScore::Text_OwnerName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchScore, Text_EnemyName) == 0x000318, "Member 'UWidgetContainerMatchScore::Text_EnemyName' has a wrong offset!");

// Class TimeWatch.WidgetContainerMatchSettings
// 0x0068 (0x02B0 - 0x0248)
class UWidgetContainerMatchSettings final : public UNGDWidgetContainer
{
public:
	class USpinner*                               Spinner_Map;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpinner*                               Spinner_PlayersSetup;                              // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpinner*                               Spinner_MatchPoints;                               // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpinner*                               Spinner_ClonesCount;                               // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpinner*                               Spinner_HealthPackMode;                            // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpinner*                               Spinner_HealingMode;                               // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpinner*                               Spinner_WeaponMode;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpinner*                               Spinner_OvertimeMode;                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_StartMatch;                                 // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTWLevelEntry*>                  PlayableLevels;                                    // 0x0290(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloneCountSelectionChanged(const class FString& Value);
	void HealingModeChanged(const class FString& Value);
	void HealthPackModeChanged(const class FString& Value);
	void MapSelectionChanged(const class FString& Value);
	void MatchScoreSelectionChanged(const class FString& Value);
	void OvertimeModeChanged(const class FString& Value);
	void StartMatchButtonClicked();
	void WeaponModeChanged(const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMatchSettings">();
	}
	static class UWidgetContainerMatchSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMatchSettings>();
	}
};
static_assert(alignof(UWidgetContainerMatchSettings) == 0x000008, "Wrong alignment on UWidgetContainerMatchSettings");
static_assert(sizeof(UWidgetContainerMatchSettings) == 0x0002B0, "Wrong size on UWidgetContainerMatchSettings");
static_assert(offsetof(UWidgetContainerMatchSettings, Spinner_Map) == 0x000248, "Member 'UWidgetContainerMatchSettings::Spinner_Map' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, Spinner_PlayersSetup) == 0x000250, "Member 'UWidgetContainerMatchSettings::Spinner_PlayersSetup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, Spinner_MatchPoints) == 0x000258, "Member 'UWidgetContainerMatchSettings::Spinner_MatchPoints' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, Spinner_ClonesCount) == 0x000260, "Member 'UWidgetContainerMatchSettings::Spinner_ClonesCount' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, Spinner_HealthPackMode) == 0x000268, "Member 'UWidgetContainerMatchSettings::Spinner_HealthPackMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, Spinner_HealingMode) == 0x000270, "Member 'UWidgetContainerMatchSettings::Spinner_HealingMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, Spinner_WeaponMode) == 0x000278, "Member 'UWidgetContainerMatchSettings::Spinner_WeaponMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, Spinner_OvertimeMode) == 0x000280, "Member 'UWidgetContainerMatchSettings::Spinner_OvertimeMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, Button_StartMatch) == 0x000288, "Member 'UWidgetContainerMatchSettings::Button_StartMatch' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchSettings, PlayableLevels) == 0x000290, "Member 'UWidgetContainerMatchSettings::PlayableLevels' has a wrong offset!");

// Class TimeWatch.WidgetContainerMatchTally
// 0x0348 (0x0590 - 0x0248)
class UWidgetContainerMatchTally final : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_MainMenuButton;                             // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_BackToTally;                                // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_ReportPlayer;                               // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Background_VictoryColor;                           // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Background_DefeatColor;                            // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     Material_VictoryFontMaterial;                      // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     Material_DefeatFontMaterial;                       // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTournamentRankWidget*                TournamentRankWidget;                              // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWLeagueDataAsset*                     LeagueDataAsset;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWRewardsDataAsset*                    RewardsDataAsset;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   VictoryMessage;                                    // 0x02A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DefeatMessage;                                     // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ForfeitMessage;                                    // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDebugModeOn;                                      // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchResultDataResponse               DebugOldDataResponse;                              // 0x02F8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FMatchResultDataResponse               DebugNewDataResponse;                              // 0x0350(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ETWMatchType                                  DebugMatchType;                                    // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            XPIncrementCurve;                                  // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            BPIncrementCurve;                                  // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TPIncrementCurve;                                  // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWRewardWidget>            RewardWidgetTemplate;                              // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UWidgetContainerReportPlayer> ReportPlayerWidgetContainer;                     // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_RewardsProgressBox;                  // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_CurrentRewardsBox;                   // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_BPsDisplayBox;                       // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_NextRewardOverlay;                         // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_NextReward;                              // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_LeavingMatch;                        // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_WonRewardsBox;                       // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_MatchResultText;                         // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_TimeToLeaveText;                         // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_CanvasSwitcher;                     // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_RequestingResults;                   // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_RequestFailed;                       // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_GameSuspended;                       // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_LevelText;                               // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_DailyBoost;                          // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_DailyBoostReward;                        // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_DailyBoost_XPText;                       // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_DailyBoost_QuarksText;                   // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_GainedXPText;                            // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_GainedCoins;                             // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_BackgroundXPBar;                       // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_FrontXPBar;                            // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_BackgroundBPBar;                       // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_FrontBPBar;                            // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Canvas_Rematch;                                    // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_WantsRematch;                                // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ScreenBackground;                            // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_Rematch;                                    // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CurrentTierNumber;                       // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_NextTierNumber;                          // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CurrentTierPoints;                       // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_PointsToNextTier;                        // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_NewTierNumberText;                       // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_ItemsWon;                              // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnimateXPBar;                                     // 0x04E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnimateTPBar;                                     // 0x04E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowingTierUpPopUp;                               // 0x04EA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTierUpPopUpSeen;                                  // 0x04EB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRewardTrackActive;                              // 0x04EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAreRewardsAvailable;                              // 0x04ED(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAreNextTierRewardsAvailable;                      // 0x04EE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EF[0x1];                                      // 0x04EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RematchSpamTimerHandle;                            // 0x04F0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_BackgroundFade;                               // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_RankResume;                                   // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x8];                                      // 0x0508(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchStartXP;                                      // 0x0510(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MatchEndXP;                                        // 0x0514(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MatchStartCoins;                                   // 0x0518(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MatchEndCoins;                                     // 0x051C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentBPsForTier;                                 // 0x0520(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NewBPsForTier;                                     // 0x0524(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTWRewardWidget*>                CurrentTierRewardWidgets;                          // 0x0528(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UTWRewardWidget*>                NextTierRewardWidgets;                             // 0x0538(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x48];                                     // 0x0548(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnPlayerDemoted();
	void BP_OnPlayerPromoted();
	void BP_OnPlayerTournamentResultReceived();
	void BP_OnStandardMatchResultFinished(ETWMatchType FinishedMatchType);
	void EnableRematchButton(bool bIsButtonEnabled);
	void OnBackToTallyButtonClicked();
	void OnBattlePointsUpdateEnd();
	void OnBattlePointsUpdateStart();
	void OnDemotion();
	void OnLeaveTierUpPopup();
	void OnLevelUp();
	void OnMainMenuButtonClicked();
	void OnMedalFadeInAnimFinished();
	void OnMedalFadeInAnimStarted();
	void OnMedalFadeOutAnimFinished();
	void OnPresentMedalAnimFinished();
	void OnPromotion();
	void OnRematchButtonClicked();
	void OnReportPlayerButtonClicked();
	void OnShowTierUpPopup();
	void OnTournamentPointsUpdateEnd();
	void OnTournamentPointsUpdateStart();
	void OnXPUpdateEnd();
	void OnXPUpdateStart();
	void PlayRankResume();
	void SetAnimateXPBar(bool Value);
	void SetWantsRematchVisibility(bool IsVisible_0);
	void ShowButtons();
	void ShowMatchResult();
	void StartMatchResultChecker();
	void VoidRematchButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMatchTally">();
	}
	static class UWidgetContainerMatchTally* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMatchTally>();
	}
};
static_assert(alignof(UWidgetContainerMatchTally) == 0x000008, "Wrong alignment on UWidgetContainerMatchTally");
static_assert(sizeof(UWidgetContainerMatchTally) == 0x000590, "Wrong size on UWidgetContainerMatchTally");
static_assert(offsetof(UWidgetContainerMatchTally, Button_MainMenuButton) == 0x000248, "Member 'UWidgetContainerMatchTally::Button_MainMenuButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Button_BackToTally) == 0x000250, "Member 'UWidgetContainerMatchTally::Button_BackToTally' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Button_ReportPlayer) == 0x000258, "Member 'UWidgetContainerMatchTally::Button_ReportPlayer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Background_VictoryColor) == 0x000260, "Member 'UWidgetContainerMatchTally::Background_VictoryColor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Background_DefeatColor) == 0x000270, "Member 'UWidgetContainerMatchTally::Background_DefeatColor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Material_VictoryFontMaterial) == 0x000280, "Member 'UWidgetContainerMatchTally::Material_VictoryFontMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Material_DefeatFontMaterial) == 0x000288, "Member 'UWidgetContainerMatchTally::Material_DefeatFontMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TournamentRankWidget) == 0x000290, "Member 'UWidgetContainerMatchTally::TournamentRankWidget' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, LeagueDataAsset) == 0x000298, "Member 'UWidgetContainerMatchTally::LeagueDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, RewardsDataAsset) == 0x0002A0, "Member 'UWidgetContainerMatchTally::RewardsDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, VictoryMessage) == 0x0002A8, "Member 'UWidgetContainerMatchTally::VictoryMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, DefeatMessage) == 0x0002C0, "Member 'UWidgetContainerMatchTally::DefeatMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, ForfeitMessage) == 0x0002D8, "Member 'UWidgetContainerMatchTally::ForfeitMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, bDebugModeOn) == 0x0002F0, "Member 'UWidgetContainerMatchTally::bDebugModeOn' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, DebugOldDataResponse) == 0x0002F8, "Member 'UWidgetContainerMatchTally::DebugOldDataResponse' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, DebugNewDataResponse) == 0x000350, "Member 'UWidgetContainerMatchTally::DebugNewDataResponse' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, DebugMatchType) == 0x0003A8, "Member 'UWidgetContainerMatchTally::DebugMatchType' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, XPIncrementCurve) == 0x0003B0, "Member 'UWidgetContainerMatchTally::XPIncrementCurve' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, BPIncrementCurve) == 0x0003B8, "Member 'UWidgetContainerMatchTally::BPIncrementCurve' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TPIncrementCurve) == 0x0003C0, "Member 'UWidgetContainerMatchTally::TPIncrementCurve' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, RewardWidgetTemplate) == 0x0003C8, "Member 'UWidgetContainerMatchTally::RewardWidgetTemplate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, ReportPlayerWidgetContainer) == 0x0003D0, "Member 'UWidgetContainerMatchTally::ReportPlayerWidgetContainer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_RewardsProgressBox) == 0x0003D8, "Member 'UWidgetContainerMatchTally::HorizontalBox_RewardsProgressBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_CurrentRewardsBox) == 0x0003E0, "Member 'UWidgetContainerMatchTally::HorizontalBox_CurrentRewardsBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_BPsDisplayBox) == 0x0003E8, "Member 'UWidgetContainerMatchTally::HorizontalBox_BPsDisplayBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Overlay_NextRewardOverlay) == 0x0003F0, "Member 'UWidgetContainerMatchTally::Overlay_NextRewardOverlay' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_NextReward) == 0x0003F8, "Member 'UWidgetContainerMatchTally::TextBlock_NextReward' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_LeavingMatch) == 0x000400, "Member 'UWidgetContainerMatchTally::HorizontalBox_LeavingMatch' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_WonRewardsBox) == 0x000408, "Member 'UWidgetContainerMatchTally::HorizontalBox_WonRewardsBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_MatchResultText) == 0x000410, "Member 'UWidgetContainerMatchTally::TextBlock_MatchResultText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_TimeToLeaveText) == 0x000418, "Member 'UWidgetContainerMatchTally::TextBlock_TimeToLeaveText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, WidgetSwitcher_CanvasSwitcher) == 0x000420, "Member 'UWidgetContainerMatchTally::WidgetSwitcher_CanvasSwitcher' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_RequestingResults) == 0x000428, "Member 'UWidgetContainerMatchTally::HorizontalBox_RequestingResults' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_RequestFailed) == 0x000430, "Member 'UWidgetContainerMatchTally::HorizontalBox_RequestFailed' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_GameSuspended) == 0x000438, "Member 'UWidgetContainerMatchTally::HorizontalBox_GameSuspended' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_LevelText) == 0x000440, "Member 'UWidgetContainerMatchTally::TextBlock_LevelText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, HorizontalBox_DailyBoost) == 0x000448, "Member 'UWidgetContainerMatchTally::HorizontalBox_DailyBoost' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_DailyBoostReward) == 0x000450, "Member 'UWidgetContainerMatchTally::TextBlock_DailyBoostReward' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_DailyBoost_XPText) == 0x000458, "Member 'UWidgetContainerMatchTally::TextBlock_DailyBoost_XPText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_DailyBoost_QuarksText) == 0x000460, "Member 'UWidgetContainerMatchTally::TextBlock_DailyBoost_QuarksText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_GainedXPText) == 0x000468, "Member 'UWidgetContainerMatchTally::TextBlock_GainedXPText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_GainedCoins) == 0x000470, "Member 'UWidgetContainerMatchTally::TextBlock_GainedCoins' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, ProgressBar_BackgroundXPBar) == 0x000478, "Member 'UWidgetContainerMatchTally::ProgressBar_BackgroundXPBar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, ProgressBar_FrontXPBar) == 0x000480, "Member 'UWidgetContainerMatchTally::ProgressBar_FrontXPBar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, ProgressBar_BackgroundBPBar) == 0x000488, "Member 'UWidgetContainerMatchTally::ProgressBar_BackgroundBPBar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, ProgressBar_FrontBPBar) == 0x000490, "Member 'UWidgetContainerMatchTally::ProgressBar_FrontBPBar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Canvas_Rematch) == 0x000498, "Member 'UWidgetContainerMatchTally::Canvas_Rematch' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Image_WantsRematch) == 0x0004A0, "Member 'UWidgetContainerMatchTally::Image_WantsRematch' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Image_ScreenBackground) == 0x0004A8, "Member 'UWidgetContainerMatchTally::Image_ScreenBackground' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Button_Rematch) == 0x0004B0, "Member 'UWidgetContainerMatchTally::Button_Rematch' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_CurrentTierNumber) == 0x0004B8, "Member 'UWidgetContainerMatchTally::TextBlock_CurrentTierNumber' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_NextTierNumber) == 0x0004C0, "Member 'UWidgetContainerMatchTally::TextBlock_NextTierNumber' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_CurrentTierPoints) == 0x0004C8, "Member 'UWidgetContainerMatchTally::TextBlock_CurrentTierPoints' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_PointsToNextTier) == 0x0004D0, "Member 'UWidgetContainerMatchTally::TextBlock_PointsToNextTier' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, TextBlock_NewTierNumberText) == 0x0004D8, "Member 'UWidgetContainerMatchTally::TextBlock_NewTierNumberText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, VerticalBox_ItemsWon) == 0x0004E0, "Member 'UWidgetContainerMatchTally::VerticalBox_ItemsWon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, bAnimateXPBar) == 0x0004E8, "Member 'UWidgetContainerMatchTally::bAnimateXPBar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, bAnimateTPBar) == 0x0004E9, "Member 'UWidgetContainerMatchTally::bAnimateTPBar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, bShowingTierUpPopUp) == 0x0004EA, "Member 'UWidgetContainerMatchTally::bShowingTierUpPopUp' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, bTierUpPopUpSeen) == 0x0004EB, "Member 'UWidgetContainerMatchTally::bTierUpPopUpSeen' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, bIsRewardTrackActive) == 0x0004EC, "Member 'UWidgetContainerMatchTally::bIsRewardTrackActive' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, bAreRewardsAvailable) == 0x0004ED, "Member 'UWidgetContainerMatchTally::bAreRewardsAvailable' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, bAreNextTierRewardsAvailable) == 0x0004EE, "Member 'UWidgetContainerMatchTally::bAreNextTierRewardsAvailable' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, RematchSpamTimerHandle) == 0x0004F0, "Member 'UWidgetContainerMatchTally::RematchSpamTimerHandle' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Anim_BackgroundFade) == 0x0004F8, "Member 'UWidgetContainerMatchTally::Anim_BackgroundFade' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, Anim_RankResume) == 0x000500, "Member 'UWidgetContainerMatchTally::Anim_RankResume' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, MatchStartXP) == 0x000510, "Member 'UWidgetContainerMatchTally::MatchStartXP' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, MatchEndXP) == 0x000514, "Member 'UWidgetContainerMatchTally::MatchEndXP' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, MatchStartCoins) == 0x000518, "Member 'UWidgetContainerMatchTally::MatchStartCoins' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, MatchEndCoins) == 0x00051C, "Member 'UWidgetContainerMatchTally::MatchEndCoins' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, CurrentBPsForTier) == 0x000520, "Member 'UWidgetContainerMatchTally::CurrentBPsForTier' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, NewBPsForTier) == 0x000524, "Member 'UWidgetContainerMatchTally::NewBPsForTier' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, CurrentTierRewardWidgets) == 0x000528, "Member 'UWidgetContainerMatchTally::CurrentTierRewardWidgets' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMatchTally, NextTierRewardWidgets) == 0x000538, "Member 'UWidgetContainerMatchTally::NextTierRewardWidgets' has a wrong offset!");

// Class TimeWatch.WidgetContainerMediaPlayer
// 0x0058 (0x02A0 - 0x0248)
class UWidgetContainerMediaPlayer : public UNGDWidgetContainer
{
public:
	bool                                          bIsVideoStoppable;                                 // 0x0248(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x17];                                     // 0x0249(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UMediaPlayer*                           MediaPlayer;                                       // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_TutorialVideoContainer;                      // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetContainerPointReview*            WC_PlayerSkip;                                     // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x28];                                     // 0x0278(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMediaStopped();
	void StopMedia();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerMediaPlayer">();
	}
	static class UWidgetContainerMediaPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerMediaPlayer>();
	}
};
static_assert(alignof(UWidgetContainerMediaPlayer) == 0x000008, "Wrong alignment on UWidgetContainerMediaPlayer");
static_assert(sizeof(UWidgetContainerMediaPlayer) == 0x0002A0, "Wrong size on UWidgetContainerMediaPlayer");
static_assert(offsetof(UWidgetContainerMediaPlayer, bIsVideoStoppable) == 0x000248, "Member 'UWidgetContainerMediaPlayer::bIsVideoStoppable' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMediaPlayer, MediaPlayer) == 0x000260, "Member 'UWidgetContainerMediaPlayer::MediaPlayer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMediaPlayer, Image_TutorialVideoContainer) == 0x000268, "Member 'UWidgetContainerMediaPlayer::Image_TutorialVideoContainer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerMediaPlayer, WC_PlayerSkip) == 0x000270, "Member 'UWidgetContainerMediaPlayer::WC_PlayerSkip' has a wrong offset!");

// Class TimeWatch.WidgetContainerNews
// 0x0058 (0x02A0 - 0x0248)
class UWidgetContainerNews : public UNGDWidgetContainer
{
public:
	TSubclassOf<class UNewsItemWidget>            NewsItemWidgetTemplate;                            // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondsBetweenNews;                                // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlotSizeX;                                         // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlotSizeY;                                         // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlotPadding;                                       // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_News;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Background;                                  // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Outline;                                     // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Title;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_NewsItems;                           // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNewsItemWidget*                        SelectedNews;                                      // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNewsButtonHovered();
	void OnNewsButtonUnhovered();
	void OnNewsItemHovered();
	void OnNewsItemSelected(int32 Index_0);
	void OpenNewsURL();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerNews">();
	}
	static class UWidgetContainerNews* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerNews>();
	}
};
static_assert(alignof(UWidgetContainerNews) == 0x000008, "Wrong alignment on UWidgetContainerNews");
static_assert(sizeof(UWidgetContainerNews) == 0x0002A0, "Wrong size on UWidgetContainerNews");
static_assert(offsetof(UWidgetContainerNews, NewsItemWidgetTemplate) == 0x000248, "Member 'UWidgetContainerNews::NewsItemWidgetTemplate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, SecondsBetweenNews) == 0x000250, "Member 'UWidgetContainerNews::SecondsBetweenNews' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, SlotSizeX) == 0x000254, "Member 'UWidgetContainerNews::SlotSizeX' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, SlotSizeY) == 0x000258, "Member 'UWidgetContainerNews::SlotSizeY' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, SlotPadding) == 0x00025C, "Member 'UWidgetContainerNews::SlotPadding' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, Button_News) == 0x000260, "Member 'UWidgetContainerNews::Button_News' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, Image_Background) == 0x000268, "Member 'UWidgetContainerNews::Image_Background' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, Image_Outline) == 0x000270, "Member 'UWidgetContainerNews::Image_Outline' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, Text_Title) == 0x000278, "Member 'UWidgetContainerNews::Text_Title' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, HorizontalBox_NewsItems) == 0x000280, "Member 'UWidgetContainerNews::HorizontalBox_NewsItems' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNews, SelectedNews) == 0x000288, "Member 'UWidgetContainerNews::SelectedNews' has a wrong offset!");

// Class TimeWatch.WidgetContainerNotification
// 0x00D8 (0x0320 - 0x0248)
class UWidgetContainerNotification final : public UNGDWidgetContainer
{
public:
	TSubclassOf<class UTWChallengeDetailWidget>   ChallengeDetailClass;                              // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Color_ChallengeCompleted;                          // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetailSizeBoxHeigth;                               // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetailSizeBoxWidth;                                // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_ChallengesListBox;                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWChallengeDetailWidget*>       ChallengeDetailsList;                              // 0x0270(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UTWChallengeDetailWidget*> CounterChallengeRules;                        // 0x0280(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UTWChallengeDetailWidget*> PercentageChallengeRules;                     // 0x02D0(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnChallengeDataLoaded(class UTWChallengeEventData* ChallengeEventData);
	void OnChallengeProgress(class UTWChallengeEvent* ChallengeEvent, const struct FTWChallengeRule& Rule);
	void OnNotificationFromChallenge(class UTWChallengeEvent* Challenge);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerNotification">();
	}
	static class UWidgetContainerNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerNotification>();
	}
};
static_assert(alignof(UWidgetContainerNotification) == 0x000008, "Wrong alignment on UWidgetContainerNotification");
static_assert(sizeof(UWidgetContainerNotification) == 0x000320, "Wrong size on UWidgetContainerNotification");
static_assert(offsetof(UWidgetContainerNotification, ChallengeDetailClass) == 0x000248, "Member 'UWidgetContainerNotification::ChallengeDetailClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNotification, Color_ChallengeCompleted) == 0x000250, "Member 'UWidgetContainerNotification::Color_ChallengeCompleted' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNotification, DetailSizeBoxHeigth) == 0x000260, "Member 'UWidgetContainerNotification::DetailSizeBoxHeigth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNotification, DetailSizeBoxWidth) == 0x000264, "Member 'UWidgetContainerNotification::DetailSizeBoxWidth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNotification, VerticalBox_ChallengesListBox) == 0x000268, "Member 'UWidgetContainerNotification::VerticalBox_ChallengesListBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNotification, ChallengeDetailsList) == 0x000270, "Member 'UWidgetContainerNotification::ChallengeDetailsList' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNotification, CounterChallengeRules) == 0x000280, "Member 'UWidgetContainerNotification::CounterChallengeRules' has a wrong offset!");
static_assert(offsetof(UWidgetContainerNotification, PercentageChallengeRules) == 0x0002D0, "Member 'UWidgetContainerNotification::PercentageChallengeRules' has a wrong offset!");

// Class TimeWatch.WidgetContainerOptionsMenu
// 0x0010 (0x0258 - 0x0248)
class UWidgetContainerOptionsMenu : public UNGDWidgetContainer
{
public:
	class UImage*                                 Background;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                BackBtn;                                           // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Focus_BP();
	void GoToMainMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerOptionsMenu">();
	}
	static class UWidgetContainerOptionsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerOptionsMenu>();
	}
};
static_assert(alignof(UWidgetContainerOptionsMenu) == 0x000008, "Wrong alignment on UWidgetContainerOptionsMenu");
static_assert(sizeof(UWidgetContainerOptionsMenu) == 0x000258, "Wrong size on UWidgetContainerOptionsMenu");
static_assert(offsetof(UWidgetContainerOptionsMenu, Background) == 0x000248, "Member 'UWidgetContainerOptionsMenu::Background' has a wrong offset!");
static_assert(offsetof(UWidgetContainerOptionsMenu, BackBtn) == 0x000250, "Member 'UWidgetContainerOptionsMenu::BackBtn' has a wrong offset!");

// Class TimeWatch.WidgetContainerPlayerInfoDisplay
// 0x0028 (0x0270 - 0x0248)
class UWidgetContainerPlayerInfoDisplay : public UNGDWidgetContainer
{
public:
	class USelfHealthBarStatus*                   SelfHealthBarStatus;                               // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Canvas_Health;                                     // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerPlayerInfoDisplay">();
	}
	static class UWidgetContainerPlayerInfoDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerPlayerInfoDisplay>();
	}
};
static_assert(alignof(UWidgetContainerPlayerInfoDisplay) == 0x000008, "Wrong alignment on UWidgetContainerPlayerInfoDisplay");
static_assert(sizeof(UWidgetContainerPlayerInfoDisplay) == 0x000270, "Wrong size on UWidgetContainerPlayerInfoDisplay");
static_assert(offsetof(UWidgetContainerPlayerInfoDisplay, SelfHealthBarStatus) == 0x000248, "Member 'UWidgetContainerPlayerInfoDisplay::SelfHealthBarStatus' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerInfoDisplay, Canvas_Health) == 0x000250, "Member 'UWidgetContainerPlayerInfoDisplay::Canvas_Health' has a wrong offset!");

// Class TimeWatch.WidgetContainerPlayerMatchIntro
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerPlayerMatchIntro : public UNGDWidgetContainer
{
public:
	class UTWPlayerCardWidget*                    PlayerCard;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ShowPlayerCard(class AFluxPlayerState* NewPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerPlayerMatchIntro">();
	}
	static class UWidgetContainerPlayerMatchIntro* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerPlayerMatchIntro>();
	}
};
static_assert(alignof(UWidgetContainerPlayerMatchIntro) == 0x000008, "Wrong alignment on UWidgetContainerPlayerMatchIntro");
static_assert(sizeof(UWidgetContainerPlayerMatchIntro) == 0x000250, "Wrong size on UWidgetContainerPlayerMatchIntro");
static_assert(offsetof(UWidgetContainerPlayerMatchIntro, PlayerCard) == 0x000248, "Member 'UWidgetContainerPlayerMatchIntro::PlayerCard' has a wrong offset!");

// Class TimeWatch.WidgetContainerPlayerProfile
// 0x0270 (0x04B8 - 0x0248)
class UWidgetContainerPlayerProfile : public UNGDWidgetContainer
{
public:
	class UHorizontalBox*                         HorizontalBox_SetFeatured;                         // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_Preview;                                // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetContainerPlayerTitleSelect*      PlayerTitleSelect;                                 // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_PlayerProfile;                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTabWidget*                           Tab_LeagueRanking;                                 // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTabWidget*                           Tab_1V1Leaderboard;                                // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTabWidget*                           Tab_2V2Leaderboard;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTabWidget*                           Tab_MatchHistory;                                  // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTabWidget*                           Tab_PlayerTitles;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Player;                                      // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PlayerStyle;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_DominanceTable;                             // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_EloTable;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_PlayerName;                              // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_MMR;                                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_TimePlayed;                              // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_WinRate;                                 // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_GamesWon;                                // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_KillRate;                                // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_PlayerStyle;                             // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_PlayerLevel;                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_PlayerStyleDescription;                  // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_RightClickAction;                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_XPRadialProgressBar;                         // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_EloLeaderboard;                          // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_DominanceLeaderboard;                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetContainerLeaderboardSlot*        LeaderboardSlot_OwnEloSlot;                        // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetContainerLeaderboardSlot*        LeaderboardSlot_OwnDominanceSlot;                  // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_Leaderboard;                           // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_GlobalLeaderboards;                 // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCircularThrobber*                      CircularThrobber_LoadingLeaderboars;               // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_DominanceArrow;                              // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_EloArrow;                                    // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_TournamentBox;                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_TournamentBoardScroll;                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_TournamentLeaderboard;                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCircularThrobber*                      CircularThrobber_LoadingSymbol;                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTournamentRankWidget*                TournamentRankWidget;                              // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox_TournamentTitleRowSizeBox;                 // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_JoinMessage;                           // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_UnlockPremium;                         // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_UnlockPremium;                              // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTabWidget*                           SelectedTab;                                       // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWidgetContainerLeaderboardSlot> LeaderboardSlotWidgetClass;                   // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeaderboardSlotSizeY;                              // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxAllowedUsernameLength;                          // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWLeagueDataAsset*                     LeagueDataAsset;                                   // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWLeaderboardRowWidget>    TWLeaderboardRowWidgetClass;                       // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FRowFieldProperties>       TournamentLeaderboardFilters;                      // 0x03E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         ScrollSpeedMultiplier;                             // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeaderboardRowHeight;                              // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, int32>                    LastTournamentLeaderboardRanks;                    // 0x0438(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWLeaderboardRowWidget*>        AroundUserLeaderboardRows;                         // 0x0488(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWLeaderboardRowWidget*>        GlobalLeaderboardRows;                             // 0x0498(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LeaderboardUpdatedCheckerHandle;                   // 0x04B0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GoToMainMenu();
	void InitializeLeagueRankings();
	void InitializePlayerProfileWidget(const class FString& InUserName, int32 InPlayerXP);
	void On1V1LeaderboardButtonClicked();
	void On2V2LeaderboardButtonClicked();
	void OnBackButtonClicked();
	void OnDominanceTableButtonClicked();
	void OnEloTableButtonClicked();
	void OnLeaderboardPeriodChanged(const class FString& SelectedOption);
	void OnLeaderboardsRequestComplete(bool bWasSuccessful, const class FString& ErrorString, TArray<struct FNGDBackendGlobalLeaderboardEntry>* LeaderboardEntries, const struct FNGDBackendGlobalLeaderboardEntry& OwnEntry);
	void OnLeagueRankingButtonClicked();
	void OnMatchHistoryButtonClicked();
	void OnPlayerTitlesButtonClicked();
	void OnProfileOverviewButtonClicked();
	void OnScrolled(float Value);
	void OnUnlockPremiumButtonClicked();
	void SetGamesWon(int32 GamesWonInt);
	void SetHighestMMR(int32 HighestMMRInt);
	void SetKillRate(int32 KillRateInt);
	void SetPlayerStyle();
	void SetPlayerTitleCalloutVisibility(ESlateVisibility NewVisibility);
	void SetTabToMatchHistory();
	void SetTimePlayed();
	void SetupLeaderboardLayout();
	void SetUserAvatar();
	void SetUserLevel(int32 InCurrentXP);
	void SetUsername(const class FString& Name_0);
	void SetWinRatio(int32 WinRateInt);
	void SetXPBarProgress(int32 InCurrentXP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerPlayerProfile">();
	}
	static class UWidgetContainerPlayerProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerPlayerProfile>();
	}
};
static_assert(alignof(UWidgetContainerPlayerProfile) == 0x000008, "Wrong alignment on UWidgetContainerPlayerProfile");
static_assert(sizeof(UWidgetContainerPlayerProfile) == 0x0004B8, "Wrong size on UWidgetContainerPlayerProfile");
static_assert(offsetof(UWidgetContainerPlayerProfile, HorizontalBox_SetFeatured) == 0x000248, "Member 'UWidgetContainerPlayerProfile::HorizontalBox_SetFeatured' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, PlayerCard_Preview) == 0x000250, "Member 'UWidgetContainerPlayerProfile::PlayerCard_Preview' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, PlayerTitleSelect) == 0x000258, "Member 'UWidgetContainerPlayerProfile::PlayerTitleSelect' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, WidgetSwitcher_PlayerProfile) == 0x000260, "Member 'UWidgetContainerPlayerProfile::WidgetSwitcher_PlayerProfile' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Tab_LeagueRanking) == 0x000268, "Member 'UWidgetContainerPlayerProfile::Tab_LeagueRanking' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Tab_1V1Leaderboard) == 0x000270, "Member 'UWidgetContainerPlayerProfile::Tab_1V1Leaderboard' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Tab_2V2Leaderboard) == 0x000278, "Member 'UWidgetContainerPlayerProfile::Tab_2V2Leaderboard' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Tab_MatchHistory) == 0x000280, "Member 'UWidgetContainerPlayerProfile::Tab_MatchHistory' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Tab_PlayerTitles) == 0x000288, "Member 'UWidgetContainerPlayerProfile::Tab_PlayerTitles' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Image_Player) == 0x000290, "Member 'UWidgetContainerPlayerProfile::Image_Player' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Image_PlayerStyle) == 0x000298, "Member 'UWidgetContainerPlayerProfile::Image_PlayerStyle' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Button_DominanceTable) == 0x0002A0, "Member 'UWidgetContainerPlayerProfile::Button_DominanceTable' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Button_EloTable) == 0x0002A8, "Member 'UWidgetContainerPlayerProfile::Button_EloTable' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Button_BackButton) == 0x0002B0, "Member 'UWidgetContainerPlayerProfile::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_PlayerName) == 0x0002B8, "Member 'UWidgetContainerPlayerProfile::TextBlock_PlayerName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_MMR) == 0x0002C0, "Member 'UWidgetContainerPlayerProfile::TextBlock_MMR' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_TimePlayed) == 0x0002C8, "Member 'UWidgetContainerPlayerProfile::TextBlock_TimePlayed' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_WinRate) == 0x0002D0, "Member 'UWidgetContainerPlayerProfile::TextBlock_WinRate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_GamesWon) == 0x0002D8, "Member 'UWidgetContainerPlayerProfile::TextBlock_GamesWon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_KillRate) == 0x0002E0, "Member 'UWidgetContainerPlayerProfile::TextBlock_KillRate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_PlayerStyle) == 0x0002E8, "Member 'UWidgetContainerPlayerProfile::TextBlock_PlayerStyle' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_PlayerLevel) == 0x0002F0, "Member 'UWidgetContainerPlayerProfile::TextBlock_PlayerLevel' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_PlayerStyleDescription) == 0x0002F8, "Member 'UWidgetContainerPlayerProfile::TextBlock_PlayerStyleDescription' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TextBlock_RightClickAction) == 0x000300, "Member 'UWidgetContainerPlayerProfile::TextBlock_RightClickAction' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Image_XPRadialProgressBar) == 0x000308, "Member 'UWidgetContainerPlayerProfile::Image_XPRadialProgressBar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, ScrollBox_EloLeaderboard) == 0x000310, "Member 'UWidgetContainerPlayerProfile::ScrollBox_EloLeaderboard' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, ScrollBox_DominanceLeaderboard) == 0x000318, "Member 'UWidgetContainerPlayerProfile::ScrollBox_DominanceLeaderboard' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, LeaderboardSlot_OwnEloSlot) == 0x000320, "Member 'UWidgetContainerPlayerProfile::LeaderboardSlot_OwnEloSlot' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, LeaderboardSlot_OwnDominanceSlot) == 0x000328, "Member 'UWidgetContainerPlayerProfile::LeaderboardSlot_OwnDominanceSlot' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, CanvasPanel_Leaderboard) == 0x000330, "Member 'UWidgetContainerPlayerProfile::CanvasPanel_Leaderboard' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, WidgetSwitcher_GlobalLeaderboards) == 0x000338, "Member 'UWidgetContainerPlayerProfile::WidgetSwitcher_GlobalLeaderboards' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, CircularThrobber_LoadingLeaderboars) == 0x000340, "Member 'UWidgetContainerPlayerProfile::CircularThrobber_LoadingLeaderboars' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Image_DominanceArrow) == 0x000348, "Member 'UWidgetContainerPlayerProfile::Image_DominanceArrow' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Image_EloArrow) == 0x000350, "Member 'UWidgetContainerPlayerProfile::Image_EloArrow' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, VerticalBox_TournamentBox) == 0x000358, "Member 'UWidgetContainerPlayerProfile::VerticalBox_TournamentBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, ScrollBox_TournamentBoardScroll) == 0x000360, "Member 'UWidgetContainerPlayerProfile::ScrollBox_TournamentBoardScroll' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, VerticalBox_TournamentLeaderboard) == 0x000368, "Member 'UWidgetContainerPlayerProfile::VerticalBox_TournamentLeaderboard' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, CircularThrobber_LoadingSymbol) == 0x000370, "Member 'UWidgetContainerPlayerProfile::CircularThrobber_LoadingSymbol' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TournamentRankWidget) == 0x000378, "Member 'UWidgetContainerPlayerProfile::TournamentRankWidget' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, SizeBox_TournamentTitleRowSizeBox) == 0x000380, "Member 'UWidgetContainerPlayerProfile::SizeBox_TournamentTitleRowSizeBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, CanvasPanel_JoinMessage) == 0x000388, "Member 'UWidgetContainerPlayerProfile::CanvasPanel_JoinMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, CanvasPanel_UnlockPremium) == 0x000390, "Member 'UWidgetContainerPlayerProfile::CanvasPanel_UnlockPremium' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, Button_UnlockPremium) == 0x000398, "Member 'UWidgetContainerPlayerProfile::Button_UnlockPremium' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, SelectedTab) == 0x0003A0, "Member 'UWidgetContainerPlayerProfile::SelectedTab' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, LeaderboardSlotWidgetClass) == 0x0003B0, "Member 'UWidgetContainerPlayerProfile::LeaderboardSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, LeaderboardSlotSizeY) == 0x0003B8, "Member 'UWidgetContainerPlayerProfile::LeaderboardSlotSizeY' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, MaxAllowedUsernameLength) == 0x0003BC, "Member 'UWidgetContainerPlayerProfile::MaxAllowedUsernameLength' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, LeagueDataAsset) == 0x0003D0, "Member 'UWidgetContainerPlayerProfile::LeagueDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TWLeaderboardRowWidgetClass) == 0x0003D8, "Member 'UWidgetContainerPlayerProfile::TWLeaderboardRowWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, TournamentLeaderboardFilters) == 0x0003E0, "Member 'UWidgetContainerPlayerProfile::TournamentLeaderboardFilters' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, ScrollSpeedMultiplier) == 0x000430, "Member 'UWidgetContainerPlayerProfile::ScrollSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, LeaderboardRowHeight) == 0x000434, "Member 'UWidgetContainerPlayerProfile::LeaderboardRowHeight' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, LastTournamentLeaderboardRanks) == 0x000438, "Member 'UWidgetContainerPlayerProfile::LastTournamentLeaderboardRanks' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, AroundUserLeaderboardRows) == 0x000488, "Member 'UWidgetContainerPlayerProfile::AroundUserLeaderboardRows' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, GlobalLeaderboardRows) == 0x000498, "Member 'UWidgetContainerPlayerProfile::GlobalLeaderboardRows' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerProfile, LeaderboardUpdatedCheckerHandle) == 0x0004B0, "Member 'UWidgetContainerPlayerProfile::LeaderboardUpdatedCheckerHandle' has a wrong offset!");

// Class TimeWatch.WidgetContainerPlayerTitleSelect
// 0x00E0 (0x0328 - 0x0248)
class UWidgetContainerPlayerTitleSelect : public UNGDWidgetContainer
{
public:
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWRewardsDataAsset*                    RarityConfig;                                      // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_ContextualAction;                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ItemType;                                // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ItemRarity;                              // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ItemName;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_Preview;                                // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UTWStyleButtonWidget*> AvailableStylesButtons;                         // 0x0288(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTWPlayerTitleDataAsset*>        TestBackendAvailableTitles;                        // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_StylesScroll;                            // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWStyleButtonWidget>       StyleButtonClass;                                  // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StyleButtonWidth;                                  // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StyleButtonHeigth;                                 // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerTitleDataAsset*                CurrentPlayerTitleData;                            // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnContextualButtonClicked();
	void OnStyleClicked(const class UTWItemDataAsset* SelectedStyleData);
	void TryEquipCurrentItem();
	void TryEquipItem(const class UTWItemDataAsset* SelectedStyleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerPlayerTitleSelect">();
	}
	static class UWidgetContainerPlayerTitleSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerPlayerTitleSelect>();
	}
};
static_assert(alignof(UWidgetContainerPlayerTitleSelect) == 0x000008, "Wrong alignment on UWidgetContainerPlayerTitleSelect");
static_assert(sizeof(UWidgetContainerPlayerTitleSelect) == 0x000328, "Wrong size on UWidgetContainerPlayerTitleSelect");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, RarityConfig) == 0x000258, "Member 'UWidgetContainerPlayerTitleSelect::RarityConfig' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, Button_ContextualAction) == 0x000260, "Member 'UWidgetContainerPlayerTitleSelect::Button_ContextualAction' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, TextBlock_ItemType) == 0x000268, "Member 'UWidgetContainerPlayerTitleSelect::TextBlock_ItemType' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, TextBlock_ItemRarity) == 0x000270, "Member 'UWidgetContainerPlayerTitleSelect::TextBlock_ItemRarity' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, TextBlock_ItemName) == 0x000278, "Member 'UWidgetContainerPlayerTitleSelect::TextBlock_ItemName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, PlayerCard_Preview) == 0x000280, "Member 'UWidgetContainerPlayerTitleSelect::PlayerCard_Preview' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, AvailableStylesButtons) == 0x000288, "Member 'UWidgetContainerPlayerTitleSelect::AvailableStylesButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, TestBackendAvailableTitles) == 0x0002D8, "Member 'UWidgetContainerPlayerTitleSelect::TestBackendAvailableTitles' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, ScrollBox_StylesScroll) == 0x0002E8, "Member 'UWidgetContainerPlayerTitleSelect::ScrollBox_StylesScroll' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, StyleButtonClass) == 0x0002F0, "Member 'UWidgetContainerPlayerTitleSelect::StyleButtonClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, StyleButtonWidth) == 0x0002F8, "Member 'UWidgetContainerPlayerTitleSelect::StyleButtonWidth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, StyleButtonHeigth) == 0x0002FC, "Member 'UWidgetContainerPlayerTitleSelect::StyleButtonHeigth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlayerTitleSelect, CurrentPlayerTitleData) == 0x000300, "Member 'UWidgetContainerPlayerTitleSelect::CurrentPlayerTitleData' has a wrong offset!");

// Class TimeWatch.WidgetContainerPlaySelection
// 0x0158 (0x03A0 - 0x0248)
class UWidgetContainerPlaySelection : public UNGDWidgetContainer
{
public:
	class UTexture2D*                             LockedIcon;                                        // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             TimeIcon;                                          // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_DetailsPrompt;                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTabWidget*                           Tab_OneVOne;                                       // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTabWidget*                           Tab_TwoVTwo;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_Teams;                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_1V1Ranked;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_1V1Casual;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_Training;                                     // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_1v1Custom;                                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_2V2Ranked;                                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_2V2Casual;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_2V2Custom;                                    // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      MediumTrainingPopup;                               // 0x02C0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      AdvancedTrainingPopup;                             // 0x02F8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      CasualQueueInfoPopup;                              // 0x0330(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      RankedQueueInfoPopup;                              // 0x0368(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void GoToMainMenu(ETWMatchQueueType MatchmakingType);
	void HideDetailsPrompt();
	void InitializePlaySelectionWidget();
	void On1V1CasualClicked();
	void On1V1RankedClicked();
	void On2V2CasualClicked();
	void On2V2RankedClicked();
	void OnBackButtonClicked();
	void OnCasualRightClicked();
	void OnCustomMatchClicked();
	void OnOneVOneTabClicked();
	void OnPartyDataUpdated(const bool bPartyStructureChanged);
	void OnRankedRightClicked();
	void OnTrainingClicked();
	void OnTwoVTwoTabClicked();
	void ShowDetailsPrompt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerPlaySelection">();
	}
	static class UWidgetContainerPlaySelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerPlaySelection>();
	}
};
static_assert(alignof(UWidgetContainerPlaySelection) == 0x000008, "Wrong alignment on UWidgetContainerPlaySelection");
static_assert(sizeof(UWidgetContainerPlaySelection) == 0x0003A0, "Wrong size on UWidgetContainerPlaySelection");
static_assert(offsetof(UWidgetContainerPlaySelection, LockedIcon) == 0x000248, "Member 'UWidgetContainerPlaySelection::LockedIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, TimeIcon) == 0x000250, "Member 'UWidgetContainerPlaySelection::TimeIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Button_BackButton) == 0x000260, "Member 'UWidgetContainerPlaySelection::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, HorizontalBox_DetailsPrompt) == 0x000268, "Member 'UWidgetContainerPlaySelection::HorizontalBox_DetailsPrompt' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Tab_OneVOne) == 0x000270, "Member 'UWidgetContainerPlaySelection::Tab_OneVOne' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Tab_TwoVTwo) == 0x000278, "Member 'UWidgetContainerPlaySelection::Tab_TwoVTwo' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, WidgetSwitcher_Teams) == 0x000280, "Member 'UWidgetContainerPlaySelection::WidgetSwitcher_Teams' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Mode_1V1Ranked) == 0x000288, "Member 'UWidgetContainerPlaySelection::Mode_1V1Ranked' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Mode_1V1Casual) == 0x000290, "Member 'UWidgetContainerPlaySelection::Mode_1V1Casual' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Mode_Training) == 0x000298, "Member 'UWidgetContainerPlaySelection::Mode_Training' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Mode_1v1Custom) == 0x0002A0, "Member 'UWidgetContainerPlaySelection::Mode_1v1Custom' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Mode_2V2Ranked) == 0x0002A8, "Member 'UWidgetContainerPlaySelection::Mode_2V2Ranked' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Mode_2V2Casual) == 0x0002B0, "Member 'UWidgetContainerPlaySelection::Mode_2V2Casual' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, Mode_2V2Custom) == 0x0002B8, "Member 'UWidgetContainerPlaySelection::Mode_2V2Custom' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, MediumTrainingPopup) == 0x0002C0, "Member 'UWidgetContainerPlaySelection::MediumTrainingPopup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, AdvancedTrainingPopup) == 0x0002F8, "Member 'UWidgetContainerPlaySelection::AdvancedTrainingPopup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, CasualQueueInfoPopup) == 0x000330, "Member 'UWidgetContainerPlaySelection::CasualQueueInfoPopup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPlaySelection, RankedQueueInfoPopup) == 0x000368, "Member 'UWidgetContainerPlaySelection::RankedQueueInfoPopup' has a wrong offset!");

// Class TimeWatch.WidgetContainerPointReview
// 0x0020 (0x0268 - 0x0248)
class UWidgetContainerPointReview : public UNGDWidgetContainer
{
public:
	TSubclassOf<class UTWPlayerSkipConfirmation>  PlayerSkipConfirmationClass;                       // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWPlayerSkipConfirmation*>      PlayerSkipConfirmationWidgets;                     // 0x0250(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_PlayersConfirmation;                 // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDisabled();
	void OnEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerPointReview">();
	}
	static class UWidgetContainerPointReview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerPointReview>();
	}
};
static_assert(alignof(UWidgetContainerPointReview) == 0x000008, "Wrong alignment on UWidgetContainerPointReview");
static_assert(sizeof(UWidgetContainerPointReview) == 0x000268, "Wrong size on UWidgetContainerPointReview");
static_assert(offsetof(UWidgetContainerPointReview, PlayerSkipConfirmationClass) == 0x000248, "Member 'UWidgetContainerPointReview::PlayerSkipConfirmationClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPointReview, PlayerSkipConfirmationWidgets) == 0x000250, "Member 'UWidgetContainerPointReview::PlayerSkipConfirmationWidgets' has a wrong offset!");
static_assert(offsetof(UWidgetContainerPointReview, HorizontalBox_PlayersConfirmation) == 0x000260, "Member 'UWidgetContainerPointReview::HorizontalBox_PlayersConfirmation' has a wrong offset!");

// Class TimeWatch.WidgetContainerQuickChat
// 0x0090 (0x02D8 - 0x0248)
class UWidgetContainerQuickChat final : public UNGDWidgetContainer
{
public:
	TSubclassOf<class UTWQuickChatSlot>           QuickChatSlotClass;                                // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           QuickChatActionNames;                              // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_QuickChatOptions;                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_BackButton;                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CategoryName;                            // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActionMapping*                         ActionMapping_Back;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EQuickChatCategory, class FName>         BackActionNames;                                   // 0x0280(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetEntriesCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerQuickChat">();
	}
	static class UWidgetContainerQuickChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerQuickChat>();
	}
};
static_assert(alignof(UWidgetContainerQuickChat) == 0x000008, "Wrong alignment on UWidgetContainerQuickChat");
static_assert(sizeof(UWidgetContainerQuickChat) == 0x0002D8, "Wrong size on UWidgetContainerQuickChat");
static_assert(offsetof(UWidgetContainerQuickChat, QuickChatSlotClass) == 0x000248, "Member 'UWidgetContainerQuickChat::QuickChatSlotClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerQuickChat, QuickChatActionNames) == 0x000250, "Member 'UWidgetContainerQuickChat::QuickChatActionNames' has a wrong offset!");
static_assert(offsetof(UWidgetContainerQuickChat, VerticalBox_QuickChatOptions) == 0x000260, "Member 'UWidgetContainerQuickChat::VerticalBox_QuickChatOptions' has a wrong offset!");
static_assert(offsetof(UWidgetContainerQuickChat, HorizontalBox_BackButton) == 0x000268, "Member 'UWidgetContainerQuickChat::HorizontalBox_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerQuickChat, TextBlock_CategoryName) == 0x000270, "Member 'UWidgetContainerQuickChat::TextBlock_CategoryName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerQuickChat, ActionMapping_Back) == 0x000278, "Member 'UWidgetContainerQuickChat::ActionMapping_Back' has a wrong offset!");
static_assert(offsetof(UWidgetContainerQuickChat, BackActionNames) == 0x000280, "Member 'UWidgetContainerQuickChat::BackActionNames' has a wrong offset!");

// Class TimeWatch.WidgetContainerRadialFeedback
// 0x0010 (0x0258 - 0x0248)
class UWidgetContainerRadialFeedback : public UNGDWidgetContainer
{
public:
	TArray<struct FRadialFeedback>                RadialFeedbacks;                                   // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddRadialFeedback(const struct FVector& HitDirection, EFeedbackType FeedbackType, const struct FVector& Location);
	void UpdateFeedback(class UWidget* HitWidget, float Progress, float Alpha, float Scale, float Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerRadialFeedback">();
	}
	static class UWidgetContainerRadialFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerRadialFeedback>();
	}
};
static_assert(alignof(UWidgetContainerRadialFeedback) == 0x000008, "Wrong alignment on UWidgetContainerRadialFeedback");
static_assert(sizeof(UWidgetContainerRadialFeedback) == 0x000258, "Wrong size on UWidgetContainerRadialFeedback");
static_assert(offsetof(UWidgetContainerRadialFeedback, RadialFeedbacks) == 0x000248, "Member 'UWidgetContainerRadialFeedback::RadialFeedbacks' has a wrong offset!");

// Class TimeWatch.WidgetContainerRedeemCode
// 0x0020 (0x0268 - 0x0248)
class UWidgetContainerRedeemCode : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_RedeemCodeButton;                           // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          InputField_RedeemCode;                             // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRedeemingCode;                                  // 0x0260(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackButtonClicked();
	void OnPlayerDataUpdate(bool bWasSuccessful, const class FString& ErrorString);
	void OnRedeemCodeButtonClicked();
	void OnRedeemCodeResponseReceived(bool bWasSuccessful, const class FString& RedeemCodeResult, const struct FNGDBackendReceivedRewards& RewardData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerRedeemCode">();
	}
	static class UWidgetContainerRedeemCode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerRedeemCode>();
	}
};
static_assert(alignof(UWidgetContainerRedeemCode) == 0x000008, "Wrong alignment on UWidgetContainerRedeemCode");
static_assert(sizeof(UWidgetContainerRedeemCode) == 0x000268, "Wrong size on UWidgetContainerRedeemCode");
static_assert(offsetof(UWidgetContainerRedeemCode, Button_BackButton) == 0x000248, "Member 'UWidgetContainerRedeemCode::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRedeemCode, Button_RedeemCodeButton) == 0x000250, "Member 'UWidgetContainerRedeemCode::Button_RedeemCodeButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRedeemCode, InputField_RedeemCode) == 0x000258, "Member 'UWidgetContainerRedeemCode::InputField_RedeemCode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRedeemCode, bIsRedeemingCode) == 0x000260, "Member 'UWidgetContainerRedeemCode::bIsRedeemingCode' has a wrong offset!");

// Class TimeWatch.WidgetContainerReplayControl
// 0x0018 (0x0260 - 0x0248)
class UWidgetContainerReplayControl : public UNGDWidgetContainer
{
public:
	class UVerticalBox*                           VerticalBox_ReplayControls;                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HidePanel;                                         // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerReplayControl">();
	}
	static class UWidgetContainerReplayControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerReplayControl>();
	}
};
static_assert(alignof(UWidgetContainerReplayControl) == 0x000008, "Wrong alignment on UWidgetContainerReplayControl");
static_assert(sizeof(UWidgetContainerReplayControl) == 0x000260, "Wrong size on UWidgetContainerReplayControl");
static_assert(offsetof(UWidgetContainerReplayControl, VerticalBox_ReplayControls) == 0x000248, "Member 'UWidgetContainerReplayControl::VerticalBox_ReplayControls' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReplayControl, HidePanel) == 0x000250, "Member 'UWidgetContainerReplayControl::HidePanel' has a wrong offset!");

// Class TimeWatch.WidgetContainerReplays
// 0x0080 (0x02C8 - 0x0248)
class UWidgetContainerReplays : public UNGDWidgetContainer
{
public:
	class UVerticalBox*                           VerticalBox_List;                                  // 0x0248(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetContainerMatchHistorySlot> ReplayItemClass;                             // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_NoReplaysFound;                            // 0x0258(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidgetContainerMatchHistorySlot*> ReplaySlots;                                     // 0x0260(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReplayItemHeigth;                                  // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplayItemWidth;                                   // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxReplayLifespan_Days;                            // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4C];                                     // 0x027C(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerReplays">();
	}
	static class UWidgetContainerReplays* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerReplays>();
	}
};
static_assert(alignof(UWidgetContainerReplays) == 0x000008, "Wrong alignment on UWidgetContainerReplays");
static_assert(sizeof(UWidgetContainerReplays) == 0x0002C8, "Wrong size on UWidgetContainerReplays");
static_assert(offsetof(UWidgetContainerReplays, VerticalBox_List) == 0x000248, "Member 'UWidgetContainerReplays::VerticalBox_List' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReplays, ReplayItemClass) == 0x000250, "Member 'UWidgetContainerReplays::ReplayItemClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReplays, Overlay_NoReplaysFound) == 0x000258, "Member 'UWidgetContainerReplays::Overlay_NoReplaysFound' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReplays, ReplaySlots) == 0x000260, "Member 'UWidgetContainerReplays::ReplaySlots' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReplays, ReplayItemHeigth) == 0x000270, "Member 'UWidgetContainerReplays::ReplayItemHeigth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReplays, ReplayItemWidth) == 0x000274, "Member 'UWidgetContainerReplays::ReplayItemWidth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReplays, MaxReplayLifespan_Days) == 0x000278, "Member 'UWidgetContainerReplays::MaxReplayLifespan_Days' has a wrong offset!");

// Class TimeWatch.WidgetContainerReplayState
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerReplayState : public UNGDWidgetContainer
{
public:
	class UTextBlock*                             Text_MatchEnded;                                   // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayMatchEndedAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerReplayState">();
	}
	static class UWidgetContainerReplayState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerReplayState>();
	}
};
static_assert(alignof(UWidgetContainerReplayState) == 0x000008, "Wrong alignment on UWidgetContainerReplayState");
static_assert(sizeof(UWidgetContainerReplayState) == 0x000250, "Wrong size on UWidgetContainerReplayState");
static_assert(offsetof(UWidgetContainerReplayState, Text_MatchEnded) == 0x000248, "Member 'UWidgetContainerReplayState::Text_MatchEnded' has a wrong offset!");

// Class TimeWatch.WidgetContainerReportPlayer
// 0x0020 (0x0268 - 0x0248)
class UWidgetContainerReportPlayer final : public UNGDWidgetContainer
{
public:
	class UDropdownScrollListWidget*              DropDown_Player;                                   // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDropdownScrollListWidget*              DropDown_Reason;                                   // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_Submit;                                     // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWStandardButtonWidget*                Button_Close;                                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCloseButtonClicked();
	void OnSubmitButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerReportPlayer">();
	}
	static class UWidgetContainerReportPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerReportPlayer>();
	}
};
static_assert(alignof(UWidgetContainerReportPlayer) == 0x000008, "Wrong alignment on UWidgetContainerReportPlayer");
static_assert(sizeof(UWidgetContainerReportPlayer) == 0x000268, "Wrong size on UWidgetContainerReportPlayer");
static_assert(offsetof(UWidgetContainerReportPlayer, DropDown_Player) == 0x000248, "Member 'UWidgetContainerReportPlayer::DropDown_Player' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReportPlayer, DropDown_Reason) == 0x000250, "Member 'UWidgetContainerReportPlayer::DropDown_Reason' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReportPlayer, Button_Submit) == 0x000258, "Member 'UWidgetContainerReportPlayer::Button_Submit' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReportPlayer, Button_Close) == 0x000260, "Member 'UWidgetContainerReportPlayer::Button_Close' has a wrong offset!");

// Class TimeWatch.WidgetContainerReviveFeedback
// 0x0010 (0x0258 - 0x0248)
class UWidgetContainerReviveFeedback : public UNGDWidgetContainer
{
public:
	class UTextBlock*                             TextBlock_RevivedMessage;                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveFeedbackMessageDuration;                     // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericEventReceived(class UTimeWatchEvent* Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerReviveFeedback">();
	}
	static class UWidgetContainerReviveFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerReviveFeedback>();
	}
};
static_assert(alignof(UWidgetContainerReviveFeedback) == 0x000008, "Wrong alignment on UWidgetContainerReviveFeedback");
static_assert(sizeof(UWidgetContainerReviveFeedback) == 0x000258, "Wrong size on UWidgetContainerReviveFeedback");
static_assert(offsetof(UWidgetContainerReviveFeedback, TextBlock_RevivedMessage) == 0x000248, "Member 'UWidgetContainerReviveFeedback::TextBlock_RevivedMessage' has a wrong offset!");
static_assert(offsetof(UWidgetContainerReviveFeedback, ReviveFeedbackMessageDuration) == 0x000250, "Member 'UWidgetContainerReviveFeedback::ReviveFeedbackMessageDuration' has a wrong offset!");

// Class TimeWatch.WidgetContainerRewardTrack
// 0x0248 (0x0490 - 0x0248)
class UWidgetContainerRewardTrack : public UNGDWidgetContainer
{
public:
	struct FKey                                   KeyForScrolling;                                   // 0x0248(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   KeyForRotatingItem;                                // 0x0260(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsQuantityForScroll;                            // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RewardItemWidth;                                   // 0x027C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotButtonSize;                                     // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBetweenDotsButtons;                        // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTWRewardWidget>            RewardItemClass;                                   // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNewsItemWidget>            DotIndexButtonClass;                               // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsTotalAmount;                                  // 0x0298(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWPlayerCardWidget*                    PlayerCard_Preview;                                // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_Rewards;                                 // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_Rewards;                               // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_DotButtons;                          // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_Toggles;                             // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_Levels;                              // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RewardRarity;                                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RewardType;                                   // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_MinLevelInScrollBox;                          // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RewardDisplayName;                            // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_CurrentItemLevel;                             // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_SeasonNum;                                    // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_MaxLevelInScrollBox;                          // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LevelSeparator;                               // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Requirement;                                  // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_ScrollLeft;                                 // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_ScrollRight;                                // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ItemMaterial;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PreviewItemMaterial;                         // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_RewardTrack;                        // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PreviewItemName;                              // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PreviewRarity;                                // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PreviewItemType;                              // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PreviewTierRequirement;                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                BackBtn;                                           // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_Equip;                                      // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWRewardsDataAsset*                    RewardsDataAsset;                                  // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CharacterStylePosition;                            // 0x0378(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CharacterPreviewPosition;                          // 0x0384(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CharacterStyleRotation;                            // 0x0390(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               WeaponStyleRotation;                               // 0x039C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               PlayerTitleBaseAnchors;                            // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               PlayerTitlePreviewScreenAnchors;                   // 0x03C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               PlayerTitleBaseOffsets;                            // 0x03D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               PlayerTitlePreviewScreenOffsets;                   // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWRewardItemPreviewActor*              ItemPreviewActor;                                  // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x60];                                     // 0x03F8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ItemLoadTimerHandle;                               // 0x0458(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNGDBackendReward                      CurrentItemRewardInfo;                             // 0x0460(0x0028)(Transient, NativeAccessSpecifierPrivate)
	class UTWRewardWidget*                        CurrentSelectedItem;                               // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GoToMainMenu();
	void OnEquipButtonPressed();
	void OnEscapePressed();
	void OnFirstLoadComplete();
	void OnRewardItemClicked(class UTWRewardWidget* ClickedRewardWidget);
	void OnRewardItemHovered(class UTWRewardWidget* ClickedRewardWidget);
	void OnRewardItemUnhovered(class UTWRewardWidget* ClickedRewardWidget);
	void OnRewardsScrolled(int32 ScrollingDirection);
	void OnScrollLeftButtonPressed();
	void OnScrollRightButtonPressed();
	void ScrollItemIntoView(int32 InIndex);
	void UpdateRemainingTime(int32 RemainingMinutes);

	class AMainMenuHUD* GetMainMenuHud() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerRewardTrack">();
	}
	static class UWidgetContainerRewardTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerRewardTrack>();
	}
};
static_assert(alignof(UWidgetContainerRewardTrack) == 0x000010, "Wrong alignment on UWidgetContainerRewardTrack");
static_assert(sizeof(UWidgetContainerRewardTrack) == 0x000490, "Wrong size on UWidgetContainerRewardTrack");
static_assert(offsetof(UWidgetContainerRewardTrack, KeyForScrolling) == 0x000248, "Member 'UWidgetContainerRewardTrack::KeyForScrolling' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, KeyForRotatingItem) == 0x000260, "Member 'UWidgetContainerRewardTrack::KeyForRotatingItem' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, ItemsQuantityForScroll) == 0x000278, "Member 'UWidgetContainerRewardTrack::ItemsQuantityForScroll' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, RewardItemWidth) == 0x00027C, "Member 'UWidgetContainerRewardTrack::RewardItemWidth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, DotButtonSize) == 0x000280, "Member 'UWidgetContainerRewardTrack::DotButtonSize' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, DistanceBetweenDotsButtons) == 0x000284, "Member 'UWidgetContainerRewardTrack::DistanceBetweenDotsButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, RewardItemClass) == 0x000288, "Member 'UWidgetContainerRewardTrack::RewardItemClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, DotIndexButtonClass) == 0x000290, "Member 'UWidgetContainerRewardTrack::DotIndexButtonClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, ItemsTotalAmount) == 0x000298, "Member 'UWidgetContainerRewardTrack::ItemsTotalAmount' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, PlayerCard_Preview) == 0x0002A0, "Member 'UWidgetContainerRewardTrack::PlayerCard_Preview' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, ScrollBox_Rewards) == 0x0002A8, "Member 'UWidgetContainerRewardTrack::ScrollBox_Rewards' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, CanvasPanel_Rewards) == 0x0002B0, "Member 'UWidgetContainerRewardTrack::CanvasPanel_Rewards' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, HorizontalBox_DotButtons) == 0x0002B8, "Member 'UWidgetContainerRewardTrack::HorizontalBox_DotButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, HorizontalBox_Toggles) == 0x0002C0, "Member 'UWidgetContainerRewardTrack::HorizontalBox_Toggles' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, HorizontalBox_Levels) == 0x0002C8, "Member 'UWidgetContainerRewardTrack::HorizontalBox_Levels' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_RewardRarity) == 0x0002D0, "Member 'UWidgetContainerRewardTrack::Text_RewardRarity' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_RewardType) == 0x0002D8, "Member 'UWidgetContainerRewardTrack::Text_RewardType' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_MinLevelInScrollBox) == 0x0002E0, "Member 'UWidgetContainerRewardTrack::Text_MinLevelInScrollBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_RewardDisplayName) == 0x0002E8, "Member 'UWidgetContainerRewardTrack::Text_RewardDisplayName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_CurrentItemLevel) == 0x0002F0, "Member 'UWidgetContainerRewardTrack::Text_CurrentItemLevel' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_SeasonNum) == 0x0002F8, "Member 'UWidgetContainerRewardTrack::Text_SeasonNum' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_MaxLevelInScrollBox) == 0x000300, "Member 'UWidgetContainerRewardTrack::Text_MaxLevelInScrollBox' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_LevelSeparator) == 0x000308, "Member 'UWidgetContainerRewardTrack::Text_LevelSeparator' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_Requirement) == 0x000310, "Member 'UWidgetContainerRewardTrack::Text_Requirement' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Button_ScrollLeft) == 0x000318, "Member 'UWidgetContainerRewardTrack::Button_ScrollLeft' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Button_ScrollRight) == 0x000320, "Member 'UWidgetContainerRewardTrack::Button_ScrollRight' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Image_ItemMaterial) == 0x000328, "Member 'UWidgetContainerRewardTrack::Image_ItemMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Image_PreviewItemMaterial) == 0x000330, "Member 'UWidgetContainerRewardTrack::Image_PreviewItemMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, WidgetSwitcher_RewardTrack) == 0x000338, "Member 'UWidgetContainerRewardTrack::WidgetSwitcher_RewardTrack' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_PreviewItemName) == 0x000340, "Member 'UWidgetContainerRewardTrack::Text_PreviewItemName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_PreviewRarity) == 0x000348, "Member 'UWidgetContainerRewardTrack::Text_PreviewRarity' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_PreviewItemType) == 0x000350, "Member 'UWidgetContainerRewardTrack::Text_PreviewItemType' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Text_PreviewTierRequirement) == 0x000358, "Member 'UWidgetContainerRewardTrack::Text_PreviewTierRequirement' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, BackBtn) == 0x000360, "Member 'UWidgetContainerRewardTrack::BackBtn' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, Button_Equip) == 0x000368, "Member 'UWidgetContainerRewardTrack::Button_Equip' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, RewardsDataAsset) == 0x000370, "Member 'UWidgetContainerRewardTrack::RewardsDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, CharacterStylePosition) == 0x000378, "Member 'UWidgetContainerRewardTrack::CharacterStylePosition' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, CharacterPreviewPosition) == 0x000384, "Member 'UWidgetContainerRewardTrack::CharacterPreviewPosition' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, CharacterStyleRotation) == 0x000390, "Member 'UWidgetContainerRewardTrack::CharacterStyleRotation' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, WeaponStyleRotation) == 0x00039C, "Member 'UWidgetContainerRewardTrack::WeaponStyleRotation' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, PlayerTitleBaseAnchors) == 0x0003B0, "Member 'UWidgetContainerRewardTrack::PlayerTitleBaseAnchors' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, PlayerTitlePreviewScreenAnchors) == 0x0003C0, "Member 'UWidgetContainerRewardTrack::PlayerTitlePreviewScreenAnchors' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, PlayerTitleBaseOffsets) == 0x0003D0, "Member 'UWidgetContainerRewardTrack::PlayerTitleBaseOffsets' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, PlayerTitlePreviewScreenOffsets) == 0x0003E0, "Member 'UWidgetContainerRewardTrack::PlayerTitlePreviewScreenOffsets' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, ItemPreviewActor) == 0x0003F0, "Member 'UWidgetContainerRewardTrack::ItemPreviewActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, ItemLoadTimerHandle) == 0x000458, "Member 'UWidgetContainerRewardTrack::ItemLoadTimerHandle' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, CurrentItemRewardInfo) == 0x000460, "Member 'UWidgetContainerRewardTrack::CurrentItemRewardInfo' has a wrong offset!");
static_assert(offsetof(UWidgetContainerRewardTrack, CurrentSelectedItem) == 0x000488, "Member 'UWidgetContainerRewardTrack::CurrentSelectedItem' has a wrong offset!");

// Class TimeWatch.WidgetContainerScorePopup
// 0x0018 (0x0260 - 0x0248)
class UWidgetContainerScorePopup : public UNGDWidgetContainer
{
public:
	class UTWPlayerCardWidget*                    PlayerCard_2v2LeftPlayer;                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_2v2RightPlayer;                         // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_1v1;                                    // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayBlueScoredAnimationForSpectator();
	void PlayEnemyScoredAnimation();
	void PlayRedScoredAnimationForSpectator();
	void PlayYouScoredAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerScorePopup">();
	}
	static class UWidgetContainerScorePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerScorePopup>();
	}
};
static_assert(alignof(UWidgetContainerScorePopup) == 0x000008, "Wrong alignment on UWidgetContainerScorePopup");
static_assert(sizeof(UWidgetContainerScorePopup) == 0x000260, "Wrong size on UWidgetContainerScorePopup");
static_assert(offsetof(UWidgetContainerScorePopup, PlayerCard_2v2LeftPlayer) == 0x000248, "Member 'UWidgetContainerScorePopup::PlayerCard_2v2LeftPlayer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerScorePopup, PlayerCard_2v2RightPlayer) == 0x000250, "Member 'UWidgetContainerScorePopup::PlayerCard_2v2RightPlayer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerScorePopup, PlayerCard_1v1) == 0x000258, "Member 'UWidgetContainerScorePopup::PlayerCard_1v1' has a wrong offset!");

// Class TimeWatch.WidgetContainerSpectatorDisplay
// 0x00B8 (0x0300 - 0x0248)
class UWidgetContainerSpectatorDisplay : public UNGDWidgetContainer
{
public:
	class UTextBlock*                             TextBlock_SpectatorMode;                           // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasPanel_ReplayPanel;                           // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_BannerBG;                                    // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBlock_BannerText;                              // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Banner_SpectatingPrefixText;                       // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Banner_BlueTeamText;                               // 0x0280(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Banner_RedTeamText;                                // 0x0298(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Banner_FreeLookText;                               // 0x02B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Banner_LoopReviewText;                             // 0x02C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class ATimeWatchCharacter*                    Owner;                                             // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerSpectatorDisplay">();
	}
	static class UWidgetContainerSpectatorDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerSpectatorDisplay>();
	}
};
static_assert(alignof(UWidgetContainerSpectatorDisplay) == 0x000008, "Wrong alignment on UWidgetContainerSpectatorDisplay");
static_assert(sizeof(UWidgetContainerSpectatorDisplay) == 0x000300, "Wrong size on UWidgetContainerSpectatorDisplay");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, TextBlock_SpectatorMode) == 0x000248, "Member 'UWidgetContainerSpectatorDisplay::TextBlock_SpectatorMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, CanvasPanel_ReplayPanel) == 0x000250, "Member 'UWidgetContainerSpectatorDisplay::CanvasPanel_ReplayPanel' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, Image_BannerBG) == 0x000258, "Member 'UWidgetContainerSpectatorDisplay::Image_BannerBG' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, TextBlock_BannerText) == 0x000260, "Member 'UWidgetContainerSpectatorDisplay::TextBlock_BannerText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, Banner_SpectatingPrefixText) == 0x000268, "Member 'UWidgetContainerSpectatorDisplay::Banner_SpectatingPrefixText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, Banner_BlueTeamText) == 0x000280, "Member 'UWidgetContainerSpectatorDisplay::Banner_BlueTeamText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, Banner_RedTeamText) == 0x000298, "Member 'UWidgetContainerSpectatorDisplay::Banner_RedTeamText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, Banner_FreeLookText) == 0x0002B0, "Member 'UWidgetContainerSpectatorDisplay::Banner_FreeLookText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, Banner_LoopReviewText) == 0x0002C8, "Member 'UWidgetContainerSpectatorDisplay::Banner_LoopReviewText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerSpectatorDisplay, Owner) == 0x0002E0, "Member 'UWidgetContainerSpectatorDisplay::Owner' has a wrong offset!");

// Class TimeWatch.WidgetContainerStore
// 0x01D8 (0x0420 - 0x0248)
class UWidgetContainerStore : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Featured_1;                                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Featured_2;                                        // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   DailyDeal_1;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   DailyDeal_2;                                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   DailyDeal_3;                                       // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   DailyDeal_4;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   QuarkBundle_0;                                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   QuarkBundle_1;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   QuarkBundle_2;                                     // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   QuarkBundle_3;                                     // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPremiumBannerWidget*                 PremiumBannerWidget;                               // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox_PremiumBanner;                             // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_FeaturedTime;                                 // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_DailyDealsTime;                               // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_StoreTab;                           // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ItemName;                                // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Rarity;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ItemType;                                // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Price;                                   // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_Unlock;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                QuarkStore;                                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_Background;                            // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWRewardsDataAsset*                    RewardsDataAsset;                                  // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_QuarkStore;                            // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNGDPopupHUDState>          PopupHUDStateClass;                                // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CharacterStylePosition;                            // 0x0318(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WeaponStylePosition;                               // 0x0324(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DescriptionFontTypeName;                           // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWRewardItemPreviewActor*              ItemPreviewActor;                                  // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, struct FNGDBackendDailyStoreSlot> Slots;                                     // 0x0340(0x0050)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FNGDBackendQuarkBundleData> Bundles;                                  // 0x0390(0x0050)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x18];                                     // 0x03E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBuyingItem;                                     // 0x03F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              FeaturedTimespan;                                  // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              DailyDealTimespan;                                 // 0x0408(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBuyItemSuccess();
	void GoToMainMenu();
	void MicroTxnFinished(bool bWasSucessful);
	void OnBuyItemClicked();
	void OnBuyItemComplete(bool bWasSuccessful, const class FString& ErrorString, const class FString& SKU, int32 newCoinsAmmount);
	void OnLoadDailyStoreRequestComplete(bool bWasSuccessful, const class FString& ErrorString, const struct FNGDBackendDailyStoreData& DailyStoreData);
	void OnLoadQuarkStoreRequestComplete(bool bWasSuccessful, const class FString& ErrorString, const struct FNGDBackendQuarkStoreData& QuarksStoreData);
	void OnQuarkBundleClicked(class FString* SlotID);
	void OnShowQuarksBundles();
	void OnSlotClicked(class FString* SlotID);
	void OnSlotHovered(class FString* SlotID);
	void OnSteamMicroTxnReceived(bool bWasSuccessful, const class FString& ErrorString, bool Authorized, int32 OrderId, const class FString& TransactionId, const struct FNGDBackendReceivedRewards& RewardData);
	void OnSteamMicroTxnStart(bool bWasSuccessful, const class FString& ErrorString, int32 OrderId, const class FString& TransactionId);
	void OnUnlock();
	void OnUnlockPremiumButtonClicked();
	void OpenPremiumPopup(const class FText& PopupTitle);

	class AMainMenuHUD* GetMainMenuHud() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerStore">();
	}
	static class UWidgetContainerStore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerStore>();
	}
};
static_assert(alignof(UWidgetContainerStore) == 0x000008, "Wrong alignment on UWidgetContainerStore");
static_assert(sizeof(UWidgetContainerStore) == 0x000420, "Wrong size on UWidgetContainerStore");
static_assert(offsetof(UWidgetContainerStore, Button_BackButton) == 0x000248, "Member 'UWidgetContainerStore::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, Featured_1) == 0x000250, "Member 'UWidgetContainerStore::Featured_1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, Featured_2) == 0x000258, "Member 'UWidgetContainerStore::Featured_2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, DailyDeal_1) == 0x000260, "Member 'UWidgetContainerStore::DailyDeal_1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, DailyDeal_2) == 0x000268, "Member 'UWidgetContainerStore::DailyDeal_2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, DailyDeal_3) == 0x000270, "Member 'UWidgetContainerStore::DailyDeal_3' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, DailyDeal_4) == 0x000278, "Member 'UWidgetContainerStore::DailyDeal_4' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, QuarkBundle_0) == 0x000280, "Member 'UWidgetContainerStore::QuarkBundle_0' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, QuarkBundle_1) == 0x000288, "Member 'UWidgetContainerStore::QuarkBundle_1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, QuarkBundle_2) == 0x000290, "Member 'UWidgetContainerStore::QuarkBundle_2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, QuarkBundle_3) == 0x000298, "Member 'UWidgetContainerStore::QuarkBundle_3' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, PremiumBannerWidget) == 0x0002A0, "Member 'UWidgetContainerStore::PremiumBannerWidget' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, SizeBox_PremiumBanner) == 0x0002A8, "Member 'UWidgetContainerStore::SizeBox_PremiumBanner' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, Text_FeaturedTime) == 0x0002B0, "Member 'UWidgetContainerStore::Text_FeaturedTime' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, Text_DailyDealsTime) == 0x0002B8, "Member 'UWidgetContainerStore::Text_DailyDealsTime' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, WidgetSwitcher_StoreTab) == 0x0002C0, "Member 'UWidgetContainerStore::WidgetSwitcher_StoreTab' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, TextBlock_ItemName) == 0x0002C8, "Member 'UWidgetContainerStore::TextBlock_ItemName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, TextBlock_Rarity) == 0x0002D0, "Member 'UWidgetContainerStore::TextBlock_Rarity' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, TextBlock_ItemType) == 0x0002D8, "Member 'UWidgetContainerStore::TextBlock_ItemType' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, TextBlock_Price) == 0x0002E0, "Member 'UWidgetContainerStore::TextBlock_Price' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, Button_Unlock) == 0x0002E8, "Member 'UWidgetContainerStore::Button_Unlock' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, QuarkStore) == 0x0002F0, "Member 'UWidgetContainerStore::QuarkStore' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, CanvasPanel_Background) == 0x0002F8, "Member 'UWidgetContainerStore::CanvasPanel_Background' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, RewardsDataAsset) == 0x000300, "Member 'UWidgetContainerStore::RewardsDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, VerticalBox_QuarkStore) == 0x000308, "Member 'UWidgetContainerStore::VerticalBox_QuarkStore' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, PopupHUDStateClass) == 0x000310, "Member 'UWidgetContainerStore::PopupHUDStateClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, CharacterStylePosition) == 0x000318, "Member 'UWidgetContainerStore::CharacterStylePosition' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, WeaponStylePosition) == 0x000324, "Member 'UWidgetContainerStore::WeaponStylePosition' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, DescriptionFontTypeName) == 0x000330, "Member 'UWidgetContainerStore::DescriptionFontTypeName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, ItemPreviewActor) == 0x000338, "Member 'UWidgetContainerStore::ItemPreviewActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, Slots) == 0x000340, "Member 'UWidgetContainerStore::Slots' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, Bundles) == 0x000390, "Member 'UWidgetContainerStore::Bundles' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, bIsBuyingItem) == 0x0003F8, "Member 'UWidgetContainerStore::bIsBuyingItem' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, FeaturedTimespan) == 0x000400, "Member 'UWidgetContainerStore::FeaturedTimespan' has a wrong offset!");
static_assert(offsetof(UWidgetContainerStore, DailyDealTimespan) == 0x000408, "Member 'UWidgetContainerStore::DailyDealTimespan' has a wrong offset!");

// Class TimeWatch.WidgetContainerTeamsInfo
// 0x00E0 (0x0328 - 0x0248)
class UWidgetContainerTeamsInfo : public UNGDWidgetContainer
{
public:
	int32                                         MaxTeamNameLength;                                 // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OutlineGradientMaterial;                           // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWLeagueDataAsset*                     LeagueDataAsset;                                   // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_RightPanel;                            // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_LeftTeammate;                        // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_RightTeammate;                       // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftUserBG;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftUserAvatar;                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftUserOutline;                             // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftUserLeagueIcon;                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightUserBG;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightUserAvatar;                             // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightUserOutline;                            // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightUserLeagueIcon;                         // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftTeammateBG;                              // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftTeammateAvatar;                          // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftTeammateOutline;                         // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LeftTeammateLeagueIcon;                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightTeammateBG;                             // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightTeammateAvatar;                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightTeammateOutline;                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightTeammateLeagueIcon;                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LeftUserName;                                 // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LeftTeammateName;                             // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RightUserName;                                // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RightTeammateName;                            // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeammateHealthBarStatus*               TeammateHealthBarStatus;                           // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerTeamsInfo">();
	}
	static class UWidgetContainerTeamsInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerTeamsInfo>();
	}
};
static_assert(alignof(UWidgetContainerTeamsInfo) == 0x000008, "Wrong alignment on UWidgetContainerTeamsInfo");
static_assert(sizeof(UWidgetContainerTeamsInfo) == 0x000328, "Wrong size on UWidgetContainerTeamsInfo");
static_assert(offsetof(UWidgetContainerTeamsInfo, MaxTeamNameLength) == 0x000248, "Member 'UWidgetContainerTeamsInfo::MaxTeamNameLength' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, OutlineGradientMaterial) == 0x000250, "Member 'UWidgetContainerTeamsInfo::OutlineGradientMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, LeagueDataAsset) == 0x000258, "Member 'UWidgetContainerTeamsInfo::LeagueDataAsset' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, CanvasPanel_RightPanel) == 0x000260, "Member 'UWidgetContainerTeamsInfo::CanvasPanel_RightPanel' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, HorizontalBox_LeftTeammate) == 0x000268, "Member 'UWidgetContainerTeamsInfo::HorizontalBox_LeftTeammate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, HorizontalBox_RightTeammate) == 0x000270, "Member 'UWidgetContainerTeamsInfo::HorizontalBox_RightTeammate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_LeftUserBG) == 0x000278, "Member 'UWidgetContainerTeamsInfo::Image_LeftUserBG' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_LeftUserAvatar) == 0x000280, "Member 'UWidgetContainerTeamsInfo::Image_LeftUserAvatar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_LeftUserOutline) == 0x000288, "Member 'UWidgetContainerTeamsInfo::Image_LeftUserOutline' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_LeftUserLeagueIcon) == 0x000290, "Member 'UWidgetContainerTeamsInfo::Image_LeftUserLeagueIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_RightUserBG) == 0x000298, "Member 'UWidgetContainerTeamsInfo::Image_RightUserBG' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_RightUserAvatar) == 0x0002A0, "Member 'UWidgetContainerTeamsInfo::Image_RightUserAvatar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_RightUserOutline) == 0x0002A8, "Member 'UWidgetContainerTeamsInfo::Image_RightUserOutline' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_RightUserLeagueIcon) == 0x0002B0, "Member 'UWidgetContainerTeamsInfo::Image_RightUserLeagueIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_LeftTeammateBG) == 0x0002B8, "Member 'UWidgetContainerTeamsInfo::Image_LeftTeammateBG' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_LeftTeammateAvatar) == 0x0002C0, "Member 'UWidgetContainerTeamsInfo::Image_LeftTeammateAvatar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_LeftTeammateOutline) == 0x0002C8, "Member 'UWidgetContainerTeamsInfo::Image_LeftTeammateOutline' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_LeftTeammateLeagueIcon) == 0x0002D0, "Member 'UWidgetContainerTeamsInfo::Image_LeftTeammateLeagueIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_RightTeammateBG) == 0x0002D8, "Member 'UWidgetContainerTeamsInfo::Image_RightTeammateBG' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_RightTeammateAvatar) == 0x0002E0, "Member 'UWidgetContainerTeamsInfo::Image_RightTeammateAvatar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_RightTeammateOutline) == 0x0002E8, "Member 'UWidgetContainerTeamsInfo::Image_RightTeammateOutline' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Image_RightTeammateLeagueIcon) == 0x0002F0, "Member 'UWidgetContainerTeamsInfo::Image_RightTeammateLeagueIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Text_LeftUserName) == 0x0002F8, "Member 'UWidgetContainerTeamsInfo::Text_LeftUserName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Text_LeftTeammateName) == 0x000300, "Member 'UWidgetContainerTeamsInfo::Text_LeftTeammateName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Text_RightUserName) == 0x000308, "Member 'UWidgetContainerTeamsInfo::Text_RightUserName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, Text_RightTeammateName) == 0x000310, "Member 'UWidgetContainerTeamsInfo::Text_RightTeammateName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTeamsInfo, TeammateHealthBarStatus) == 0x000318, "Member 'UWidgetContainerTeamsInfo::TeammateHealthBarStatus' has a wrong offset!");

// Class TimeWatch.WidgetContainerTeamsScoreboard
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerTeamsScoreboard : public UNGDWidgetContainer
{
public:
	class UTWScoreboardWidget*                    ScoreboardWidget;                                  // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerTeamsScoreboard">();
	}
	static class UWidgetContainerTeamsScoreboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerTeamsScoreboard>();
	}
};
static_assert(alignof(UWidgetContainerTeamsScoreboard) == 0x000008, "Wrong alignment on UWidgetContainerTeamsScoreboard");
static_assert(sizeof(UWidgetContainerTeamsScoreboard) == 0x000250, "Wrong size on UWidgetContainerTeamsScoreboard");
static_assert(offsetof(UWidgetContainerTeamsScoreboard, ScoreboardWidget) == 0x000248, "Member 'UWidgetContainerTeamsScoreboard::ScoreboardWidget' has a wrong offset!");

// Class TimeWatch.WidgetContainerTimeLoopInfo
// 0x0010 (0x0258 - 0x0248)
class UWidgetContainerTimeLoopInfo : public UNGDWidgetContainer
{
public:
	class UTWMatchClockWidget*                    MatchClock;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWTimelinesWidget*                     Timelines;                                         // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerTimeLoopInfo">();
	}
	static class UWidgetContainerTimeLoopInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerTimeLoopInfo>();
	}
};
static_assert(alignof(UWidgetContainerTimeLoopInfo) == 0x000008, "Wrong alignment on UWidgetContainerTimeLoopInfo");
static_assert(sizeof(UWidgetContainerTimeLoopInfo) == 0x000258, "Wrong size on UWidgetContainerTimeLoopInfo");
static_assert(offsetof(UWidgetContainerTimeLoopInfo, MatchClock) == 0x000248, "Member 'UWidgetContainerTimeLoopInfo::MatchClock' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTimeLoopInfo, Timelines) == 0x000250, "Member 'UWidgetContainerTimeLoopInfo::Timelines' has a wrong offset!");

// Class TimeWatch.WidgetContainerTipNotification
// 0x0078 (0x02C0 - 0x0248)
class UWidgetContainerTipNotification : public UNGDWidgetContainer
{
public:
	TSubclassOf<class UWidgetTipNotification>     WidgetTipClass;                                    // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FTipNotificationConfig> TipConfigs;                                   // 0x0250(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasPanel_WidgetTipContainer;                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetTipNotification*                 CurrentTip;                                        // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidgetTipNotification*>         QueueTip;                                          // 0x02B0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void HideCurrentTip();
	void OnHideEnd(class UWidgetTipNotification* NotificationToRemove);
	class UWidgetTipNotification* ShowNotification(const class FText& Title, const class FText& Description, const class FString& NotificationID, int32 ShowPriority, float Duration, float MaxExpiration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerTipNotification">();
	}
	static class UWidgetContainerTipNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerTipNotification>();
	}
};
static_assert(alignof(UWidgetContainerTipNotification) == 0x000008, "Wrong alignment on UWidgetContainerTipNotification");
static_assert(sizeof(UWidgetContainerTipNotification) == 0x0002C0, "Wrong size on UWidgetContainerTipNotification");
static_assert(offsetof(UWidgetContainerTipNotification, WidgetTipClass) == 0x000248, "Member 'UWidgetContainerTipNotification::WidgetTipClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTipNotification, TipConfigs) == 0x000250, "Member 'UWidgetContainerTipNotification::TipConfigs' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTipNotification, CanvasPanel_WidgetTipContainer) == 0x0002A0, "Member 'UWidgetContainerTipNotification::CanvasPanel_WidgetTipContainer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTipNotification, CurrentTip) == 0x0002A8, "Member 'UWidgetContainerTipNotification::CurrentTip' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTipNotification, QueueTip) == 0x0002B0, "Member 'UWidgetContainerTipNotification::QueueTip' has a wrong offset!");

// Class TimeWatch.WidgetContainerTraining
// 0x0378 (0x05C0 - 0x0248)
class UWidgetContainerTraining : public UNGDWidgetContainer
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher_TrainingTypes;                      // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTWModeSelectionSlot*                   Mode_Tutorials;                                    // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_ShootingRange;                                // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWModeSelectionSlot*                   Mode_TimeloopDrill;                                // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_Play;                                       // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_SelectedChallengeName;                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_SelectedChallengeDescription;            // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_Rewards;                               // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_BegginerTuts;                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_MediumTuts;                            // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_AdvancedTuts;                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_GamemodeTuts;                          // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_Tutorials;                               // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_VideoInfo;                           // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_VideoDurationAmount;                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_BegginerSectionText;                     // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_MediumSectionText;                       // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_AdvancedSectionText;                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_GamemodeSectionText;                     // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Reward;                                  // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Requirements;                            // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_RewardClaimed;                           // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ChallengePreview;                            // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RewardIcon;                                  // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWTutorialEntryWidget>     TutorialEntryClass;                                // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWTutorialEntryWidget*>         TutorialEntryWidgets;                              // 0x0318(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              XpIcon;                                            // 0x0328(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              CoinsIcon;                                         // 0x0350(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClaimedRewardTextOpacity;                          // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTWImagePopupData                      CongratulationsPopup;                              // 0x0380(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTWImagePopupData                      CasualUnlockedPopup;                               // 0x03B8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x1C0];                                    // 0x03F0(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWTutorialEntryWidget*                 LastSelectedEntry;                                 // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPlayerGraduated;                                // 0x05B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackButtonClicked();
	void OnPartyDataUpdated(const bool bPartyStructureChanged);
	void OnPlayButtonClicked();
	void OnSetRegistryResponseReceived(bool bWasSuccessful, const class FString& Result);
	void OnTutorialEntryClicked(class UTWTutorialEntryWidget* TutorialEntryClicked);
	void SetActiveTutorialsWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerTraining">();
	}
	static class UWidgetContainerTraining* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerTraining>();
	}
};
static_assert(alignof(UWidgetContainerTraining) == 0x000008, "Wrong alignment on UWidgetContainerTraining");
static_assert(sizeof(UWidgetContainerTraining) == 0x0005C0, "Wrong size on UWidgetContainerTraining");
static_assert(offsetof(UWidgetContainerTraining, WidgetSwitcher_TrainingTypes) == 0x000248, "Member 'UWidgetContainerTraining::WidgetSwitcher_TrainingTypes' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, Mode_Tutorials) == 0x000250, "Member 'UWidgetContainerTraining::Mode_Tutorials' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, Mode_ShootingRange) == 0x000258, "Member 'UWidgetContainerTraining::Mode_ShootingRange' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, Mode_TimeloopDrill) == 0x000260, "Member 'UWidgetContainerTraining::Mode_TimeloopDrill' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, Button_BackButton) == 0x000268, "Member 'UWidgetContainerTraining::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, Button_Play) == 0x000270, "Member 'UWidgetContainerTraining::Button_Play' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_SelectedChallengeName) == 0x000278, "Member 'UWidgetContainerTraining::TextBlock_SelectedChallengeName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_SelectedChallengeDescription) == 0x000280, "Member 'UWidgetContainerTraining::TextBlock_SelectedChallengeDescription' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, VerticalBox_Rewards) == 0x000288, "Member 'UWidgetContainerTraining::VerticalBox_Rewards' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, VerticalBox_BegginerTuts) == 0x000290, "Member 'UWidgetContainerTraining::VerticalBox_BegginerTuts' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, VerticalBox_MediumTuts) == 0x000298, "Member 'UWidgetContainerTraining::VerticalBox_MediumTuts' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, VerticalBox_AdvancedTuts) == 0x0002A0, "Member 'UWidgetContainerTraining::VerticalBox_AdvancedTuts' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, VerticalBox_GamemodeTuts) == 0x0002A8, "Member 'UWidgetContainerTraining::VerticalBox_GamemodeTuts' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, ScrollBox_Tutorials) == 0x0002B0, "Member 'UWidgetContainerTraining::ScrollBox_Tutorials' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, HorizontalBox_VideoInfo) == 0x0002B8, "Member 'UWidgetContainerTraining::HorizontalBox_VideoInfo' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_VideoDurationAmount) == 0x0002C0, "Member 'UWidgetContainerTraining::TextBlock_VideoDurationAmount' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_BegginerSectionText) == 0x0002C8, "Member 'UWidgetContainerTraining::TextBlock_BegginerSectionText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_MediumSectionText) == 0x0002D0, "Member 'UWidgetContainerTraining::TextBlock_MediumSectionText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_AdvancedSectionText) == 0x0002D8, "Member 'UWidgetContainerTraining::TextBlock_AdvancedSectionText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_GamemodeSectionText) == 0x0002E0, "Member 'UWidgetContainerTraining::TextBlock_GamemodeSectionText' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_Reward) == 0x0002E8, "Member 'UWidgetContainerTraining::TextBlock_Reward' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_Requirements) == 0x0002F0, "Member 'UWidgetContainerTraining::TextBlock_Requirements' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TextBlock_RewardClaimed) == 0x0002F8, "Member 'UWidgetContainerTraining::TextBlock_RewardClaimed' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, Image_ChallengePreview) == 0x000300, "Member 'UWidgetContainerTraining::Image_ChallengePreview' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, Image_RewardIcon) == 0x000308, "Member 'UWidgetContainerTraining::Image_RewardIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TutorialEntryClass) == 0x000310, "Member 'UWidgetContainerTraining::TutorialEntryClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, TutorialEntryWidgets) == 0x000318, "Member 'UWidgetContainerTraining::TutorialEntryWidgets' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, XpIcon) == 0x000328, "Member 'UWidgetContainerTraining::XpIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, CoinsIcon) == 0x000350, "Member 'UWidgetContainerTraining::CoinsIcon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, ClaimedRewardTextOpacity) == 0x000378, "Member 'UWidgetContainerTraining::ClaimedRewardTextOpacity' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, CongratulationsPopup) == 0x000380, "Member 'UWidgetContainerTraining::CongratulationsPopup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, CasualUnlockedPopup) == 0x0003B8, "Member 'UWidgetContainerTraining::CasualUnlockedPopup' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, LastSelectedEntry) == 0x0005B0, "Member 'UWidgetContainerTraining::LastSelectedEntry' has a wrong offset!");
static_assert(offsetof(UWidgetContainerTraining, bIsPlayerGraduated) == 0x0005B8, "Member 'UWidgetContainerTraining::bIsPlayerGraduated' has a wrong offset!");

// Class TimeWatch.WidgetContainerTutorialObjective
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerTutorialObjective final : public UNGDWidgetContainer
{
public:
	class URichTextBlock*                         RichText_Objective;                                // 0x0248(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerTutorialObjective">();
	}
	static class UWidgetContainerTutorialObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerTutorialObjective>();
	}
};
static_assert(alignof(UWidgetContainerTutorialObjective) == 0x000008, "Wrong alignment on UWidgetContainerTutorialObjective");
static_assert(sizeof(UWidgetContainerTutorialObjective) == 0x000250, "Wrong size on UWidgetContainerTutorialObjective");
static_assert(offsetof(UWidgetContainerTutorialObjective, RichText_Objective) == 0x000248, "Member 'UWidgetContainerTutorialObjective::RichText_Objective' has a wrong offset!");

// Class TimeWatch.WidgetContainerVersusScreen
// 0x00B0 (0x02F8 - 0x0248)
class UWidgetContainerVersusScreen : public UNGDWidgetContainer
{
public:
	class UTextBlock*                             Text_MapName;                                      // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_GameMode;                                     // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_2v2LeftChar1;                           // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_2v2LeftChar2;                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_2v2RightChar1;                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_2v2RightChar2;                          // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_1V1Left;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPlayerCardWidget*                    PlayerCard_1V1Right;                               // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_1v1LeftChar;                                 // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_1v1LeftChar;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_2v2LeftChar1;                                // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_2v2LeftChar1;                                 // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_2v2LeftChar2;                                // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_2v2LeftChar2;                                 // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_1v1RigthChar;                                // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_1v1RigthChar;                                 // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_2v2RigthChar1;                               // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_2v2RigthChar1;                                // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_2v2RigthChar2;                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_2v2RigthChar2;                                // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTWPlayerCardWidget*>            PlayerCardsToShowAfterAnimation;                   // 0x02E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void InitializeVersusScreen();
	void ShowPlayerCards();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerVersusScreen">();
	}
	static class UWidgetContainerVersusScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerVersusScreen>();
	}
};
static_assert(alignof(UWidgetContainerVersusScreen) == 0x000008, "Wrong alignment on UWidgetContainerVersusScreen");
static_assert(sizeof(UWidgetContainerVersusScreen) == 0x0002F8, "Wrong size on UWidgetContainerVersusScreen");
static_assert(offsetof(UWidgetContainerVersusScreen, Text_MapName) == 0x000248, "Member 'UWidgetContainerVersusScreen::Text_MapName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Text_GameMode) == 0x000250, "Member 'UWidgetContainerVersusScreen::Text_GameMode' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, PlayerCard_2v2LeftChar1) == 0x000258, "Member 'UWidgetContainerVersusScreen::PlayerCard_2v2LeftChar1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, PlayerCard_2v2LeftChar2) == 0x000260, "Member 'UWidgetContainerVersusScreen::PlayerCard_2v2LeftChar2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, PlayerCard_2v2RightChar1) == 0x000268, "Member 'UWidgetContainerVersusScreen::PlayerCard_2v2RightChar1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, PlayerCard_2v2RightChar2) == 0x000270, "Member 'UWidgetContainerVersusScreen::PlayerCard_2v2RightChar2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, PlayerCard_1V1Left) == 0x000278, "Member 'UWidgetContainerVersusScreen::PlayerCard_1V1Left' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, PlayerCard_1V1Right) == 0x000280, "Member 'UWidgetContainerVersusScreen::PlayerCard_1V1Right' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Image_1v1LeftChar) == 0x000288, "Member 'UWidgetContainerVersusScreen::Image_1v1LeftChar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Text_1v1LeftChar) == 0x000290, "Member 'UWidgetContainerVersusScreen::Text_1v1LeftChar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Image_2v2LeftChar1) == 0x000298, "Member 'UWidgetContainerVersusScreen::Image_2v2LeftChar1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Text_2v2LeftChar1) == 0x0002A0, "Member 'UWidgetContainerVersusScreen::Text_2v2LeftChar1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Image_2v2LeftChar2) == 0x0002A8, "Member 'UWidgetContainerVersusScreen::Image_2v2LeftChar2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Text_2v2LeftChar2) == 0x0002B0, "Member 'UWidgetContainerVersusScreen::Text_2v2LeftChar2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Image_1v1RigthChar) == 0x0002B8, "Member 'UWidgetContainerVersusScreen::Image_1v1RigthChar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Text_1v1RigthChar) == 0x0002C0, "Member 'UWidgetContainerVersusScreen::Text_1v1RigthChar' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Image_2v2RigthChar1) == 0x0002C8, "Member 'UWidgetContainerVersusScreen::Image_2v2RigthChar1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Text_2v2RigthChar1) == 0x0002D0, "Member 'UWidgetContainerVersusScreen::Text_2v2RigthChar1' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Image_2v2RigthChar2) == 0x0002D8, "Member 'UWidgetContainerVersusScreen::Image_2v2RigthChar2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, Text_2v2RigthChar2) == 0x0002E0, "Member 'UWidgetContainerVersusScreen::Text_2v2RigthChar2' has a wrong offset!");
static_assert(offsetof(UWidgetContainerVersusScreen, PlayerCardsToShowAfterAnimation) == 0x0002E8, "Member 'UWidgetContainerVersusScreen::PlayerCardsToShowAfterAnimation' has a wrong offset!");

// Class TimeWatch.WidgetContainerWatermarkNDA
// 0x0018 (0x0260 - 0x0248)
class UWidgetContainerWatermarkNDA : public UNGDWidgetContainer
{
public:
	float                                         AlternatingTime;                                   // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextBlock_Username;                                // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTime;                                       // 0x0258(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoginComplete(bool bWasSuccessful, const class FString& ErrorString);
	void SetUsername(const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerWatermarkNDA">();
	}
	static class UWidgetContainerWatermarkNDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerWatermarkNDA>();
	}
};
static_assert(alignof(UWidgetContainerWatermarkNDA) == 0x000008, "Wrong alignment on UWidgetContainerWatermarkNDA");
static_assert(sizeof(UWidgetContainerWatermarkNDA) == 0x000260, "Wrong size on UWidgetContainerWatermarkNDA");
static_assert(offsetof(UWidgetContainerWatermarkNDA, AlternatingTime) == 0x000248, "Member 'UWidgetContainerWatermarkNDA::AlternatingTime' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWatermarkNDA, TextBlock_Username) == 0x000250, "Member 'UWidgetContainerWatermarkNDA::TextBlock_Username' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWatermarkNDA, CurrentTime) == 0x000258, "Member 'UWidgetContainerWatermarkNDA::CurrentTime' has a wrong offset!");

// Class TimeWatch.WidgetContainerWeaponCustomization
// 0x0158 (0x03A0 - 0x0248)
class UWidgetContainerWeaponCustomization : public UNGDWidgetContainer
{
public:
	class UCanvasPanel*                           CanvasPanel_Background;                            // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ScreenName;                              // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_StylesScroll;                            // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                Button_ContextualAction;                           // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         TextBlock_ItemType;                                // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ItemName;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Requirement;                             // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_RightClickAction;                        // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_RightClick;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWPremiumBannerWidget*                 PremiumBannerWidget;                               // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWWeaponSkinPreviewActor*              WeaponSkinPreviewActor;                            // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATWSkinPreviewActor*                    CharacterSkinPreviewActor;                         // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTWStyleButtonWidget>       StyleButtonClass;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ENGDBackendItemRarity, struct FRarityInfo> RarityConfig;                                    // 0x02B8(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         StyleButtonWidth;                                  // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StyleButtonHeigth;                                 // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UTWStyleButtonWidget*> AvailableStylesButtons;                         // 0x0310(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsBuyingStyle;                                    // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTWWeaponStyleDataAsset*                CurrentWeaponStyleData;                            // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x30];                                     // 0x0370(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBuyItemSuccess();
	void BuyWeaponSkin();
	void BuyWeaponSkinPopUp();
	void OnBackButtonClicked();
	void OnBackgroundHovered();
	void OnBuyWeaponSkinComplete(bool bWasSuccessful, const class FString& ErrorString, const class FString& SKU, int32 newCoinsAmmount);
	void OnContextualButtonClicked();
	void OnStyleClicked(const class UTWItemDataAsset* SelectedStyleData);
	void OnStyleHovered(const class UTWItemDataAsset* SelectedStyleData);
	void OnUnlockPremiumButtonClicked();
	void OpenPremiumPopup();
	void SaveWeaponLoadoutEntry();
	void TryEquipCurrentItem();
	void TryEquipItem(const class UTWItemDataAsset* SelectedStyleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerWeaponCustomization">();
	}
	static class UWidgetContainerWeaponCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerWeaponCustomization>();
	}
};
static_assert(alignof(UWidgetContainerWeaponCustomization) == 0x000008, "Wrong alignment on UWidgetContainerWeaponCustomization");
static_assert(sizeof(UWidgetContainerWeaponCustomization) == 0x0003A0, "Wrong size on UWidgetContainerWeaponCustomization");
static_assert(offsetof(UWidgetContainerWeaponCustomization, CanvasPanel_Background) == 0x000248, "Member 'UWidgetContainerWeaponCustomization::CanvasPanel_Background' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, Button_BackButton) == 0x000250, "Member 'UWidgetContainerWeaponCustomization::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, TextBlock_ScreenName) == 0x000258, "Member 'UWidgetContainerWeaponCustomization::TextBlock_ScreenName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, ScrollBox_StylesScroll) == 0x000260, "Member 'UWidgetContainerWeaponCustomization::ScrollBox_StylesScroll' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, Button_ContextualAction) == 0x000268, "Member 'UWidgetContainerWeaponCustomization::Button_ContextualAction' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, TextBlock_ItemType) == 0x000270, "Member 'UWidgetContainerWeaponCustomization::TextBlock_ItemType' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, TextBlock_ItemName) == 0x000278, "Member 'UWidgetContainerWeaponCustomization::TextBlock_ItemName' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, TextBlock_Requirement) == 0x000280, "Member 'UWidgetContainerWeaponCustomization::TextBlock_Requirement' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, TextBlock_RightClickAction) == 0x000288, "Member 'UWidgetContainerWeaponCustomization::TextBlock_RightClickAction' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, Image_RightClick) == 0x000290, "Member 'UWidgetContainerWeaponCustomization::Image_RightClick' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, PremiumBannerWidget) == 0x000298, "Member 'UWidgetContainerWeaponCustomization::PremiumBannerWidget' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, WeaponSkinPreviewActor) == 0x0002A0, "Member 'UWidgetContainerWeaponCustomization::WeaponSkinPreviewActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, CharacterSkinPreviewActor) == 0x0002A8, "Member 'UWidgetContainerWeaponCustomization::CharacterSkinPreviewActor' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, StyleButtonClass) == 0x0002B0, "Member 'UWidgetContainerWeaponCustomization::StyleButtonClass' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, RarityConfig) == 0x0002B8, "Member 'UWidgetContainerWeaponCustomization::RarityConfig' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, StyleButtonWidth) == 0x000308, "Member 'UWidgetContainerWeaponCustomization::StyleButtonWidth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, StyleButtonHeigth) == 0x00030C, "Member 'UWidgetContainerWeaponCustomization::StyleButtonHeigth' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, AvailableStylesButtons) == 0x000310, "Member 'UWidgetContainerWeaponCustomization::AvailableStylesButtons' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, bIsBuyingStyle) == 0x000360, "Member 'UWidgetContainerWeaponCustomization::bIsBuyingStyle' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponCustomization, CurrentWeaponStyleData) == 0x000368, "Member 'UWidgetContainerWeaponCustomization::CurrentWeaponStyleData' has a wrong offset!");

// Class TimeWatch.WidgetContainerWeaponSelection
// 0x0038 (0x0280 - 0x0248)
class UWidgetContainerWeaponSelection : public UNGDWidgetContainer
{
public:
	class UTWStandardButtonWidget*                Button_BackButton;                                 // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         HorizontalBox_Slots;                               // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponSlotHeight;                                  // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSlotsPerColumns;                                // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ColumnsAmount;                                     // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTWModeSelectionSlot>       WeaponSeleccionSlotClass;                          // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackButtonClicked();
	void OnSlotSelected(class FString* SlotSKU);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerWeaponSelection">();
	}
	static class UWidgetContainerWeaponSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerWeaponSelection>();
	}
};
static_assert(alignof(UWidgetContainerWeaponSelection) == 0x000008, "Wrong alignment on UWidgetContainerWeaponSelection");
static_assert(sizeof(UWidgetContainerWeaponSelection) == 0x000280, "Wrong size on UWidgetContainerWeaponSelection");
static_assert(offsetof(UWidgetContainerWeaponSelection, Button_BackButton) == 0x000248, "Member 'UWidgetContainerWeaponSelection::Button_BackButton' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponSelection, HorizontalBox_Slots) == 0x000258, "Member 'UWidgetContainerWeaponSelection::HorizontalBox_Slots' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponSelection, WeaponSlotHeight) == 0x000260, "Member 'UWidgetContainerWeaponSelection::WeaponSlotHeight' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponSelection, MaxSlotsPerColumns) == 0x000264, "Member 'UWidgetContainerWeaponSelection::MaxSlotsPerColumns' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponSelection, ColumnsAmount) == 0x000268, "Member 'UWidgetContainerWeaponSelection::ColumnsAmount' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponSelection, WeaponSeleccionSlotClass) == 0x000270, "Member 'UWidgetContainerWeaponSelection::WeaponSeleccionSlotClass' has a wrong offset!");

// Class TimeWatch.WidgetContainerWeaponSight
// 0x0008 (0x0250 - 0x0248)
class UWidgetContainerWeaponSight : public UNGDWidgetContainer
{
public:
	class ATimeWatchCharacter*                    CurrentTWChar;                                     // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_PlayHideSightAnim(class ATimeWatchCharacter* TWChar, class AFirearm* Firearm, float Progress);
	void BP_PlaySightAnim(class ATimeWatchCharacter* TWChar, class AFirearm* Firearm, float Progress);
	void BP_ResetWidget(class ATimeWatchCharacter* TWChar, class AFirearm* Firearm, bool ResetMesh);
	void CleanEventsCharacter();
	void RegisterCharacter(class ATimeWatchCharacter* TWChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerWeaponSight">();
	}
	static class UWidgetContainerWeaponSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerWeaponSight>();
	}
};
static_assert(alignof(UWidgetContainerWeaponSight) == 0x000008, "Wrong alignment on UWidgetContainerWeaponSight");
static_assert(sizeof(UWidgetContainerWeaponSight) == 0x000250, "Wrong size on UWidgetContainerWeaponSight");
static_assert(offsetof(UWidgetContainerWeaponSight, CurrentTWChar) == 0x000248, "Member 'UWidgetContainerWeaponSight::CurrentTWChar' has a wrong offset!");

// Class TimeWatch.WidgetContainerWeaponStatus
// 0x0080 (0x02C8 - 0x0248)
class UWidgetContainerWeaponStatus : public UNGDWidgetContainer
{
public:
	TSubclassOf<class UTWWeaponSelectionSlot>     TWWeaponSelectionSlotTemplate;                     // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSelectedWeapon;                                // 0x0250(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x1];                                      // 0x0251(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAlreadyInitialized;                               // 0x0252(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_253[0x5];                                      // 0x0253(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         HorizontalBox_WeaponsWidgetsContainer;             // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EWeaponType, class UTWWeaponSelectionSlot*> WeaponsSlots;                                   // 0x0260(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ATimeWatchCharacter*                    TWOwnerCharacter;                                  // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWSelectedWeaponInfo*                  SelectedWeaponInfo_InUse;                          // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWSelectedWeaponInfo*                  SelectedWeaponInfo_OnHold;                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnCollapseWeaponSelected();
	void BP_OnPrimaryWeaponSwitchedAbility();
	void BP_OnRefreshOwnerData();
	void BP_OnReset();
	void BP_OnSecondaryWeaponSettedAbility();
	void BP_OnWeaponDrawed();
	void BP_OnWeaponSelected(int32 SelectedWeaponIndex);
	void BP_PlayCollapseToBottomAnimation(float FromTime);
	void BP_RestoreWidgetToCollapsedVersion();
	void BP_RestoreWidgetToInit();
	void BP_RestoreWidgetToWeaponSelectedVersion();
	void InitializeWidget();
	void OnGameStateChanged(EFluxCapacitorStates OldState, EFluxCapacitorStates NewState);
	void OnRefreshOwnerData();
	void OnReset(class ATimeWatchCharacter* OwnerTWCharacter);
	void OnWeaponDrawed(class ATemporalWeapon* TWWeapon, class ATemporalWeapon* HoldTWWeapon);
	void OnWeaponSelected(int32 WeaponIndex);
	void OnWeaponSelectionCollapse();
	void PlayCollapseToBottomAnimation();
	void RestoreWidgetToCollapsedVersion();
	void RestoreWidgetToInit();
	void RestoreWidgetToWeaponSelectedVersion();
	void SetDesiredWeapon(int32 DesiredWeaponIndex);
	void SetWeaponImageType(EWeaponIconType WeaponIconType, class ATemporalWeapon* TemporalWeapon);
	void SetWeaponsImageType(EWeaponIconType WeaponIconType);
	void SkipCollapseAnimation();

	class ATimeWatchCharacter* GetTimeWatchOwnerCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerWeaponStatus">();
	}
	static class UWidgetContainerWeaponStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerWeaponStatus>();
	}
};
static_assert(alignof(UWidgetContainerWeaponStatus) == 0x000008, "Wrong alignment on UWidgetContainerWeaponStatus");
static_assert(sizeof(UWidgetContainerWeaponStatus) == 0x0002C8, "Wrong size on UWidgetContainerWeaponStatus");
static_assert(offsetof(UWidgetContainerWeaponStatus, TWWeaponSelectionSlotTemplate) == 0x000248, "Member 'UWidgetContainerWeaponStatus::TWWeaponSelectionSlotTemplate' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponStatus, bHasSelectedWeapon) == 0x000250, "Member 'UWidgetContainerWeaponStatus::bHasSelectedWeapon' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponStatus, bAlreadyInitialized) == 0x000252, "Member 'UWidgetContainerWeaponStatus::bAlreadyInitialized' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponStatus, HorizontalBox_WeaponsWidgetsContainer) == 0x000258, "Member 'UWidgetContainerWeaponStatus::HorizontalBox_WeaponsWidgetsContainer' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponStatus, WeaponsSlots) == 0x000260, "Member 'UWidgetContainerWeaponStatus::WeaponsSlots' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponStatus, TWOwnerCharacter) == 0x0002B0, "Member 'UWidgetContainerWeaponStatus::TWOwnerCharacter' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponStatus, SelectedWeaponInfo_InUse) == 0x0002B8, "Member 'UWidgetContainerWeaponStatus::SelectedWeaponInfo_InUse' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWeaponStatus, SelectedWeaponInfo_OnHold) == 0x0002C0, "Member 'UWidgetContainerWeaponStatus::SelectedWeaponInfo_OnHold' has a wrong offset!");

// Class TimeWatch.WidgetContainerWishlist
// 0x0018 (0x0260 - 0x0248)
class UWidgetContainerWishlist final : public UNGDWidgetContainer
{
public:
	class UCanvasPanel*                           Canvas_PlayersPromo;                               // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Canvas_SpectatorPromo;                             // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTWStandardButtonWidget*                BackBtn;                                           // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GoToMainMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetContainerWishlist">();
	}
	static class UWidgetContainerWishlist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetContainerWishlist>();
	}
};
static_assert(alignof(UWidgetContainerWishlist) == 0x000008, "Wrong alignment on UWidgetContainerWishlist");
static_assert(sizeof(UWidgetContainerWishlist) == 0x000260, "Wrong size on UWidgetContainerWishlist");
static_assert(offsetof(UWidgetContainerWishlist, Canvas_PlayersPromo) == 0x000248, "Member 'UWidgetContainerWishlist::Canvas_PlayersPromo' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWishlist, Canvas_SpectatorPromo) == 0x000250, "Member 'UWidgetContainerWishlist::Canvas_SpectatorPromo' has a wrong offset!");
static_assert(offsetof(UWidgetContainerWishlist, BackBtn) == 0x000258, "Member 'UWidgetContainerWishlist::BackBtn' has a wrong offset!");

// Class TimeWatch.WidgetTipNotification
// 0x0048 (0x0278 - 0x0230)
class UWidgetTipNotification : public UUserWidget
{
public:
	class UTextBlock*                             TextBox_Title;                                     // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextBox_Description;                               // 0x0238(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Background;                                  // 0x0240(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Icon;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x28];                                     // 0x0250(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHideEndBroadcast();
	void PlayHideAnim();
	void PlayShowAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetTipNotification">();
	}
	static class UWidgetTipNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetTipNotification>();
	}
};
static_assert(alignof(UWidgetTipNotification) == 0x000008, "Wrong alignment on UWidgetTipNotification");
static_assert(sizeof(UWidgetTipNotification) == 0x000278, "Wrong size on UWidgetTipNotification");
static_assert(offsetof(UWidgetTipNotification, TextBox_Title) == 0x000230, "Member 'UWidgetTipNotification::TextBox_Title' has a wrong offset!");
static_assert(offsetof(UWidgetTipNotification, TextBox_Description) == 0x000238, "Member 'UWidgetTipNotification::TextBox_Description' has a wrong offset!");
static_assert(offsetof(UWidgetTipNotification, Image_Background) == 0x000240, "Member 'UWidgetTipNotification::Image_Background' has a wrong offset!");
static_assert(offsetof(UWidgetTipNotification, Image_Icon) == 0x000248, "Member 'UWidgetTipNotification::Image_Icon' has a wrong offset!");

}

