#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MagicLeapPlanes

#include "Basic.hpp"

#include "MagicLeapPlanes_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class MagicLeapPlanes.MagicLeapPlanesComponent
// 0x0040 (0x0230 - 0x01F0)
class UMagicLeapPlanesComponent final : public USceneComponent
{
public:
	TArray<EMagicLeapPlaneQueryFlags>             QueryFlags;                                        // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBoxComponent*                          SearchVolume;                                      // 0x0200(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxResults;                                        // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHolePerimeter;                                  // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlaneArea;                                      // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const bool bSuccess, const TArray<struct FMagicLeapPlaneResult>& Planes, const TArray<struct FMagicLeapPlaneBoundaries>& Polygons)> OnPlanesQueryResult; // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool RequestPlanesAsync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapPlanesComponent">();
	}
	static class UMagicLeapPlanesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicLeapPlanesComponent>();
	}
};
static_assert(alignof(UMagicLeapPlanesComponent) == 0x000010, "Wrong alignment on UMagicLeapPlanesComponent");
static_assert(sizeof(UMagicLeapPlanesComponent) == 0x000230, "Wrong size on UMagicLeapPlanesComponent");
static_assert(offsetof(UMagicLeapPlanesComponent, QueryFlags) == 0x0001F0, "Member 'UMagicLeapPlanesComponent::QueryFlags' has a wrong offset!");
static_assert(offsetof(UMagicLeapPlanesComponent, SearchVolume) == 0x000200, "Member 'UMagicLeapPlanesComponent::SearchVolume' has a wrong offset!");
static_assert(offsetof(UMagicLeapPlanesComponent, MaxResults) == 0x000208, "Member 'UMagicLeapPlanesComponent::MaxResults' has a wrong offset!");
static_assert(offsetof(UMagicLeapPlanesComponent, MinHolePerimeter) == 0x00020C, "Member 'UMagicLeapPlanesComponent::MinHolePerimeter' has a wrong offset!");
static_assert(offsetof(UMagicLeapPlanesComponent, MinPlaneArea) == 0x000210, "Member 'UMagicLeapPlanesComponent::MinPlaneArea' has a wrong offset!");
static_assert(offsetof(UMagicLeapPlanesComponent, OnPlanesQueryResult) == 0x000218, "Member 'UMagicLeapPlanesComponent::OnPlanesQueryResult' has a wrong offset!");

// Class MagicLeapPlanes.MagicLeapPlanesFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMagicLeapPlanesFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CreateTracker();
	static bool DestroyTracker();
	static struct FTransform GetContentScale(const class AActor* ContentActor, const struct FMagicLeapPlaneResult& PlaneResult);
	static bool IsTrackerValid();
	static bool PlanesQueryBeginAsync(const struct FMagicLeapPlanesQuery& Query, const TDelegate<void(const bool bSuccess, const TArray<struct FMagicLeapPlaneResult>& Planes, const TArray<struct FMagicLeapPlaneBoundaries>& Polygons)>& ResultDelegate);
	static void RemoveFlagsNotInQuery(const TArray<EMagicLeapPlaneQueryFlags>& InQueryFlags, const TArray<EMagicLeapPlaneQueryFlags>& InResultFlags, TArray<EMagicLeapPlaneQueryFlags>* OutFlags);
	static void ReorderPlaneFlags(const TArray<EMagicLeapPlaneQueryFlags>& InPriority, const TArray<EMagicLeapPlaneQueryFlags>& InFlagsToReorder, TArray<EMagicLeapPlaneQueryFlags>* OutReorderedFlags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapPlanesFunctionLibrary">();
	}
	static class UMagicLeapPlanesFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicLeapPlanesFunctionLibrary>();
	}
};
static_assert(alignof(UMagicLeapPlanesFunctionLibrary) == 0x000008, "Wrong alignment on UMagicLeapPlanesFunctionLibrary");
static_assert(sizeof(UMagicLeapPlanesFunctionLibrary) == 0x000028, "Wrong size on UMagicLeapPlanesFunctionLibrary");

}

