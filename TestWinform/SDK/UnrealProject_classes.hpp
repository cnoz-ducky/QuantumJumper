#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UnrealProject

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "UnrealProject_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_classes.hpp"
#include "AIModule_classes.hpp"
#include "PhysXVehicles_classes.hpp"


namespace SDK
{

// Class UnrealProject.BaseActor
// 0x0018 (0x0230 - 0x0218)
class ABaseActor : public AActor
{
public:
	bool                                          bIsActive;                                         // 0x0218(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedTickTime;                                     // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ANGDCharacter* GetLocalCharacter() const;
	bool IsActive() const;
	bool IsOwnedByLocalPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseActor">();
	}
	static class ABaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseActor>();
	}
};
static_assert(alignof(ABaseActor) == 0x000008, "Wrong alignment on ABaseActor");
static_assert(sizeof(ABaseActor) == 0x000230, "Wrong size on ABaseActor");
static_assert(offsetof(ABaseActor, bIsActive) == 0x000218, "Member 'ABaseActor::bIsActive' has a wrong offset!");
static_assert(offsetof(ABaseActor, FixedTickTime) == 0x00021C, "Member 'ABaseActor::FixedTickTime' has a wrong offset!");

// Class UnrealProject.Item
// 0x0080 (0x02B0 - 0x0230)
class AItem : public ABaseActor
{
public:
	class FString                                 ItemIdentifier;                                    // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ItemName;                                          // 0x0240(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ItemIcon;                                          // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VisibleWhenAdquired;                               // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanBeStored;                                       // 0x0261(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262[0x2];                                      // 0x0262(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxStack;                                          // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemPickup>                ItemPickupClass;                                   // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Quantity;                                          // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EItemFlags                                    Flags_0;                                           // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryData                         InventoryData;                                     // 0x0280(0x0010)(Net, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FInventoryData                         LocalInventoryData;                                // 0x0290(0x0010)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        ItemRoot;                                          // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTransferable;                                   // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDefaultItem;                                    // 0x02A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_InventoryData();
	void OnRep_QuantityData();
	void ServerRequestUse();
	void SetVisible(bool bNewVisibilityState);

	bool CanBeUsed() const;
	EItemFlags GetFlags() const;
	class UTexture2D* GetItemIcon() const;
	class FString GetItemIdentifier() const;
	class FString GetItemName() const;
	const TSubclassOf<class AItemPickup> GetItemPickupClass() const;
	class ANGDCharacter* GetOwnerCharacter() const;
	class UInventoryComponent* GetOwnerInventory() const;
	int32 GetQuantity() const;
	int32 GetRemainingStackQuantity() const;
	float GetWeight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item">();
	}
	static class AItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem>();
	}
};
static_assert(alignof(AItem) == 0x000008, "Wrong alignment on AItem");
static_assert(sizeof(AItem) == 0x0002B0, "Wrong size on AItem");
static_assert(offsetof(AItem, ItemIdentifier) == 0x000230, "Member 'AItem::ItemIdentifier' has a wrong offset!");
static_assert(offsetof(AItem, ItemName) == 0x000240, "Member 'AItem::ItemName' has a wrong offset!");
static_assert(offsetof(AItem, ItemIcon) == 0x000258, "Member 'AItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(AItem, VisibleWhenAdquired) == 0x000260, "Member 'AItem::VisibleWhenAdquired' has a wrong offset!");
static_assert(offsetof(AItem, CanBeStored) == 0x000261, "Member 'AItem::CanBeStored' has a wrong offset!");
static_assert(offsetof(AItem, Weight) == 0x000264, "Member 'AItem::Weight' has a wrong offset!");
static_assert(offsetof(AItem, MaxStack) == 0x000268, "Member 'AItem::MaxStack' has a wrong offset!");
static_assert(offsetof(AItem, ItemPickupClass) == 0x000270, "Member 'AItem::ItemPickupClass' has a wrong offset!");
static_assert(offsetof(AItem, Quantity) == 0x000278, "Member 'AItem::Quantity' has a wrong offset!");
static_assert(offsetof(AItem, Flags_0) == 0x00027C, "Member 'AItem::Flags_0' has a wrong offset!");
static_assert(offsetof(AItem, InventoryData) == 0x000280, "Member 'AItem::InventoryData' has a wrong offset!");
static_assert(offsetof(AItem, LocalInventoryData) == 0x000290, "Member 'AItem::LocalInventoryData' has a wrong offset!");
static_assert(offsetof(AItem, ItemRoot) == 0x0002A0, "Member 'AItem::ItemRoot' has a wrong offset!");
static_assert(offsetof(AItem, bIsTransferable) == 0x0002A8, "Member 'AItem::bIsTransferable' has a wrong offset!");
static_assert(offsetof(AItem, bIsDefaultItem) == 0x0002A9, "Member 'AItem::bIsDefaultItem' has a wrong offset!");

// Class UnrealProject.Ammunition
// 0x0000 (0x02B0 - 0x02B0)
class AAmmunition final : public AItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ammunition">();
	}
	static class AAmmunition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmmunition>();
	}
};
static_assert(alignof(AAmmunition) == 0x000008, "Wrong alignment on AAmmunition");
static_assert(sizeof(AAmmunition) == 0x0002B0, "Wrong size on AAmmunition");

// Class UnrealProject.NGDAnimInstance
// 0x0000 (0x0270 - 0x0270)
#pragma pack(push, 0x1)
class alignas(0x10) UNGDAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDAnimInstance">();
	}
	static class UNGDAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNGDAnimInstance) == 0x000010, "Wrong alignment on UNGDAnimInstance");
static_assert(sizeof(UNGDAnimInstance) == 0x000270, "Wrong size on UNGDAnimInstance");

// Class UnrealProject.NGDCameraModifier
// 0x0050 (0x0098 - 0x0048)
class UNGDCameraModifier : public UCameraModifier
{
public:
	struct FPostProcess                           ModifierSettings;                                  // 0x0048(0x0048)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCustomParameterModifier(class FName ParameterName, float InBaseValue, float* OutBaseValue);
	bool BlueprintIsModifierActive();
	void BlueprintOverrideAlpha(float* OutNewAlpha);

	float GetRelativeTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDCameraModifier">();
	}
	static class UNGDCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDCameraModifier>();
	}
};
static_assert(alignof(UNGDCameraModifier) == 0x000008, "Wrong alignment on UNGDCameraModifier");
static_assert(sizeof(UNGDCameraModifier) == 0x000098, "Wrong size on UNGDCameraModifier");
static_assert(offsetof(UNGDCameraModifier, ModifierSettings) == 0x000048, "Member 'UNGDCameraModifier::ModifierSettings' has a wrong offset!");

// Class UnrealProject.Equipment
// 0x0038 (0x02E8 - 0x02B0)
class AEquipment : public AItem
{
public:
	class UNGDAttachmentContainerComponent*       AttachmentContainer;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SlotType;                                          // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapacityBoost;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldListenToADSChange;                          // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEquipped;                                       // 0x02CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CE[0x1];                                      // 0x02CE(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsConsumable;                                     // 0x02CF(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         MeshTP;                                            // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Consume();
	class UNGDAttachmentContainerComponent* GetAttachmentContainer();
	void OnEquipped();
	void OnUnequipped();

	class FName GetBodyAttachSocket() const;
	class UMeshComponent* GetMeshTP() const;
	int32 GetSlotIndex() const;
	class FString GetSlotType() const;
	bool IsConsumable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Equipment">();
	}
	static class AEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEquipment>();
	}
};
static_assert(alignof(AEquipment) == 0x000008, "Wrong alignment on AEquipment");
static_assert(sizeof(AEquipment) == 0x0002E8, "Wrong size on AEquipment");
static_assert(offsetof(AEquipment, AttachmentContainer) == 0x0002B0, "Member 'AEquipment::AttachmentContainer' has a wrong offset!");
static_assert(offsetof(AEquipment, SlotType) == 0x0002B8, "Member 'AEquipment::SlotType' has a wrong offset!");
static_assert(offsetof(AEquipment, CapacityBoost) == 0x0002C8, "Member 'AEquipment::CapacityBoost' has a wrong offset!");
static_assert(offsetof(AEquipment, bShouldListenToADSChange) == 0x0002CC, "Member 'AEquipment::bShouldListenToADSChange' has a wrong offset!");
static_assert(offsetof(AEquipment, bIsEquipped) == 0x0002CD, "Member 'AEquipment::bIsEquipped' has a wrong offset!");
static_assert(offsetof(AEquipment, bIsConsumable) == 0x0002CF, "Member 'AEquipment::bIsConsumable' has a wrong offset!");
static_assert(offsetof(AEquipment, MeshTP) == 0x0002E0, "Member 'AEquipment::MeshTP' has a wrong offset!");

// Class UnrealProject.Action
// 0x0038 (0x0060 - 0x0028)
class UAction : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnActionBegin;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float DeltaTime)> OnActionUpdate;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnActionFinish;                                    // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          Finished;                                          // 0x0058(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActionBegan;                                       // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAction* CreateActionOfClass(const struct FActionParams& ActionParams, TSubclassOf<class UAction> ActionClass);

	void BroadcastBeginAction();
	void BroadcastFinishAction();
	void BroadcastUpdateAction(float Delta);
	void DestroyAction();
	void Initialize(const struct FActionParams& ActionParams);
	void Update(float Delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Action">();
	}
	static class UAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAction>();
	}
};
static_assert(alignof(UAction) == 0x000008, "Wrong alignment on UAction");
static_assert(sizeof(UAction) == 0x000060, "Wrong size on UAction");
static_assert(offsetof(UAction, OnActionBegin) == 0x000028, "Member 'UAction::OnActionBegin' has a wrong offset!");
static_assert(offsetof(UAction, OnActionUpdate) == 0x000038, "Member 'UAction::OnActionUpdate' has a wrong offset!");
static_assert(offsetof(UAction, OnActionFinish) == 0x000048, "Member 'UAction::OnActionFinish' has a wrong offset!");
static_assert(offsetof(UAction, Finished) == 0x000058, "Member 'UAction::Finished' has a wrong offset!");
static_assert(offsetof(UAction, ActionBegan) == 0x000059, "Member 'UAction::ActionBegan' has a wrong offset!");

// Class UnrealProject.StartAimingAction
// 0x0028 (0x0088 - 0x0060)
class UStartAimingAction final : public UAction
{
public:
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTargetLocation;                                 // 0x0068(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AimTargetActor;                                    // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimDurationLimit;                                  // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EventUpdate(float Delta);
	void Initialize_Implementation(const struct FActionParams& ActionParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartAimingAction">();
	}
	static class UStartAimingAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartAimingAction>();
	}
};
static_assert(alignof(UStartAimingAction) == 0x000008, "Wrong alignment on UStartAimingAction");
static_assert(sizeof(UStartAimingAction) == 0x000088, "Wrong size on UStartAimingAction");
static_assert(offsetof(UStartAimingAction, PlayTestComp) == 0x000060, "Member 'UStartAimingAction::PlayTestComp' has a wrong offset!");
static_assert(offsetof(UStartAimingAction, AimTargetLocation) == 0x000068, "Member 'UStartAimingAction::AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UStartAimingAction, AimTargetActor) == 0x000078, "Member 'UStartAimingAction::AimTargetActor' has a wrong offset!");
static_assert(offsetof(UStartAimingAction, Timer) == 0x000080, "Member 'UStartAimingAction::Timer' has a wrong offset!");
static_assert(offsetof(UStartAimingAction, AimDurationLimit) == 0x000084, "Member 'UStartAimingAction::AimDurationLimit' has a wrong offset!");

// Class UnrealProject.Armor
// 0x0058 (0x0340 - 0x02E8)
class AArmor final : public AEquipment
{
public:
	float                                         MaxDurability;                                     // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Durability;                                        // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UNGDBodyPart>, float>  AffectedBodyParts;                                 // 0x02F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void Equip();
	void OnRep_Durability();
	void Unequip();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Armor">();
	}
	static class AArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArmor>();
	}
};
static_assert(alignof(AArmor) == 0x000008, "Wrong alignment on AArmor");
static_assert(sizeof(AArmor) == 0x000340, "Wrong size on AArmor");
static_assert(offsetof(AArmor, MaxDurability) == 0x0002E8, "Member 'AArmor::MaxDurability' has a wrong offset!");
static_assert(offsetof(AArmor, Durability) == 0x0002EC, "Member 'AArmor::Durability' has a wrong offset!");
static_assert(offsetof(AArmor, AffectedBodyParts) == 0x0002F0, "Member 'AArmor::AffectedBodyParts' has a wrong offset!");

// Class UnrealProject.NGDAkComponent
// 0x0010 (0x03E0 - 0x03D0)
class UNGDAkComponent : public UAkComponent
{
public:
	bool                                          bPlayAKEventOnBeginPlay;                           // 0x03D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProvideIsPlayer;                                  // 0x03D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProvideTimeDilation;                              // 0x03D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D3[0x5];                                      // 0x03D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ContextActor;                                      // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 Play(class AActor* InContextActor, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& Callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDAkComponent">();
	}
	static class UNGDAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDAkComponent>();
	}
};
static_assert(alignof(UNGDAkComponent) == 0x000010, "Wrong alignment on UNGDAkComponent");
static_assert(sizeof(UNGDAkComponent) == 0x0003E0, "Wrong size on UNGDAkComponent");
static_assert(offsetof(UNGDAkComponent, bPlayAKEventOnBeginPlay) == 0x0003D0, "Member 'UNGDAkComponent::bPlayAKEventOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UNGDAkComponent, bProvideIsPlayer) == 0x0003D1, "Member 'UNGDAkComponent::bProvideIsPlayer' has a wrong offset!");
static_assert(offsetof(UNGDAkComponent, bProvideTimeDilation) == 0x0003D2, "Member 'UNGDAkComponent::bProvideTimeDilation' has a wrong offset!");
static_assert(offsetof(UNGDAkComponent, ContextActor) == 0x0003D8, "Member 'UNGDAkComponent::ContextActor' has a wrong offset!");

// Class UnrealProject.Attachment
// 0x00E0 (0x0390 - 0x02B0)
class AAttachment : public AItem
{
public:
	TArray<TSubclassOf<class AActor>>             AttachedByClasses;                                 // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotType;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachSocket;                                      // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x02E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bVisibleWhenDetached;                              // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DefaultStaticMesh;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AActor>, class UStaticMesh*> Meshes;                                      // 0x0320(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAttachmentReplicationData             ReplicationData;                                   // 0x0370(0x0010)(Net, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAttachmentReplicationData             LocalReplicationData;                              // 0x0380(0x0010)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnRep_ReplicationData();

	bool IsAttached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Attachment">();
	}
	static class AAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAttachment>();
	}
};
static_assert(alignof(AAttachment) == 0x000010, "Wrong alignment on AAttachment");
static_assert(sizeof(AAttachment) == 0x000390, "Wrong size on AAttachment");
static_assert(offsetof(AAttachment, AttachedByClasses) == 0x0002B0, "Member 'AAttachment::AttachedByClasses' has a wrong offset!");
static_assert(offsetof(AAttachment, StaticMeshComponent) == 0x0002C0, "Member 'AAttachment::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AAttachment, SlotType) == 0x0002C8, "Member 'AAttachment::SlotType' has a wrong offset!");
static_assert(offsetof(AAttachment, AttachSocket) == 0x0002D0, "Member 'AAttachment::AttachSocket' has a wrong offset!");
static_assert(offsetof(AAttachment, RelativeTransform) == 0x0002E0, "Member 'AAttachment::RelativeTransform' has a wrong offset!");
static_assert(offsetof(AAttachment, bVisibleWhenDetached) == 0x000310, "Member 'AAttachment::bVisibleWhenDetached' has a wrong offset!");
static_assert(offsetof(AAttachment, DefaultStaticMesh) == 0x000318, "Member 'AAttachment::DefaultStaticMesh' has a wrong offset!");
static_assert(offsetof(AAttachment, Meshes) == 0x000320, "Member 'AAttachment::Meshes' has a wrong offset!");
static_assert(offsetof(AAttachment, ReplicationData) == 0x000370, "Member 'AAttachment::ReplicationData' has a wrong offset!");
static_assert(offsetof(AAttachment, LocalReplicationData) == 0x000380, "Member 'AAttachment::LocalReplicationData' has a wrong offset!");

// Class UnrealProject.PlayTestComponent
// 0x01B8 (0x0268 - 0x00B0)
class UPlayTestComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0xB0];                                      // 0x00B0(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class ANGDCharacter*                          Character;                                         // 0x0160(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Controller;                                        // 0x0168(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANGDPlayerController*                   PlayerController;                                  // 0x0170(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCompositeAction*                       RootAction;                                        // 0x0178(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeapon*                                CurrentWeapon;                                     // 0x0180(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryComponent*                    InventoryComponent;                                // 0x0188(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNGDInteractionComponent*               InteractionComponent;                              // 0x0190(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFindingItems;                                   // 0x0198(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0xF];                                      // 0x0199(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimTarget;                                         // 0x01A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AimTargetActor;                                    // 0x01B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              TeleportCase;                                      // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x18];                                     // 0x01D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        PathPoints;                                        // 0x01E8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANGDCharacter*>                  Enemies;                                           // 0x0210(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AWeapon*>                        Weapons;                                           // 0x0220(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AAmmunition*>                    Ammo;                                              // 0x0230(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsAiming;                                         // 0x0240(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x13];                                     // 0x0241(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FinalLocation;                                     // 0x0254(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPathIsPartial;                                    // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetOnSight;                                    // 0x0261(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262[0x6];                                      // 0x0262(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Aim(const struct FVector& AimToLocation, float DeltaTime);
	bool CheckLineOfSight(class AActor* OtherActor);
	void ClientTeleportBroadcast();
	void CrashTest(const class FString& CrashMessage);
	void FinishPlayTest();
	class ANGDCharacter* GetClosestEnemy();
	struct FVector ProjectPointToRandomReachableNavMesh(const struct FVector& PointToProject, float RandomRadius);
	void RefreshActions();
	void ResetPlayTest();
	void ServerTeleportPlayerToNavMeshLocation(const struct FVector& Destination);
	void ServerTeleportPlayerToRandomNavMeshLocation();
	void SetNewMoveDestination(const struct FVector& LocationToGo);
	void SetRandomMoveLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayTestComponent">();
	}
	static class UPlayTestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayTestComponent>();
	}
};
static_assert(alignof(UPlayTestComponent) == 0x000008, "Wrong alignment on UPlayTestComponent");
static_assert(sizeof(UPlayTestComponent) == 0x000268, "Wrong size on UPlayTestComponent");
static_assert(offsetof(UPlayTestComponent, Character) == 0x000160, "Member 'UPlayTestComponent::Character' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, Controller) == 0x000168, "Member 'UPlayTestComponent::Controller' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, PlayerController) == 0x000170, "Member 'UPlayTestComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, RootAction) == 0x000178, "Member 'UPlayTestComponent::RootAction' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, CurrentWeapon) == 0x000180, "Member 'UPlayTestComponent::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, InventoryComponent) == 0x000188, "Member 'UPlayTestComponent::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, InteractionComponent) == 0x000190, "Member 'UPlayTestComponent::InteractionComponent' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, bIsFindingItems) == 0x000198, "Member 'UPlayTestComponent::bIsFindingItems' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, AimTarget) == 0x0001A8, "Member 'UPlayTestComponent::AimTarget' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, AimTargetActor) == 0x0001B8, "Member 'UPlayTestComponent::AimTargetActor' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, TeleportCase) == 0x0001C0, "Member 'UPlayTestComponent::TeleportCase' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, PathPoints) == 0x0001E8, "Member 'UPlayTestComponent::PathPoints' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, Enemies) == 0x000210, "Member 'UPlayTestComponent::Enemies' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, Weapons) == 0x000220, "Member 'UPlayTestComponent::Weapons' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, Ammo) == 0x000230, "Member 'UPlayTestComponent::Ammo' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, bIsAiming) == 0x000240, "Member 'UPlayTestComponent::bIsAiming' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, FinalLocation) == 0x000254, "Member 'UPlayTestComponent::FinalLocation' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, bPathIsPartial) == 0x000260, "Member 'UPlayTestComponent::bPathIsPartial' has a wrong offset!");
static_assert(offsetof(UPlayTestComponent, bTargetOnSight) == 0x000261, "Member 'UPlayTestComponent::bTargetOnSight' has a wrong offset!");

// Class UnrealProject.BarObject
// 0x0008 (0x0030 - 0x0028)
class UBarObject final : public UObject
{
public:
	class UBarWidget*                             BarWidget;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarObject">();
	}
	static class UBarObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarObject>();
	}
};
static_assert(alignof(UBarObject) == 0x000008, "Wrong alignment on UBarObject");
static_assert(sizeof(UBarObject) == 0x000030, "Wrong size on UBarObject");
static_assert(offsetof(UBarObject, BarWidget) == 0x000028, "Member 'UBarObject::BarWidget' has a wrong offset!");

// Class UnrealProject.BarsManager
// 0x0020 (0x0048 - 0x0028)
class UBarsManager final : public UObject
{
public:
	TArray<class UBarObject*>                     BarsCreated;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBarObject* AddBar(class UObject* InContext, const TArray<struct FFloatValueToShow>& FloatsToShow, const struct FVector2D& Position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarsManager">();
	}
	static class UBarsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarsManager>();
	}
};
static_assert(alignof(UBarsManager) == 0x000008, "Wrong alignment on UBarsManager");
static_assert(sizeof(UBarsManager) == 0x000048, "Wrong size on UBarsManager");
static_assert(offsetof(UBarsManager, BarsCreated) == 0x000028, "Member 'UBarsManager::BarsCreated' has a wrong offset!");

// Class UnrealProject.ThrowableProjectile
// 0x0068 (0x0298 - 0x0230)
class AThrowableProjectile final : public ABaseActor
{
public:
	class USphereComponent*                       CollisionComp;                                     // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           ProjectileMovementComp;                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     SpawnActorOnTimerEnd;                              // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Timer;                                             // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDRadialDamageConfig                 ExplosionConfig;                                   // 0x0250(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ImpactImpulse;                                     // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AngularImpulse;                                    // 0x0284(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            InstigatorContorller;                              // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyRadialDamage();
	void InitializeExplosion();
	void OnTimerExpired();
	void ProjectileOnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SetInstigator(class AController* InInstigator);
	void SpawnExplosionActor();
	class AWeapon* TryGetOwnerWeapon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowableProjectile">();
	}
	static class AThrowableProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrowableProjectile>();
	}
};
static_assert(alignof(AThrowableProjectile) == 0x000008, "Wrong alignment on AThrowableProjectile");
static_assert(sizeof(AThrowableProjectile) == 0x000298, "Wrong size on AThrowableProjectile");
static_assert(offsetof(AThrowableProjectile, CollisionComp) == 0x000230, "Member 'AThrowableProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AThrowableProjectile, ProjectileMovementComp) == 0x000238, "Member 'AThrowableProjectile::ProjectileMovementComp' has a wrong offset!");
static_assert(offsetof(AThrowableProjectile, SpawnActorOnTimerEnd) == 0x000240, "Member 'AThrowableProjectile::SpawnActorOnTimerEnd' has a wrong offset!");
static_assert(offsetof(AThrowableProjectile, Timer) == 0x000248, "Member 'AThrowableProjectile::Timer' has a wrong offset!");
static_assert(offsetof(AThrowableProjectile, ExplosionConfig) == 0x000250, "Member 'AThrowableProjectile::ExplosionConfig' has a wrong offset!");
static_assert(offsetof(AThrowableProjectile, ImpactImpulse) == 0x000280, "Member 'AThrowableProjectile::ImpactImpulse' has a wrong offset!");
static_assert(offsetof(AThrowableProjectile, AngularImpulse) == 0x000284, "Member 'AThrowableProjectile::AngularImpulse' has a wrong offset!");
static_assert(offsetof(AThrowableProjectile, InstigatorContorller) == 0x000290, "Member 'AThrowableProjectile::InstigatorContorller' has a wrong offset!");

// Class UnrealProject.BarWidget
// 0x0098 (0x02C8 - 0x0230)
class UBarWidget final : public UUserWidget
{
public:
	TArray<struct FFloatValueToShow>              OutValues;                                         // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              InitialPosition;                                   // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InitialSize;                                       // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MyCanvas;                                          // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x10];                                     // 0x0258(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImage*>                         Images;                                            // 0x0268(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UTextBlock*>                     Titles;                                            // 0x0278(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UCanvasPanelSlot*>               TitlesCanvasSlot;                                  // 0x0288(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         DrawRectImages;                                    // 0x0298(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UCanvasPanelSlot*>               FillImagesCanvasSlot;                              // 0x02A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UCanvasPanelSlot*>               RectImagesCanvasSlot;                              // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarWidget">();
	}
	static class UBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarWidget>();
	}
};
static_assert(alignof(UBarWidget) == 0x000008, "Wrong alignment on UBarWidget");
static_assert(sizeof(UBarWidget) == 0x0002C8, "Wrong size on UBarWidget");
static_assert(offsetof(UBarWidget, OutValues) == 0x000230, "Member 'UBarWidget::OutValues' has a wrong offset!");
static_assert(offsetof(UBarWidget, InitialPosition) == 0x000240, "Member 'UBarWidget::InitialPosition' has a wrong offset!");
static_assert(offsetof(UBarWidget, InitialSize) == 0x000248, "Member 'UBarWidget::InitialSize' has a wrong offset!");
static_assert(offsetof(UBarWidget, MyCanvas) == 0x000250, "Member 'UBarWidget::MyCanvas' has a wrong offset!");
static_assert(offsetof(UBarWidget, Images) == 0x000268, "Member 'UBarWidget::Images' has a wrong offset!");
static_assert(offsetof(UBarWidget, Titles) == 0x000278, "Member 'UBarWidget::Titles' has a wrong offset!");
static_assert(offsetof(UBarWidget, TitlesCanvasSlot) == 0x000288, "Member 'UBarWidget::TitlesCanvasSlot' has a wrong offset!");
static_assert(offsetof(UBarWidget, DrawRectImages) == 0x000298, "Member 'UBarWidget::DrawRectImages' has a wrong offset!");
static_assert(offsetof(UBarWidget, FillImagesCanvasSlot) == 0x0002A8, "Member 'UBarWidget::FillImagesCanvasSlot' has a wrong offset!");
static_assert(offsetof(UBarWidget, RectImagesCanvasSlot) == 0x0002B8, "Member 'UBarWidget::RectImagesCanvasSlot' has a wrong offset!");

// Class UnrealProject.NGDAttachmentContainerComponent
// 0x0010 (0x00C0 - 0x00B0)
class UNGDAttachmentContainerComponent final : public UActorComponent
{
public:
	TArray<struct FAttachmentSlot>                AttachmentSlots;                                   // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void ServerAttachToSlot(class AAttachment* InAttachment, const int32 SlotIndex);
	void ServerAutoAttach(class AAttachment* InAttachment);
	void ServerDetach(class AAttachment* InAttachment);
	void ServerDetachAll();

	bool CanBeAttached(class AAttachment* Attachment) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDAttachmentContainerComponent">();
	}
	static class UNGDAttachmentContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDAttachmentContainerComponent>();
	}
};
static_assert(alignof(UNGDAttachmentContainerComponent) == 0x000008, "Wrong alignment on UNGDAttachmentContainerComponent");
static_assert(sizeof(UNGDAttachmentContainerComponent) == 0x0000C0, "Wrong size on UNGDAttachmentContainerComponent");
static_assert(offsetof(UNGDAttachmentContainerComponent, AttachmentSlots) == 0x0000B0, "Member 'UNGDAttachmentContainerComponent::AttachmentSlots' has a wrong offset!");

// Class UnrealProject.BaseFirearmFeelComponent
// 0x0088 (0x0138 - 0x00B0)
class UBaseFirearmFeelComponent : public UActorComponent
{
public:
	bool                                          Enabled;                                           // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x00B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDebugComposed;                               // 0x00B2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x1];                                       // 0x00B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugScale;                                        // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 DebugScales;                                       // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFirearmFeelCharacterModifiers         CharacterModifiers;                                // 0x00D8(0x0028)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CharacterModifierLerpTime;                         // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCharacterModifierLerpTime;                  // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCharacterModifier;                          // 0x0108(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WantedCharacterModifier;                           // 0x010C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterModifierTimer;                            // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFirearmFeelModifiers                  Modifiers;                                         // 0x0114(0x000C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Scale;                                             // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 InitialState;                                      // 0x0128(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseFirearmFeelComponent">();
	}
	static class UBaseFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseFirearmFeelComponent>();
	}
};
static_assert(alignof(UBaseFirearmFeelComponent) == 0x000008, "Wrong alignment on UBaseFirearmFeelComponent");
static_assert(sizeof(UBaseFirearmFeelComponent) == 0x000138, "Wrong size on UBaseFirearmFeelComponent");
static_assert(offsetof(UBaseFirearmFeelComponent, Enabled) == 0x0000B0, "Member 'UBaseFirearmFeelComponent::Enabled' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, bDebug) == 0x0000B1, "Member 'UBaseFirearmFeelComponent::bDebug' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, bForceDebugComposed) == 0x0000B2, "Member 'UBaseFirearmFeelComponent::bForceDebugComposed' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, DebugScale) == 0x0000B4, "Member 'UBaseFirearmFeelComponent::DebugScale' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, DebugScales) == 0x0000B8, "Member 'UBaseFirearmFeelComponent::DebugScales' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, CharacterModifiers) == 0x0000D8, "Member 'UBaseFirearmFeelComponent::CharacterModifiers' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, CharacterModifierLerpTime) == 0x000100, "Member 'UBaseFirearmFeelComponent::CharacterModifierLerpTime' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, CurrentCharacterModifierLerpTime) == 0x000104, "Member 'UBaseFirearmFeelComponent::CurrentCharacterModifierLerpTime' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, CurrentCharacterModifier) == 0x000108, "Member 'UBaseFirearmFeelComponent::CurrentCharacterModifier' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, WantedCharacterModifier) == 0x00010C, "Member 'UBaseFirearmFeelComponent::WantedCharacterModifier' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, CharacterModifierTimer) == 0x000110, "Member 'UBaseFirearmFeelComponent::CharacterModifierTimer' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, Modifiers) == 0x000114, "Member 'UBaseFirearmFeelComponent::Modifiers' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, Scale) == 0x000120, "Member 'UBaseFirearmFeelComponent::Scale' has a wrong offset!");
static_assert(offsetof(UBaseFirearmFeelComponent, InitialState) == 0x000128, "Member 'UBaseFirearmFeelComponent::InitialState' has a wrong offset!");

// Class UnrealProject.NGDWheeledVehicle
// 0x0130 (0x03B8 - 0x0288)
class ANGDWheeledVehicle : public AWheeledVehicle
{
public:
	uint8                                         Pad_288[0x20];                                     // 0x0288(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentFuel;                                       // 0x02A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FuelCapacity;                                      // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FuelConsumption;                                   // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AffectedSocket;                                    // 0x02B4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Impulse;                                           // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinVelocityThresholdToRunOver;                     // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          InteractionBox;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          RunOverBox;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SimpleShapeBox;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDPostUpdateWorkComponent*            PostUpdateWorkComponent;                           // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      RewindCollider;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HitRegistrationCollider;                           // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        UnboardContainer;                                  // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDVehicleComponent*                   VehicleComponent;                                  // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDRewindComponent*                    RewindComponent;                                   // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDMortalityComponent*                 MortalityComponent;                                // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        DeathVFX;                                          // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        DeathSound;                                        // 0x0320(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDRadialDamageConfig                 ExplosionConfig;                                   // 0x0378(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AController*                            InstigatorKiller;                                  // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DamageCauserKiller;                                // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyRadialDamage();
	void MulticastOnDeath();
	void OnDeath(const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void OnPostUpdateWork();
	void OnRunOverBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSimpleCollisionHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	float OnTakeDamage(float Damage, const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void ServerNotifyLocalRunOverEvent(class ANGDCharacter* Victim);
	void ServerRequestDriverUnBoardContract();

	class UCapsuleComponent* GetHitRegistrationCollider() const;
	class UNGDMortalityComponent* GetMortalityComponent() const;
	class UMeshComponent* GetRewindableMeshComponent() const;
	class UCapsuleComponent* GetRewindCollider() const;
	class UNGDRewindComponent* GetRewindComponent() const;
	bool IsRewindRelevant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDWheeledVehicle">();
	}
	static class ANGDWheeledVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDWheeledVehicle>();
	}
};
static_assert(alignof(ANGDWheeledVehicle) == 0x000008, "Wrong alignment on ANGDWheeledVehicle");
static_assert(sizeof(ANGDWheeledVehicle) == 0x0003B8, "Wrong size on ANGDWheeledVehicle");
static_assert(offsetof(ANGDWheeledVehicle, CurrentFuel) == 0x0002A8, "Member 'ANGDWheeledVehicle::CurrentFuel' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, FuelCapacity) == 0x0002AC, "Member 'ANGDWheeledVehicle::FuelCapacity' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, FuelConsumption) == 0x0002B0, "Member 'ANGDWheeledVehicle::FuelConsumption' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, AffectedSocket) == 0x0002B4, "Member 'ANGDWheeledVehicle::AffectedSocket' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, Impulse) == 0x0002BC, "Member 'ANGDWheeledVehicle::Impulse' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, MinVelocityThresholdToRunOver) == 0x0002C0, "Member 'ANGDWheeledVehicle::MinVelocityThresholdToRunOver' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, InteractionBox) == 0x0002C8, "Member 'ANGDWheeledVehicle::InteractionBox' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, RunOverBox) == 0x0002D0, "Member 'ANGDWheeledVehicle::RunOverBox' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, SimpleShapeBox) == 0x0002D8, "Member 'ANGDWheeledVehicle::SimpleShapeBox' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, PostUpdateWorkComponent) == 0x0002E0, "Member 'ANGDWheeledVehicle::PostUpdateWorkComponent' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, RewindCollider) == 0x0002E8, "Member 'ANGDWheeledVehicle::RewindCollider' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, HitRegistrationCollider) == 0x0002F0, "Member 'ANGDWheeledVehicle::HitRegistrationCollider' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, UnboardContainer) == 0x0002F8, "Member 'ANGDWheeledVehicle::UnboardContainer' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, VehicleComponent) == 0x000300, "Member 'ANGDWheeledVehicle::VehicleComponent' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, RewindComponent) == 0x000308, "Member 'ANGDWheeledVehicle::RewindComponent' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, MortalityComponent) == 0x000310, "Member 'ANGDWheeledVehicle::MortalityComponent' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, DeathVFX) == 0x000318, "Member 'ANGDWheeledVehicle::DeathVFX' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, DeathSound) == 0x000320, "Member 'ANGDWheeledVehicle::DeathSound' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, ExplosionConfig) == 0x000378, "Member 'ANGDWheeledVehicle::ExplosionConfig' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, InstigatorKiller) == 0x0003A8, "Member 'ANGDWheeledVehicle::InstigatorKiller' has a wrong offset!");
static_assert(offsetof(ANGDWheeledVehicle, DamageCauserKiller) == 0x0003B0, "Member 'ANGDWheeledVehicle::DamageCauserKiller' has a wrong offset!");

// Class UnrealProject.NGDRewindable
// 0x0000 (0x0000 - 0x0000)
class INGDRewindable final
{
public:
	class UCapsuleComponent* GetHitRegistrationCollider() const;
	class UMeshComponent* GetRewindableMeshComponent() const;
	class UCapsuleComponent* GetRewindCollider() const;
	class UNGDRewindComponent* GetRewindComponent() const;
	bool IsRewindRelevant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDRewindable">();
	}
	static class INGDRewindable* GetDefaultObj()
	{
		return GetDefaultObjImpl<INGDRewindable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INGDRewindable) == 0x000001, "Wrong alignment on INGDRewindable");
static_assert(sizeof(INGDRewindable) == 0x000001, "Wrong size on INGDRewindable");

// Class UnrealProject.BaseObject
// 0x0000 (0x0028 - 0x0028)
class UBaseObject final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseObject">();
	}
	static class UBaseObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseObject>();
	}
};
static_assert(alignof(UBaseObject) == 0x000008, "Wrong alignment on UBaseObject");
static_assert(sizeof(UBaseObject) == 0x000028, "Wrong size on UBaseObject");

// Class UnrealProject.BaseProjectile
// 0x0138 (0x0368 - 0x0230)
class ABaseProjectile : public ABaseActor
{
public:
	bool                                          bRotationFollowsVelocity;                          // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDSoundConfig                        WhizzSound;                                        // 0x0238(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        CrackSound;                                        // 0x0290(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UNGDPhysicalMaterial*                   DefaultImpactMaterial;                             // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBaseProjectileComponent*               MovementComponent;                                 // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       Collision;                                         // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTravelDistance;                                 // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x8];                                      // 0x030C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnedLocation;                                   // 0x0314(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotifyImpactToServer;                             // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ColliderIncrementAgainstActors;                    // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ColliderIncrementAgainstActors_Local;              // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x10];                                     // 0x032C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnedVelocity;                                   // 0x033C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviousLocation;                                  // 0x0348(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x14];                                     // 0x0354(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Native_CosmeticOnProjectileMove();
	void Native_CosmeticsOnImpact(const struct FHitResult& HitResult);
	void OnImpactEvent(const struct FHitResult& HitResult);

	int32 GetAmmoIndex() const;
	class ANGDCharacter* GetOwnerCharacter() const;
	class AWeapon* GetOwnerWeapon() const;
	float GetTimeToLive() const;
	float GetTravelDistance() const;
	bool IsLocallyPredicted() const;
	bool IsSupersonic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProjectile">();
	}
	static class ABaseProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseProjectile>();
	}
};
static_assert(alignof(ABaseProjectile) == 0x000008, "Wrong alignment on ABaseProjectile");
static_assert(sizeof(ABaseProjectile) == 0x000368, "Wrong size on ABaseProjectile");
static_assert(offsetof(ABaseProjectile, bRotationFollowsVelocity) == 0x000230, "Member 'ABaseProjectile::bRotationFollowsVelocity' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, WhizzSound) == 0x000238, "Member 'ABaseProjectile::WhizzSound' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, CrackSound) == 0x000290, "Member 'ABaseProjectile::CrackSound' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, DefaultImpactMaterial) == 0x0002E8, "Member 'ABaseProjectile::DefaultImpactMaterial' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, MovementComponent) == 0x0002F0, "Member 'ABaseProjectile::MovementComponent' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, Collision) == 0x0002F8, "Member 'ABaseProjectile::Collision' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, GravityScale) == 0x000300, "Member 'ABaseProjectile::GravityScale' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, Drag) == 0x000304, "Member 'ABaseProjectile::Drag' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, MaxTravelDistance) == 0x000308, "Member 'ABaseProjectile::MaxTravelDistance' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, SpawnedLocation) == 0x000314, "Member 'ABaseProjectile::SpawnedLocation' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, bNotifyImpactToServer) == 0x000320, "Member 'ABaseProjectile::bNotifyImpactToServer' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, ColliderIncrementAgainstActors) == 0x000324, "Member 'ABaseProjectile::ColliderIncrementAgainstActors' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, ColliderIncrementAgainstActors_Local) == 0x000328, "Member 'ABaseProjectile::ColliderIncrementAgainstActors_Local' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, SpawnedVelocity) == 0x00033C, "Member 'ABaseProjectile::SpawnedVelocity' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, PreviousLocation) == 0x000348, "Member 'ABaseProjectile::PreviousLocation' has a wrong offset!");

// Class UnrealProject.NGDCameraComponent
// 0x0050 (0x07F0 - 0x07A0)
class UNGDCameraComponent : public UCameraComponent
{
public:
	ECameraTypes                                  CameraID;                                          // 0x07A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A1[0xF];                                      // 0x07A1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraConfig                          CameraConfig;                                      // 0x07B0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDCameraComponent">();
	}
	static class UNGDCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDCameraComponent>();
	}
};
static_assert(alignof(UNGDCameraComponent) == 0x000010, "Wrong alignment on UNGDCameraComponent");
static_assert(sizeof(UNGDCameraComponent) == 0x0007F0, "Wrong size on UNGDCameraComponent");
static_assert(offsetof(UNGDCameraComponent, CameraID) == 0x0007A0, "Member 'UNGDCameraComponent::CameraID' has a wrong offset!");
static_assert(offsetof(UNGDCameraComponent, CameraConfig) == 0x0007B0, "Member 'UNGDCameraComponent::CameraConfig' has a wrong offset!");

// Class UnrealProject.BaseProjectileComponent
// 0x0000 (0x01D0 - 0x01D0)
class UBaseProjectileComponent : public UProjectileMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProjectileComponent">();
	}
	static class UBaseProjectileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseProjectileComponent>();
	}
};
static_assert(alignof(UBaseProjectileComponent) == 0x000010, "Wrong alignment on UBaseProjectileComponent");
static_assert(sizeof(UBaseProjectileComponent) == 0x0001D0, "Wrong size on UBaseProjectileComponent");

// Class UnrealProject.SprayPatternFirearmFeelComponent
// 0x00D8 (0x0210 - 0x0138)
class USprayPatternFirearmFeelComponent final : public UBaseFirearmFeelComponent
{
public:
	bool                                          bDebugSprayPattern2D;                              // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      PatternPoints;                                     // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         ProjectionDistance;                                // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PatternScale;                                      // 0x0154(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PatternScaleModifier_Focusing;                     // 0x015C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraModifierScalar;                              // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableCurve                         FireDirAmplitudeCurve;                             // 0x0168(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         GainRecoveryCooldownFactor;                        // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GainRecoveryFactor;                                // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRecoveryConsumableByPlayerInput;                // 0x0188(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CatchupInterpolation;                              // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CatchupFactor;                                     // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoverInterpolation;                              // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RecoveryTime;                                      // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CrosshairAmplitudScalar;                           // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CrosshairSpreadSpeed;                              // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairShrinkScalar;                             // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Gained;                                            // 0x01C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C8[0x48];                                     // 0x01C8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprayPatternFirearmFeelComponent">();
	}
	static class USprayPatternFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprayPatternFirearmFeelComponent>();
	}
};
static_assert(alignof(USprayPatternFirearmFeelComponent) == 0x000008, "Wrong alignment on USprayPatternFirearmFeelComponent");
static_assert(sizeof(USprayPatternFirearmFeelComponent) == 0x000210, "Wrong size on USprayPatternFirearmFeelComponent");
static_assert(offsetof(USprayPatternFirearmFeelComponent, bDebugSprayPattern2D) == 0x000138, "Member 'USprayPatternFirearmFeelComponent::bDebugSprayPattern2D' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, PatternPoints) == 0x000140, "Member 'USprayPatternFirearmFeelComponent::PatternPoints' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, ProjectionDistance) == 0x000150, "Member 'USprayPatternFirearmFeelComponent::ProjectionDistance' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, PatternScale) == 0x000154, "Member 'USprayPatternFirearmFeelComponent::PatternScale' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, PatternScaleModifier_Focusing) == 0x00015C, "Member 'USprayPatternFirearmFeelComponent::PatternScaleModifier_Focusing' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, CameraModifierScalar) == 0x000164, "Member 'USprayPatternFirearmFeelComponent::CameraModifierScalar' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, FireDirAmplitudeCurve) == 0x000168, "Member 'USprayPatternFirearmFeelComponent::FireDirAmplitudeCurve' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, GainRecoveryCooldownFactor) == 0x000180, "Member 'USprayPatternFirearmFeelComponent::GainRecoveryCooldownFactor' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, GainRecoveryFactor) == 0x000184, "Member 'USprayPatternFirearmFeelComponent::GainRecoveryFactor' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, bIsRecoveryConsumableByPlayerInput) == 0x000188, "Member 'USprayPatternFirearmFeelComponent::bIsRecoveryConsumableByPlayerInput' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, CatchupInterpolation) == 0x000190, "Member 'USprayPatternFirearmFeelComponent::CatchupInterpolation' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, CatchupFactor) == 0x000198, "Member 'USprayPatternFirearmFeelComponent::CatchupFactor' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, RecoverInterpolation) == 0x0001A0, "Member 'USprayPatternFirearmFeelComponent::RecoverInterpolation' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, RecoveryTime) == 0x0001A8, "Member 'USprayPatternFirearmFeelComponent::RecoveryTime' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, CrosshairAmplitudScalar) == 0x0001B0, "Member 'USprayPatternFirearmFeelComponent::CrosshairAmplitudScalar' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, CrosshairSpreadSpeed) == 0x0001B8, "Member 'USprayPatternFirearmFeelComponent::CrosshairSpreadSpeed' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, CrosshairShrinkScalar) == 0x0001C0, "Member 'USprayPatternFirearmFeelComponent::CrosshairShrinkScalar' has a wrong offset!");
static_assert(offsetof(USprayPatternFirearmFeelComponent, Gained) == 0x0001C4, "Member 'USprayPatternFirearmFeelComponent::Gained' has a wrong offset!");

// Class UnrealProject.CompositeAction
// 0x0010 (0x0070 - 0x0060)
class UCompositeAction : public UAction
{
public:
	TArray<class UAction*>                        Actions;                                           // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void AddAction(class UAction* Action);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompositeAction">();
	}
	static class UCompositeAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompositeAction>();
	}
};
static_assert(alignof(UCompositeAction) == 0x000008, "Wrong alignment on UCompositeAction");
static_assert(sizeof(UCompositeAction) == 0x000070, "Wrong size on UCompositeAction");
static_assert(offsetof(UCompositeAction, Actions) == 0x000060, "Member 'UCompositeAction::Actions' has a wrong offset!");

// Class UnrealProject.FirearmAttachment
// 0x0010 (0x03A0 - 0x0390)
class AFirearmAttachment : public AAttachment
{
public:
	TArray<struct FFirearmFeelComponentModifier>  WeaponFeelModifiers;                               // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirearmAttachment">();
	}
	static class AFirearmAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirearmAttachment>();
	}
};
static_assert(alignof(AFirearmAttachment) == 0x000010, "Wrong alignment on AFirearmAttachment");
static_assert(sizeof(AFirearmAttachment) == 0x0003A0, "Wrong size on AFirearmAttachment");
static_assert(offsetof(AFirearmAttachment, WeaponFeelModifiers) == 0x000390, "Member 'AFirearmAttachment::WeaponFeelModifiers' has a wrong offset!");

// Class UnrealProject.NGDInteractionComponent
// 0x0098 (0x0148 - 0x00B0)
class UNGDInteractionComponent final : public UActorComponent
{
public:
	float                                         InteractSphereRadius;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InteractSphereAttachmentSocket;                    // 0x00B4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusRayRadius;                                    // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractSlowTime;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             InteracionTriggerChannel;                          // 0x00C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             InteractionObjectChannel;                          // 0x00C5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             InteractionTraceChannel;                           // 0x00C6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C7[0x1];                                       // 0x00C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class AItem>, struct FItemClassArray> ItemRelations;                            // 0x00C8(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractSphere;                                    // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         InteractableActorsInRange;                         // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 InteractableActorFocused;                          // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 InteractableRelatedToLastPickup;                   // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetItemsInRange(TArray<class AItem*>* OutItemList);
	void LocalPlayerInteract();
	void OnInteractSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnInteractSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void ServerOnInteract(class AActor* InInteractable);
	void SetInteractableActorFocused(class AActor* InInteractableActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDInteractionComponent">();
	}
	static class UNGDInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDInteractionComponent>();
	}
};
static_assert(alignof(UNGDInteractionComponent) == 0x000008, "Wrong alignment on UNGDInteractionComponent");
static_assert(sizeof(UNGDInteractionComponent) == 0x000148, "Wrong size on UNGDInteractionComponent");
static_assert(offsetof(UNGDInteractionComponent, InteractSphereRadius) == 0x0000B0, "Member 'UNGDInteractionComponent::InteractSphereRadius' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteractSphereAttachmentSocket) == 0x0000B4, "Member 'UNGDInteractionComponent::InteractSphereAttachmentSocket' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, FocusRayRadius) == 0x0000BC, "Member 'UNGDInteractionComponent::FocusRayRadius' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteractSlowTime) == 0x0000C0, "Member 'UNGDInteractionComponent::InteractSlowTime' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteracionTriggerChannel) == 0x0000C4, "Member 'UNGDInteractionComponent::InteracionTriggerChannel' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteractionObjectChannel) == 0x0000C5, "Member 'UNGDInteractionComponent::InteractionObjectChannel' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteractionTraceChannel) == 0x0000C6, "Member 'UNGDInteractionComponent::InteractionTraceChannel' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, ItemRelations) == 0x0000C8, "Member 'UNGDInteractionComponent::ItemRelations' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteractSphere) == 0x000118, "Member 'UNGDInteractionComponent::InteractSphere' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteractableActorsInRange) == 0x000120, "Member 'UNGDInteractionComponent::InteractableActorsInRange' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteractableActorFocused) == 0x000130, "Member 'UNGDInteractionComponent::InteractableActorFocused' has a wrong offset!");
static_assert(offsetof(UNGDInteractionComponent, InteractableRelatedToLastPickup) == 0x000138, "Member 'UNGDInteractionComponent::InteractableRelatedToLastPickup' has a wrong offset!");

// Class UnrealProject.Parallel
// 0x0000 (0x0070 - 0x0070)
class UParallel final : public UCompositeAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Parallel">();
	}
	static class UParallel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParallel>();
	}
};
static_assert(alignof(UParallel) == 0x000008, "Wrong alignment on UParallel");
static_assert(sizeof(UParallel) == 0x000070, "Wrong size on UParallel");

// Class UnrealProject.NGDCar
// 0x00C0 (0x0478 - 0x03B8)
class ANGDCar final : public ANGDWheeledVehicle
{
public:
	class USpringArmComponent*                    SpringArm;                                         // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       Camera;                                            // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNGDAkComponentCarEngine*               AKComponentEngine;                                 // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehicleDustType*                       DustType;                                          // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AVehicleImpactEffect>       ImpactTemplate;                                    // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactEffectNormalForceThreshold;                  // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              EngineSound;                                       // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        EngineAC;                                          // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              LandingSound;                                      // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               DustPSC[0x4];                                      // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SkidSound;                                         // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SkidSoundStop;                                     // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkidFadeoutTime;                                   // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkidThresholdVelocity;                             // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LongSlipSkidThreshold;                             // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LateralSlipSkidThreshold;                          // 0x043C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        SkidAC;                                            // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpringCompressionLandingThreshold;                 // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkidDurationRequiredForStopSound;                  // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0xC];                                      // 0x0454(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShake>               ImpactCameraShake;                                 // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x10];                                     // 0x0468(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSound();

	bool IsHandbrakeActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDCar">();
	}
	static class ANGDCar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDCar>();
	}
};
static_assert(alignof(ANGDCar) == 0x000008, "Wrong alignment on ANGDCar");
static_assert(sizeof(ANGDCar) == 0x000478, "Wrong size on ANGDCar");
static_assert(offsetof(ANGDCar, SpringArm) == 0x0003B8, "Member 'ANGDCar::SpringArm' has a wrong offset!");
static_assert(offsetof(ANGDCar, Camera) == 0x0003C0, "Member 'ANGDCar::Camera' has a wrong offset!");
static_assert(offsetof(ANGDCar, AKComponentEngine) == 0x0003C8, "Member 'ANGDCar::AKComponentEngine' has a wrong offset!");
static_assert(offsetof(ANGDCar, DustType) == 0x0003D0, "Member 'ANGDCar::DustType' has a wrong offset!");
static_assert(offsetof(ANGDCar, ImpactTemplate) == 0x0003D8, "Member 'ANGDCar::ImpactTemplate' has a wrong offset!");
static_assert(offsetof(ANGDCar, ImpactEffectNormalForceThreshold) == 0x0003E0, "Member 'ANGDCar::ImpactEffectNormalForceThreshold' has a wrong offset!");
static_assert(offsetof(ANGDCar, EngineSound) == 0x0003E8, "Member 'ANGDCar::EngineSound' has a wrong offset!");
static_assert(offsetof(ANGDCar, EngineAC) == 0x0003F0, "Member 'ANGDCar::EngineAC' has a wrong offset!");
static_assert(offsetof(ANGDCar, LandingSound) == 0x0003F8, "Member 'ANGDCar::LandingSound' has a wrong offset!");
static_assert(offsetof(ANGDCar, DustPSC) == 0x000400, "Member 'ANGDCar::DustPSC' has a wrong offset!");
static_assert(offsetof(ANGDCar, SkidSound) == 0x000420, "Member 'ANGDCar::SkidSound' has a wrong offset!");
static_assert(offsetof(ANGDCar, SkidSoundStop) == 0x000428, "Member 'ANGDCar::SkidSoundStop' has a wrong offset!");
static_assert(offsetof(ANGDCar, SkidFadeoutTime) == 0x000430, "Member 'ANGDCar::SkidFadeoutTime' has a wrong offset!");
static_assert(offsetof(ANGDCar, SkidThresholdVelocity) == 0x000434, "Member 'ANGDCar::SkidThresholdVelocity' has a wrong offset!");
static_assert(offsetof(ANGDCar, LongSlipSkidThreshold) == 0x000438, "Member 'ANGDCar::LongSlipSkidThreshold' has a wrong offset!");
static_assert(offsetof(ANGDCar, LateralSlipSkidThreshold) == 0x00043C, "Member 'ANGDCar::LateralSlipSkidThreshold' has a wrong offset!");
static_assert(offsetof(ANGDCar, SkidAC) == 0x000440, "Member 'ANGDCar::SkidAC' has a wrong offset!");
static_assert(offsetof(ANGDCar, SpringCompressionLandingThreshold) == 0x000448, "Member 'ANGDCar::SpringCompressionLandingThreshold' has a wrong offset!");
static_assert(offsetof(ANGDCar, SkidDurationRequiredForStopSound) == 0x000450, "Member 'ANGDCar::SkidDurationRequiredForStopSound' has a wrong offset!");
static_assert(offsetof(ANGDCar, ImpactCameraShake) == 0x000460, "Member 'ANGDCar::ImpactCameraShake' has a wrong offset!");

// Class UnrealProject.Sequence
// 0x0000 (0x0070 - 0x0070)
class USequence final : public UCompositeAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Sequence">();
	}
	static class USequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequence>();
	}
};
static_assert(alignof(USequence) == 0x000008, "Wrong alignment on USequence");
static_assert(sizeof(USequence) == 0x000070, "Wrong size on USequence");

// Class UnrealProject.NGDCheatManager
// 0x0000 (0x0078 - 0x0078)
class UNGDCheatManager : public UCheatManager
{
public:
	bool CallOnServer(const class FString& Command);
	void ChangeLevel(const class FString& LevelName);
	void ChangeLevelSeemless(const class FString& LevelName);
	void Cheat(const class FString& Msg);
	void Cheats();
	void CrashGame();
	void DamagePlayersOnLobby(const class FString& Damage);
	void DropCar(const class FString& CarKey);
	void GetItem(const class FString& ItemKey);
	void GetItemQuantity(const class FString& ItemKey, int32 Quantity);
	void GetWeapon(const class FString& WeaponKey);
	void JoinTeam(int32 NewTeam);
	void Respawn();
	void RestartServer();
	void ShowTeam();
	void StartMapCapture();
	void Suicide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDCheatManager">();
	}
	static class UNGDCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDCheatManager>();
	}
};
static_assert(alignof(UNGDCheatManager) == 0x000008, "Wrong alignment on UNGDCheatManager");
static_assert(sizeof(UNGDCheatManager) == 0x000078, "Wrong size on UNGDCheatManager");

// Class UnrealProject.NGDVehicleComponent
// 0x0138 (0x01E8 - 0x00B0)
class UNGDVehicleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ANGDCharacter*                          Driver;                                            // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPassangers;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsControlledByDriver;                             // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldCheckCollisionToExit;                       // 0x00C5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDisableCollisionOnBoard;                    // 0x00C6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEnableCollisionOnUnBoard;                   // 0x00C7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAttachOnBoard;                              // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldHideHUD;                                    // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDSoundConfig                        BoardSound;                                        // 0x00D0(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        UnBoardSound;                                      // 0x0128(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      DriverAnimationSequence;                           // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CompanionAnimationSequence;                        // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class ANGDCharacter*>             PassengersMap;                                     // 0x0190(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PassangerSpringArmLength;                          // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDVehicleComponent">();
	}
	static class UNGDVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDVehicleComponent>();
	}
};
static_assert(alignof(UNGDVehicleComponent) == 0x000008, "Wrong alignment on UNGDVehicleComponent");
static_assert(sizeof(UNGDVehicleComponent) == 0x0001E8, "Wrong size on UNGDVehicleComponent");
static_assert(offsetof(UNGDVehicleComponent, Driver) == 0x0000B8, "Member 'UNGDVehicleComponent::Driver' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, MaxPassangers) == 0x0000C0, "Member 'UNGDVehicleComponent::MaxPassangers' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, bIsControlledByDriver) == 0x0000C4, "Member 'UNGDVehicleComponent::bIsControlledByDriver' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, bShouldCheckCollisionToExit) == 0x0000C5, "Member 'UNGDVehicleComponent::bShouldCheckCollisionToExit' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, bShouldDisableCollisionOnBoard) == 0x0000C6, "Member 'UNGDVehicleComponent::bShouldDisableCollisionOnBoard' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, bShouldEnableCollisionOnUnBoard) == 0x0000C7, "Member 'UNGDVehicleComponent::bShouldEnableCollisionOnUnBoard' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, bShouldAttachOnBoard) == 0x0000C8, "Member 'UNGDVehicleComponent::bShouldAttachOnBoard' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, bShouldHideHUD) == 0x0000C9, "Member 'UNGDVehicleComponent::bShouldHideHUD' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, BoardSound) == 0x0000D0, "Member 'UNGDVehicleComponent::BoardSound' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, UnBoardSound) == 0x000128, "Member 'UNGDVehicleComponent::UnBoardSound' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, DriverAnimationSequence) == 0x000180, "Member 'UNGDVehicleComponent::DriverAnimationSequence' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, CompanionAnimationSequence) == 0x000188, "Member 'UNGDVehicleComponent::CompanionAnimationSequence' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, PassengersMap) == 0x000190, "Member 'UNGDVehicleComponent::PassengersMap' has a wrong offset!");
static_assert(offsetof(UNGDVehicleComponent, PassangerSpringArmLength) == 0x0001E0, "Member 'UNGDVehicleComponent::PassangerSpringArmLength' has a wrong offset!");

// Class UnrealProject.MoveAction
// 0x0038 (0x0098 - 0x0060)
class UMoveAction final : public UAction
{
public:
	struct FVector                                MoveLocation;                                      // 0x0060(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0070(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventFinish();
	void EventUpdate(float Delta);
	void Initialize_Implementation(const struct FActionParams& ActionParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveAction">();
	}
	static class UMoveAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveAction>();
	}
};
static_assert(alignof(UMoveAction) == 0x000008, "Wrong alignment on UMoveAction");
static_assert(sizeof(UMoveAction) == 0x000098, "Wrong size on UMoveAction");
static_assert(offsetof(UMoveAction, MoveLocation) == 0x000060, "Member 'UMoveAction::MoveLocation' has a wrong offset!");
static_assert(offsetof(UMoveAction, PlayTestComp) == 0x000070, "Member 'UMoveAction::PlayTestComp' has a wrong offset!");

// Class UnrealProject.SelectRandomLocationAction
// 0x0008 (0x0068 - 0x0060)
class USelectRandomLocationAction final : public UAction
{
public:
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0060(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Initialize_Implementation(const struct FActionParams& ActionParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectRandomLocationAction">();
	}
	static class USelectRandomLocationAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectRandomLocationAction>();
	}
};
static_assert(alignof(USelectRandomLocationAction) == 0x000008, "Wrong alignment on USelectRandomLocationAction");
static_assert(sizeof(USelectRandomLocationAction) == 0x000068, "Wrong size on USelectRandomLocationAction");
static_assert(offsetof(USelectRandomLocationAction, PlayTestComp) == 0x000060, "Member 'USelectRandomLocationAction::PlayTestComp' has a wrong offset!");

// Class UnrealProject.NGDMapImagesGenerator
// 0x0088 (0x02B8 - 0x0230)
class ANGDMapImagesGenerator final : public ABaseActor
{
public:
	struct FVector                                MapCenter;                                         // 0x0230(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToWaitForLod;                                  // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToTakeScreenshot;                              // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x8];                                      // 0x0244(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredDivisions;                                  // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredResolution;                                 // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootSpringArm;                                     // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDSpringArmComponent*                 SpringArmComponent;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       CameraComponent;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      Controller;                                        // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x40];                                     // 0x0278(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartMapGeneration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDMapImagesGenerator">();
	}
	static class ANGDMapImagesGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDMapImagesGenerator>();
	}
};
static_assert(alignof(ANGDMapImagesGenerator) == 0x000008, "Wrong alignment on ANGDMapImagesGenerator");
static_assert(sizeof(ANGDMapImagesGenerator) == 0x0002B8, "Wrong size on ANGDMapImagesGenerator");
static_assert(offsetof(ANGDMapImagesGenerator, MapCenter) == 0x000230, "Member 'ANGDMapImagesGenerator::MapCenter' has a wrong offset!");
static_assert(offsetof(ANGDMapImagesGenerator, TimeToWaitForLod) == 0x00023C, "Member 'ANGDMapImagesGenerator::TimeToWaitForLod' has a wrong offset!");
static_assert(offsetof(ANGDMapImagesGenerator, TimeToTakeScreenshot) == 0x000240, "Member 'ANGDMapImagesGenerator::TimeToTakeScreenshot' has a wrong offset!");
static_assert(offsetof(ANGDMapImagesGenerator, DesiredDivisions) == 0x00024C, "Member 'ANGDMapImagesGenerator::DesiredDivisions' has a wrong offset!");
static_assert(offsetof(ANGDMapImagesGenerator, DesiredResolution) == 0x000250, "Member 'ANGDMapImagesGenerator::DesiredResolution' has a wrong offset!");
static_assert(offsetof(ANGDMapImagesGenerator, RootSpringArm) == 0x000258, "Member 'ANGDMapImagesGenerator::RootSpringArm' has a wrong offset!");
static_assert(offsetof(ANGDMapImagesGenerator, SpringArmComponent) == 0x000260, "Member 'ANGDMapImagesGenerator::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ANGDMapImagesGenerator, CameraComponent) == 0x000268, "Member 'ANGDMapImagesGenerator::CameraComponent' has a wrong offset!");
static_assert(offsetof(ANGDMapImagesGenerator, Controller) == 0x000270, "Member 'ANGDMapImagesGenerator::Controller' has a wrong offset!");

// Class UnrealProject.FireAction
// 0x0008 (0x0068 - 0x0060)
class UFireAction final : public UAction
{
public:
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0060(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EventUpdate(float Delta);
	void Initialize_Implementation(const struct FActionParams& ActionParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireAction">();
	}
	static class UFireAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireAction>();
	}
};
static_assert(alignof(UFireAction) == 0x000008, "Wrong alignment on UFireAction");
static_assert(sizeof(UFireAction) == 0x000068, "Wrong size on UFireAction");
static_assert(offsetof(UFireAction, PlayTestComp) == 0x000060, "Member 'UFireAction::PlayTestComp' has a wrong offset!");

// Class UnrealProject.ChangeSpeedAction
// 0x0018 (0x0078 - 0x0060)
class UChangeSpeedAction final : public UAction
{
public:
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0060(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventUpdate(float Delta);
	void Initialize_Implementation(const struct FActionParams& ActionParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeSpeedAction">();
	}
	static class UChangeSpeedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeSpeedAction>();
	}
};
static_assert(alignof(UChangeSpeedAction) == 0x000008, "Wrong alignment on UChangeSpeedAction");
static_assert(sizeof(UChangeSpeedAction) == 0x000078, "Wrong size on UChangeSpeedAction");
static_assert(offsetof(UChangeSpeedAction, PlayTestComp) == 0x000060, "Member 'UChangeSpeedAction::PlayTestComp' has a wrong offset!");

// Class UnrealProject.VehicleImpactEffect
// 0x0130 (0x0348 - 0x0218)
class AVehicleImpactEffect final : public AActor
{
public:
	class UParticleSystem*                        DefaultFX;                                         // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        AsphaltFX;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DirtFX;                                            // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        WaterFX;                                           // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        WoodFX;                                            // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StoneFX;                                           // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        MetalFX;                                           // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GrassFX;                                           // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GravelFX;                                          // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DefaultSound;                                      // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              AsphaltSound;                                      // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DirtSound;                                         // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              WaterSound;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              WoodSound;                                         // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              StoneSound;                                        // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MetalSound;                                        // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GrassSound;                                        // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GravelSound;                                       // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              WheelLandingSound;                                 // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitSurface;                                        // 0x02B0(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                HitForce;                                          // 0x0338(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleImpactEffect">();
	}
	static class AVehicleImpactEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleImpactEffect>();
	}
};
static_assert(alignof(AVehicleImpactEffect) == 0x000008, "Wrong alignment on AVehicleImpactEffect");
static_assert(sizeof(AVehicleImpactEffect) == 0x000348, "Wrong size on AVehicleImpactEffect");
static_assert(offsetof(AVehicleImpactEffect, DefaultFX) == 0x000218, "Member 'AVehicleImpactEffect::DefaultFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, AsphaltFX) == 0x000220, "Member 'AVehicleImpactEffect::AsphaltFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, DirtFX) == 0x000228, "Member 'AVehicleImpactEffect::DirtFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, WaterFX) == 0x000230, "Member 'AVehicleImpactEffect::WaterFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, WoodFX) == 0x000238, "Member 'AVehicleImpactEffect::WoodFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, StoneFX) == 0x000240, "Member 'AVehicleImpactEffect::StoneFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, MetalFX) == 0x000248, "Member 'AVehicleImpactEffect::MetalFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, GrassFX) == 0x000250, "Member 'AVehicleImpactEffect::GrassFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, GravelFX) == 0x000258, "Member 'AVehicleImpactEffect::GravelFX' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, DefaultSound) == 0x000260, "Member 'AVehicleImpactEffect::DefaultSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, AsphaltSound) == 0x000268, "Member 'AVehicleImpactEffect::AsphaltSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, DirtSound) == 0x000270, "Member 'AVehicleImpactEffect::DirtSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, WaterSound) == 0x000278, "Member 'AVehicleImpactEffect::WaterSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, WoodSound) == 0x000280, "Member 'AVehicleImpactEffect::WoodSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, StoneSound) == 0x000288, "Member 'AVehicleImpactEffect::StoneSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, MetalSound) == 0x000290, "Member 'AVehicleImpactEffect::MetalSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, GrassSound) == 0x000298, "Member 'AVehicleImpactEffect::GrassSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, GravelSound) == 0x0002A0, "Member 'AVehicleImpactEffect::GravelSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, WheelLandingSound) == 0x0002A8, "Member 'AVehicleImpactEffect::WheelLandingSound' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, HitSurface) == 0x0002B0, "Member 'AVehicleImpactEffect::HitSurface' has a wrong offset!");
static_assert(offsetof(AVehicleImpactEffect, HitForce) == 0x000338, "Member 'AVehicleImpactEffect::HitForce' has a wrong offset!");

// Class UnrealProject.Bullet
// 0x0000 (0x0368 - 0x0368)
class ABullet final : public ABaseProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bullet">();
	}
	static class ABullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABullet>();
	}
};
static_assert(alignof(ABullet) == 0x000008, "Wrong alignment on ABullet");
static_assert(sizeof(ABullet) == 0x000368, "Wrong size on ABullet");

// Class UnrealProject.GainFirearmFeelComponent
// 0x0018 (0x0150 - 0x0138)
class UGainFirearmFeelComponent : public UBaseFirearmFeelComponent
{
public:
	float                                         Gain;                                              // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Recovery;                                          // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoveryDelayFactor;                               // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0xC];                                      // 0x0144(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GainFirearmFeelComponent">();
	}
	static class UGainFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGainFirearmFeelComponent>();
	}
};
static_assert(alignof(UGainFirearmFeelComponent) == 0x000008, "Wrong alignment on UGainFirearmFeelComponent");
static_assert(sizeof(UGainFirearmFeelComponent) == 0x000150, "Wrong size on UGainFirearmFeelComponent");
static_assert(offsetof(UGainFirearmFeelComponent, Gain) == 0x000138, "Member 'UGainFirearmFeelComponent::Gain' has a wrong offset!");
static_assert(offsetof(UGainFirearmFeelComponent, Recovery) == 0x00013C, "Member 'UGainFirearmFeelComponent::Recovery' has a wrong offset!");
static_assert(offsetof(UGainFirearmFeelComponent, RecoveryDelayFactor) == 0x000140, "Member 'UGainFirearmFeelComponent::RecoveryDelayFactor' has a wrong offset!");

// Class UnrealProject.BulletCase
// 0x0028 (0x0258 - 0x0230)
class ABulletCase final : public ABaseActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Torque;                                            // 0x0240(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0xC];                                      // 0x024C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletCase">();
	}
	static class ABulletCase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletCase>();
	}
};
static_assert(alignof(ABulletCase) == 0x000008, "Wrong alignment on ABulletCase");
static_assert(sizeof(ABulletCase) == 0x000258, "Wrong size on ABulletCase");
static_assert(offsetof(ABulletCase, Root) == 0x000230, "Member 'ABulletCase::Root' has a wrong offset!");
static_assert(offsetof(ABulletCase, Mesh) == 0x000238, "Member 'ABulletCase::Mesh' has a wrong offset!");
static_assert(offsetof(ABulletCase, Torque) == 0x000240, "Member 'ABulletCase::Torque' has a wrong offset!");

// Class UnrealProject.NGDInteractableActor
// 0x0020 (0x0238 - 0x0218)
class ANGDInteractableActor : public AActor
{
public:
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionBox;                                    // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenInteractions;                          // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool EnterInteractZone(class ANGDCharacter* InCharacter);
	bool Interact(class ANGDCharacter* InCharacter);
	bool LeaveInteractZone(class ANGDCharacter* InCharacter);
	void OnEnterInteractZone(class ANGDCharacter* InCharacter);
	void OnInteract(class ANGDCharacter* InCharacter);
	void OnLeaveInteractZone(class ANGDCharacter* InCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDInteractableActor">();
	}
	static class ANGDInteractableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDInteractableActor>();
	}
};
static_assert(alignof(ANGDInteractableActor) == 0x000008, "Wrong alignment on ANGDInteractableActor");
static_assert(sizeof(ANGDInteractableActor) == 0x000238, "Wrong size on ANGDInteractableActor");
static_assert(offsetof(ANGDInteractableActor, Root) == 0x000220, "Member 'ANGDInteractableActor::Root' has a wrong offset!");
static_assert(offsetof(ANGDInteractableActor, InteractionBox) == 0x000228, "Member 'ANGDInteractableActor::InteractionBox' has a wrong offset!");
static_assert(offsetof(ANGDInteractableActor, DelayBetweenInteractions) == 0x000230, "Member 'ANGDInteractableActor::DelayBetweenInteractions' has a wrong offset!");

// Class UnrealProject.NGDPhysicalMaterial
// 0x00F0 (0x0170 - 0x0080)
class UNGDPhysicalMaterial final : public UPhysicalMaterial
{
public:
	TArray<TSubclassOf<class ADecalActor>>        impactDecals;                                      // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AEmitter>>           impactParticles;                                   // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         particleMinScale;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         particleMaxScale;                                  // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         particleScaleDistance;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDSoundConfig                        ImpactSound;                                       // 0x00B0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        FootstepSound;                                     // 0x0108(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* HitActor)> OnImpactDelegate;                         // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnImpact(class AActor* Instigator, class AActor* Target, const struct FVector& Position, const struct FVector& Normal, float Scale, class FName SocketName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPhysicalMaterial">();
	}
	static class UNGDPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPhysicalMaterial>();
	}
};
static_assert(alignof(UNGDPhysicalMaterial) == 0x000008, "Wrong alignment on UNGDPhysicalMaterial");
static_assert(sizeof(UNGDPhysicalMaterial) == 0x000170, "Wrong size on UNGDPhysicalMaterial");
static_assert(offsetof(UNGDPhysicalMaterial, impactDecals) == 0x000080, "Member 'UNGDPhysicalMaterial::impactDecals' has a wrong offset!");
static_assert(offsetof(UNGDPhysicalMaterial, impactParticles) == 0x000090, "Member 'UNGDPhysicalMaterial::impactParticles' has a wrong offset!");
static_assert(offsetof(UNGDPhysicalMaterial, particleMinScale) == 0x0000A0, "Member 'UNGDPhysicalMaterial::particleMinScale' has a wrong offset!");
static_assert(offsetof(UNGDPhysicalMaterial, particleMaxScale) == 0x0000A4, "Member 'UNGDPhysicalMaterial::particleMaxScale' has a wrong offset!");
static_assert(offsetof(UNGDPhysicalMaterial, particleScaleDistance) == 0x0000A8, "Member 'UNGDPhysicalMaterial::particleScaleDistance' has a wrong offset!");
static_assert(offsetof(UNGDPhysicalMaterial, ImpactSound) == 0x0000B0, "Member 'UNGDPhysicalMaterial::ImpactSound' has a wrong offset!");
static_assert(offsetof(UNGDPhysicalMaterial, FootstepSound) == 0x000108, "Member 'UNGDPhysicalMaterial::FootstepSound' has a wrong offset!");
static_assert(offsetof(UNGDPhysicalMaterial, OnImpactDelegate) == 0x000160, "Member 'UNGDPhysicalMaterial::OnImpactDelegate' has a wrong offset!");

// Class UnrealProject.CameraControllerComponent
// 0x0098 (0x0148 - 0x00B0)
class UCameraControllerComponent final : public UActorComponent
{
public:
	TMap<ECameraTypes, struct FCompleteCameraConfig> CompleteCamerasConfigs;                         // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootSpringArm;                                     // 0x0100(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDCameraComponent*                    CurrentCamera;                                     // 0x0108(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDSpringArmComponent*                 CurrentSpringArm;                                  // 0x0110(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldUpdateCamera;                                // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENGDCharacterLocomotionFlags                  CharacterLocomotionFlags;                          // 0x0119(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENGDCharacterExtraFlags                       CharacterExtraFlags;                               // 0x011A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B[0x1];                                      // 0x011B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CharacterOrigin;                                   // 0x011C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterVelocity;                                 // 0x0128(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CharacterControllerRotation;                       // 0x0134(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ADSFOV;                                            // 0x0140(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUpdateOwnerDataOnTick;                      // 0x0144(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CharacterHasExtraFlag(ENGDCharacterExtraFlags FlagToCheck);
	bool CharacterHasLocomotionFlag(ENGDCharacterLocomotionFlags FlagToCheck);
	bool GetShouldUpdateCamera();
	void OnInteriorStatusChange(bool bEnteredBuilding);
	void OnTeleport(const struct FVector& TeleportedPosition, const struct FRotator& TeleportedRotator);
	void SetShouldUpdateCamera(bool Value);
	void UpdateCameraConfigTargetArmLength(ECameraTypes CameraType, float NewLength);
	void UpdateOwnerData();
	void UpdateOwnerDataBP(class AActor* Owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraControllerComponent">();
	}
	static class UCameraControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraControllerComponent>();
	}
};
static_assert(alignof(UCameraControllerComponent) == 0x000008, "Wrong alignment on UCameraControllerComponent");
static_assert(sizeof(UCameraControllerComponent) == 0x000148, "Wrong size on UCameraControllerComponent");
static_assert(offsetof(UCameraControllerComponent, CompleteCamerasConfigs) == 0x0000B0, "Member 'UCameraControllerComponent::CompleteCamerasConfigs' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, RootSpringArm) == 0x000100, "Member 'UCameraControllerComponent::RootSpringArm' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, CurrentCamera) == 0x000108, "Member 'UCameraControllerComponent::CurrentCamera' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, CurrentSpringArm) == 0x000110, "Member 'UCameraControllerComponent::CurrentSpringArm' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, ShouldUpdateCamera) == 0x000118, "Member 'UCameraControllerComponent::ShouldUpdateCamera' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, CharacterLocomotionFlags) == 0x000119, "Member 'UCameraControllerComponent::CharacterLocomotionFlags' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, CharacterExtraFlags) == 0x00011A, "Member 'UCameraControllerComponent::CharacterExtraFlags' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, CharacterOrigin) == 0x00011C, "Member 'UCameraControllerComponent::CharacterOrigin' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, CharacterVelocity) == 0x000128, "Member 'UCameraControllerComponent::CharacterVelocity' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, CharacterControllerRotation) == 0x000134, "Member 'UCameraControllerComponent::CharacterControllerRotation' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, ADSFOV) == 0x000140, "Member 'UCameraControllerComponent::ADSFOV' has a wrong offset!");
static_assert(offsetof(UCameraControllerComponent, bShouldUpdateOwnerDataOnTick) == 0x000144, "Member 'UCameraControllerComponent::bShouldUpdateOwnerDataOnTick' has a wrong offset!");

// Class UnrealProject.NGDUserWidget
// 0x0050 (0x0280 - 0x0230)
class UNGDUserWidget : public UUserWidget
{
public:
	uint8                                         Pad_230[0x50];                                     // 0x0230(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* CreateWidgetComponent(TSubclassOf<class UWidget> WidgetClass);

	class ANGDHUD* GetHUD() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDUserWidget">();
	}
	static class UNGDUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDUserWidget>();
	}
};
static_assert(alignof(UNGDUserWidget) == 0x000008, "Wrong alignment on UNGDUserWidget");
static_assert(sizeof(UNGDUserWidget) == 0x000280, "Wrong size on UNGDUserWidget");

// Class UnrealProject.CameraShakeFirearmFeelComponent
// 0x0010 (0x0148 - 0x0138)
class UCameraShakeFirearmFeelComponent final : public UBaseFirearmFeelComponent
{
public:
	TArray<TSubclassOf<class UCameraShake>>       Shakes;                                            // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraShakeFirearmFeelComponent">();
	}
	static class UCameraShakeFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraShakeFirearmFeelComponent>();
	}
};
static_assert(alignof(UCameraShakeFirearmFeelComponent) == 0x000008, "Wrong alignment on UCameraShakeFirearmFeelComponent");
static_assert(sizeof(UCameraShakeFirearmFeelComponent) == 0x000148, "Wrong size on UCameraShakeFirearmFeelComponent");
static_assert(offsetof(UCameraShakeFirearmFeelComponent, Shakes) == 0x000138, "Member 'UCameraShakeFirearmFeelComponent::Shakes' has a wrong offset!");

// Class UnrealProject.ScopeAttachment
// 0x00B0 (0x0450 - 0x03A0)
class AScopeAttachment final : public AFirearmAttachment
{
public:
	struct FRotator                               AimTransformCorrection;                            // 0x03A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MeshADSComponent;                                  // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MeshCrosshairComponent;                            // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AFirearm>, struct FAttachmentScopeConfig> ScopeConfigs;                   // 0x03C8(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAttachmentScopeConfig                 DefaultScopeConfig;                                // 0x0418(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform GetAimTransform();
	void OnADSStateChanged(bool bIsADS);

	const struct FAttachmentScopeConfig GetScopeConfig() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScopeAttachment">();
	}
	static class AScopeAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScopeAttachment>();
	}
};
static_assert(alignof(AScopeAttachment) == 0x000010, "Wrong alignment on AScopeAttachment");
static_assert(sizeof(AScopeAttachment) == 0x000450, "Wrong size on AScopeAttachment");
static_assert(offsetof(AScopeAttachment, AimTransformCorrection) == 0x0003A0, "Member 'AScopeAttachment::AimTransformCorrection' has a wrong offset!");
static_assert(offsetof(AScopeAttachment, PostProcessComponent) == 0x0003B0, "Member 'AScopeAttachment::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(AScopeAttachment, MeshADSComponent) == 0x0003B8, "Member 'AScopeAttachment::MeshADSComponent' has a wrong offset!");
static_assert(offsetof(AScopeAttachment, MeshCrosshairComponent) == 0x0003C0, "Member 'AScopeAttachment::MeshCrosshairComponent' has a wrong offset!");
static_assert(offsetof(AScopeAttachment, ScopeConfigs) == 0x0003C8, "Member 'AScopeAttachment::ScopeConfigs' has a wrong offset!");
static_assert(offsetof(AScopeAttachment, DefaultScopeConfig) == 0x000418, "Member 'AScopeAttachment::DefaultScopeConfig' has a wrong offset!");

// Class UnrealProject.CheckAmmoAction
// 0x0038 (0x0098 - 0x0060)
class UCheckAmmoAction final : public UAction
{
public:
	struct FActionParams                          ActionParams;                                      // 0x0060(0x0030)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EventUpdate(float DeltaTime);
	void Initialize_Implementation(const struct FActionParams& ActionParams_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckAmmoAction">();
	}
	static class UCheckAmmoAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckAmmoAction>();
	}
};
static_assert(alignof(UCheckAmmoAction) == 0x000008, "Wrong alignment on UCheckAmmoAction");
static_assert(sizeof(UCheckAmmoAction) == 0x000098, "Wrong size on UCheckAmmoAction");
static_assert(offsetof(UCheckAmmoAction, ActionParams) == 0x000060, "Member 'UCheckAmmoAction::ActionParams' has a wrong offset!");
static_assert(offsetof(UCheckAmmoAction, PlayTestComp) == 0x000090, "Member 'UCheckAmmoAction::PlayTestComp' has a wrong offset!");

// Class UnrealProject.CheckEnemyAction
// 0x0048 (0x00A8 - 0x0060)
class UCheckEnemyAction final : public UAction
{
public:
	struct FActionParams                          ActionParams;                                      // 0x0060(0x0030)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANGDCharacter*                          EnemyTarget;                                       // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToAim;                                     // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAim();
	void EventUpdate(float DeltaTime);
	void Initialize_Implementation(const struct FActionParams& InActionParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckEnemyAction">();
	}
	static class UCheckEnemyAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckEnemyAction>();
	}
};
static_assert(alignof(UCheckEnemyAction) == 0x000008, "Wrong alignment on UCheckEnemyAction");
static_assert(sizeof(UCheckEnemyAction) == 0x0000A8, "Wrong size on UCheckEnemyAction");
static_assert(offsetof(UCheckEnemyAction, ActionParams) == 0x000060, "Member 'UCheckEnemyAction::ActionParams' has a wrong offset!");
static_assert(offsetof(UCheckEnemyAction, PlayTestComp) == 0x000090, "Member 'UCheckEnemyAction::PlayTestComp' has a wrong offset!");
static_assert(offsetof(UCheckEnemyAction, EnemyTarget) == 0x000098, "Member 'UCheckEnemyAction::EnemyTarget' has a wrong offset!");
static_assert(offsetof(UCheckEnemyAction, DistanceToAim) == 0x0000A0, "Member 'UCheckEnemyAction::DistanceToAim' has a wrong offset!");

// Class UnrealProject.Consumable
// 0x0078 (0x0328 - 0x02B0)
class AConsumable : public AItem
{
public:
	class UAnimMontage*                           ConsumingAnimMontage;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToConsume;                                     // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNGDSoundConfig                        ConsumeSound;                                      // 0x02C0(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UInventoryComponent*                    LastConsumerInventory;                             // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTimeToConsumeElapsed();
	void ServerStopConsume();
	void StartTimer();
	void Tick(float DeltaTime);

	float GetRemainingTimeToConsume() const;
	float GetTimeToConsume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Consumable">();
	}
	static class AConsumable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConsumable>();
	}
};
static_assert(alignof(AConsumable) == 0x000008, "Wrong alignment on AConsumable");
static_assert(sizeof(AConsumable) == 0x000328, "Wrong size on AConsumable");
static_assert(offsetof(AConsumable, ConsumingAnimMontage) == 0x0002B0, "Member 'AConsumable::ConsumingAnimMontage' has a wrong offset!");
static_assert(offsetof(AConsumable, TimeToConsume) == 0x0002B8, "Member 'AConsumable::TimeToConsume' has a wrong offset!");
static_assert(offsetof(AConsumable, ConsumeSound) == 0x0002C0, "Member 'AConsumable::ConsumeSound' has a wrong offset!");
static_assert(offsetof(AConsumable, LastConsumerInventory) == 0x000318, "Member 'AConsumable::LastConsumerInventory' has a wrong offset!");

// Class UnrealProject.DeviationFirearmFeelComponent
// 0x00E8 (0x0220 - 0x0138)
class UDeviationFirearmFeelComponent final : public UBaseFirearmFeelComponent
{
public:
	uint8                                         Pad_138[0x30];                                     // 0x0138(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDeviation;                                     // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BaseDeviationCurve;                                // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseDeltaDeviation;                                // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENGDCharacterExtraFlags, struct FDeviationStateOverrides> CompoundExtraFlagsStateOverrides; // 0x0180(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENGDCharacterLocomotionFlags, struct FDeviationStateOverrides> CompoundLocomotionStateOverrides; // 0x01D0(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	float GetCurrentDeviationMagnitude() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeviationFirearmFeelComponent">();
	}
	static class UDeviationFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeviationFirearmFeelComponent>();
	}
};
static_assert(alignof(UDeviationFirearmFeelComponent) == 0x000008, "Wrong alignment on UDeviationFirearmFeelComponent");
static_assert(sizeof(UDeviationFirearmFeelComponent) == 0x000220, "Wrong size on UDeviationFirearmFeelComponent");
static_assert(offsetof(UDeviationFirearmFeelComponent, BaseDeviation) == 0x000168, "Member 'UDeviationFirearmFeelComponent::BaseDeviation' has a wrong offset!");
static_assert(offsetof(UDeviationFirearmFeelComponent, BaseDeviationCurve) == 0x000170, "Member 'UDeviationFirearmFeelComponent::BaseDeviationCurve' has a wrong offset!");
static_assert(offsetof(UDeviationFirearmFeelComponent, BaseDeltaDeviation) == 0x000178, "Member 'UDeviationFirearmFeelComponent::BaseDeltaDeviation' has a wrong offset!");
static_assert(offsetof(UDeviationFirearmFeelComponent, CompoundExtraFlagsStateOverrides) == 0x000180, "Member 'UDeviationFirearmFeelComponent::CompoundExtraFlagsStateOverrides' has a wrong offset!");
static_assert(offsetof(UDeviationFirearmFeelComponent, CompoundLocomotionStateOverrides) == 0x0001D0, "Member 'UDeviationFirearmFeelComponent::CompoundLocomotionStateOverrides' has a wrong offset!");

// Class UnrealProject.DropMagazine
// 0x0008 (0x0238 - 0x0230)
class ADropMagazine final : public ABaseActor
{
public:
	class UStaticMeshComponent*                   DropMagazineMeshComponent;                         // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropMagazine">();
	}
	static class ADropMagazine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADropMagazine>();
	}
};
static_assert(alignof(ADropMagazine) == 0x000008, "Wrong alignment on ADropMagazine");
static_assert(sizeof(ADropMagazine) == 0x000238, "Wrong size on ADropMagazine");
static_assert(offsetof(ADropMagazine, DropMagazineMeshComponent) == 0x000230, "Member 'ADropMagazine::DropMagazineMeshComponent' has a wrong offset!");

// Class UnrealProject.Weapon
// 0x0278 (0x0560 - 0x02E8)
class alignas(0x10) AWeapon : public AEquipment
{
public:
	float                                         BaseDamage;                                        // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactImpulseForce;                                // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, TSubclassOf<class UNGDBodyPart>> DamageModifierMapOverride;                    // 0x02F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bIsDoingMelee;                                     // 0x0340(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldLogValidation;                              // 0x0341(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_342[0x1A];                                     // 0x0342(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnimWeaponTypeIndex;                               // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimFP_ADSOffset;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimGripOffset;                                    // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimTP_ADSOffset;                                  // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimTP_Crouch_GripOffset;                          // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimTP_Crouch_ADSOffset;                           // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimFire;                                          // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimFireCrouch;                                    // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimReload;                                        // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimReloadCrouch;                                  // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WeaponOutline;                                     // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             WeaponImage;                                       // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNGDCrosshairWidget>        CrosshairWidgetClass;                              // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedPenaltyForReload;                             // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedPenaltyCurveForReload;                        // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedPenaltyForADS;                                // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedPenaltyForFocus;                              // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedPenaltyForDrawed;                             // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationPenaltyForReload;                      // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationPenaltyForADS;                         // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationPenaltyForFocus;                       // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationPenaltyForDrawed;                      // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationPenaltyForFiring;                      // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VisibleWhenInactive;                               // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDrawed;                                         // 0x03F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F2[0x2];                                      // 0x03F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponDrawDuration;                                // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponHolsterDuration;                             // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TPArmAttachSocket;                                 // 0x03FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AimSocketName;                                     // 0x0404(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDynamicZeroing;                                // 0x040C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Zeroings;                                          // 0x0410(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         AimingDelayFactor;                                 // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedZeroing;                                   // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasADSCapability;                                 // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitRegistrationBullet                 HitRegistrationBulletCached;                       // 0x042C(0x0024)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x4];                                      // 0x0450(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VolleySize;                                        // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VolleySpreadAngle;                                 // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusingVolleySpreadScale;                         // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusingThreesholdToChangeSpread;                  // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      PatternPoints;                                     // 0x0468(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         VolleyPatternProjectionDistance;                   // 0x0478(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldPredictProjectile;                          // 0x047C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTriggering;                                     // 0x047D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47E[0xA];                                      // 0x047E(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BulletCaseSocketName;                              // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FireSocketName;                                    // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScopeSocketName;                                   // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EventsTimeWindow;                                  // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ValidationThreshold;                               // 0x04A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FireSocketDiscrepancyLimit;                        // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AC[0xB4];                                     // 0x04AC(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Equip();
	void Fire(const struct FLocalFireEvent& LocalFireEvent, bool bShouldCreateProjectile);
	struct FVector GetAimingDestination();
	float GetCrosshairAmplitude();
	void Multicast_OnRemoteDesyncFireEvent(const struct FRemoteDesyncFireEvent& RemoteDesyncFireEvent);
	void Multicast_OnRemoteFireEvent(const struct FRemoteFireEvent& RemoteFireEvent);
	void Native_CosmeticsOnFired(const struct FVector& Position, const struct FRotator& Direction);
	void OnDraw();
	void OnFired(const struct FVector& Position, const struct FRotator& Direction);
	void OnHolster();
	void ResetState();
	void Server_NotifyLocalFireEvent(float SyncedTimeStamp, const struct FVector& ShootPos, const struct FRotator& ShootRot, uint16 InBulletIndex);
	void Server_NotifyLocalHitEvent(float TimeToCheckHit, class AActor* Victim, int32 BoneIndex, float ClientPing, float TraveledTime, uint16 InBulletIndex);
	void Server_NotifyLocalHitEventWithPellet(float TimeToCheckHit, class AActor* Victim, int32 BoneIndex, float ClientPing, float TraveledTime, uint16 InBulletIndex, uint8 VolleyIndex);
	void SetIsDoingMelee(bool bValue);
	void TriggerPressed();
	void TriggerReleased();
	void Unequip();

	bool CanFire() const;
	bool CanOwningCharacterFire() const;
	struct FTransform GetAimPointLocalTransform() const;
	float GetBaseDamage() const;
	struct FRotator GetCurrentCameraRotation() const;
	float GetCurrentZeroingDistance() const;
	struct FTransform GetFireSocketTransform() const;
	float GetImpactImpulseForce() const;
	struct FTransform GetScopeSocketTransform() const;
	int32 GetVolleySize() const;
	bool HasADSCapability() const;
	bool IsDoingMelee() const;
	bool IsTriggering() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Weapon">();
	}
	static class AWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeapon>();
	}
};
static_assert(alignof(AWeapon) == 0x000010, "Wrong alignment on AWeapon");
static_assert(sizeof(AWeapon) == 0x000560, "Wrong size on AWeapon");
static_assert(offsetof(AWeapon, BaseDamage) == 0x0002E8, "Member 'AWeapon::BaseDamage' has a wrong offset!");
static_assert(offsetof(AWeapon, ImpactImpulseForce) == 0x0002EC, "Member 'AWeapon::ImpactImpulseForce' has a wrong offset!");
static_assert(offsetof(AWeapon, DamageModifierMapOverride) == 0x0002F0, "Member 'AWeapon::DamageModifierMapOverride' has a wrong offset!");
static_assert(offsetof(AWeapon, bIsDoingMelee) == 0x000340, "Member 'AWeapon::bIsDoingMelee' has a wrong offset!");
static_assert(offsetof(AWeapon, bShouldLogValidation) == 0x000341, "Member 'AWeapon::bShouldLogValidation' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimWeaponTypeIndex) == 0x00035C, "Member 'AWeapon::AnimWeaponTypeIndex' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimFP_ADSOffset) == 0x000360, "Member 'AWeapon::AnimFP_ADSOffset' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimGripOffset) == 0x000368, "Member 'AWeapon::AnimGripOffset' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimTP_ADSOffset) == 0x000370, "Member 'AWeapon::AnimTP_ADSOffset' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimTP_Crouch_GripOffset) == 0x000378, "Member 'AWeapon::AnimTP_Crouch_GripOffset' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimTP_Crouch_ADSOffset) == 0x000380, "Member 'AWeapon::AnimTP_Crouch_ADSOffset' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimFire) == 0x000388, "Member 'AWeapon::AnimFire' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimFireCrouch) == 0x000390, "Member 'AWeapon::AnimFireCrouch' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimReload) == 0x000398, "Member 'AWeapon::AnimReload' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimReloadCrouch) == 0x0003A0, "Member 'AWeapon::AnimReloadCrouch' has a wrong offset!");
static_assert(offsetof(AWeapon, WeaponOutline) == 0x0003A8, "Member 'AWeapon::WeaponOutline' has a wrong offset!");
static_assert(offsetof(AWeapon, WeaponImage) == 0x0003B0, "Member 'AWeapon::WeaponImage' has a wrong offset!");
static_assert(offsetof(AWeapon, CrosshairWidgetClass) == 0x0003B8, "Member 'AWeapon::CrosshairWidgetClass' has a wrong offset!");
static_assert(offsetof(AWeapon, SpeedPenaltyForReload) == 0x0003C0, "Member 'AWeapon::SpeedPenaltyForReload' has a wrong offset!");
static_assert(offsetof(AWeapon, SpeedPenaltyCurveForReload) == 0x0003C8, "Member 'AWeapon::SpeedPenaltyCurveForReload' has a wrong offset!");
static_assert(offsetof(AWeapon, SpeedPenaltyForADS) == 0x0003D0, "Member 'AWeapon::SpeedPenaltyForADS' has a wrong offset!");
static_assert(offsetof(AWeapon, SpeedPenaltyForFocus) == 0x0003D4, "Member 'AWeapon::SpeedPenaltyForFocus' has a wrong offset!");
static_assert(offsetof(AWeapon, SpeedPenaltyForDrawed) == 0x0003D8, "Member 'AWeapon::SpeedPenaltyForDrawed' has a wrong offset!");
static_assert(offsetof(AWeapon, AccelerationPenaltyForReload) == 0x0003DC, "Member 'AWeapon::AccelerationPenaltyForReload' has a wrong offset!");
static_assert(offsetof(AWeapon, AccelerationPenaltyForADS) == 0x0003E0, "Member 'AWeapon::AccelerationPenaltyForADS' has a wrong offset!");
static_assert(offsetof(AWeapon, AccelerationPenaltyForFocus) == 0x0003E4, "Member 'AWeapon::AccelerationPenaltyForFocus' has a wrong offset!");
static_assert(offsetof(AWeapon, AccelerationPenaltyForDrawed) == 0x0003E8, "Member 'AWeapon::AccelerationPenaltyForDrawed' has a wrong offset!");
static_assert(offsetof(AWeapon, AccelerationPenaltyForFiring) == 0x0003EC, "Member 'AWeapon::AccelerationPenaltyForFiring' has a wrong offset!");
static_assert(offsetof(AWeapon, VisibleWhenInactive) == 0x0003F0, "Member 'AWeapon::VisibleWhenInactive' has a wrong offset!");
static_assert(offsetof(AWeapon, bIsDrawed) == 0x0003F1, "Member 'AWeapon::bIsDrawed' has a wrong offset!");
static_assert(offsetof(AWeapon, WeaponDrawDuration) == 0x0003F4, "Member 'AWeapon::WeaponDrawDuration' has a wrong offset!");
static_assert(offsetof(AWeapon, WeaponHolsterDuration) == 0x0003F8, "Member 'AWeapon::WeaponHolsterDuration' has a wrong offset!");
static_assert(offsetof(AWeapon, TPArmAttachSocket) == 0x0003FC, "Member 'AWeapon::TPArmAttachSocket' has a wrong offset!");
static_assert(offsetof(AWeapon, AimSocketName) == 0x000404, "Member 'AWeapon::AimSocketName' has a wrong offset!");
static_assert(offsetof(AWeapon, bUseDynamicZeroing) == 0x00040C, "Member 'AWeapon::bUseDynamicZeroing' has a wrong offset!");
static_assert(offsetof(AWeapon, Zeroings) == 0x000410, "Member 'AWeapon::Zeroings' has a wrong offset!");
static_assert(offsetof(AWeapon, AimingDelayFactor) == 0x000420, "Member 'AWeapon::AimingDelayFactor' has a wrong offset!");
static_assert(offsetof(AWeapon, SelectedZeroing) == 0x000424, "Member 'AWeapon::SelectedZeroing' has a wrong offset!");
static_assert(offsetof(AWeapon, bHasADSCapability) == 0x000428, "Member 'AWeapon::bHasADSCapability' has a wrong offset!");
static_assert(offsetof(AWeapon, HitRegistrationBulletCached) == 0x00042C, "Member 'AWeapon::HitRegistrationBulletCached' has a wrong offset!");
static_assert(offsetof(AWeapon, VolleySize) == 0x000454, "Member 'AWeapon::VolleySize' has a wrong offset!");
static_assert(offsetof(AWeapon, VolleySpreadAngle) == 0x000458, "Member 'AWeapon::VolleySpreadAngle' has a wrong offset!");
static_assert(offsetof(AWeapon, FocusingVolleySpreadScale) == 0x00045C, "Member 'AWeapon::FocusingVolleySpreadScale' has a wrong offset!");
static_assert(offsetof(AWeapon, FocusingThreesholdToChangeSpread) == 0x000460, "Member 'AWeapon::FocusingThreesholdToChangeSpread' has a wrong offset!");
static_assert(offsetof(AWeapon, PatternPoints) == 0x000468, "Member 'AWeapon::PatternPoints' has a wrong offset!");
static_assert(offsetof(AWeapon, VolleyPatternProjectionDistance) == 0x000478, "Member 'AWeapon::VolleyPatternProjectionDistance' has a wrong offset!");
static_assert(offsetof(AWeapon, bShouldPredictProjectile) == 0x00047C, "Member 'AWeapon::bShouldPredictProjectile' has a wrong offset!");
static_assert(offsetof(AWeapon, bIsTriggering) == 0x00047D, "Member 'AWeapon::bIsTriggering' has a wrong offset!");
static_assert(offsetof(AWeapon, BulletCaseSocketName) == 0x000488, "Member 'AWeapon::BulletCaseSocketName' has a wrong offset!");
static_assert(offsetof(AWeapon, FireSocketName) == 0x000490, "Member 'AWeapon::FireSocketName' has a wrong offset!");
static_assert(offsetof(AWeapon, ScopeSocketName) == 0x000498, "Member 'AWeapon::ScopeSocketName' has a wrong offset!");
static_assert(offsetof(AWeapon, EventsTimeWindow) == 0x0004A0, "Member 'AWeapon::EventsTimeWindow' has a wrong offset!");
static_assert(offsetof(AWeapon, ValidationThreshold) == 0x0004A4, "Member 'AWeapon::ValidationThreshold' has a wrong offset!");
static_assert(offsetof(AWeapon, FireSocketDiscrepancyLimit) == 0x0004A8, "Member 'AWeapon::FireSocketDiscrepancyLimit' has a wrong offset!");

// Class UnrealProject.Firearm
// 0x0310 (0x0870 - 0x0560)
class AFirearm : public AWeapon
{
public:
	class FString                                 FirearmType;                                       // 0x0560(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomFeelTimeDilation;                            // 0x0570(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           ReloadSoundRef;                                    // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairAmplitudFactor;                           // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletCaseImpulse;                                 // 0x0584(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletCaseSpawnDelay;                              // 0x0588(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MuzzleScaleOnADS;                                  // 0x058C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MuzzleSocketName;                                  // 0x0590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABulletCase>                BulletCaseClass;                                   // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ProjectileExtraVisual;                             // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        MuzzleFlash;                                       // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        FireSound;                                         // 0x05B0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        LastBulletFireSound;                               // 0x0608(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        ReloadSound;                                       // 0x0660(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        FireModeChangeSound;                               // 0x06B8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        NoBulletsSound;                                    // 0x0710(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UNGDAkComponent*                        FirearmAkComponent;                                // 0x0768(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNGDAkComponent*                        ReloadAkComponent;                                 // 0x0770(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFirearmFeelResult                     CurrentWeaponFeel;                                 // 0x0778(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         ADSFOV;                                            // 0x07D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentAdsFoV;                                     // 0x07DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentFireTimer;                                  // 0x07E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentBurstTimer;                                 // 0x07E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFiringMode;                                 // 0x07E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFiring;                                          // 0x07EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLockedBySemiMode;                                // 0x07ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7EE[0x2];                                      // 0x07EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentBurstShot;                                  // 0x07F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFirearmMode>                   FiringModes;                                       // 0x07F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CurrentChamberTimer;                               // 0x0808(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChamberTimeDuration;                               // 0x080C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTriggeringTimer;                            // 0x0810(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChambered;                                        // 0x0814(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_815[0x3];                                      // 0x0815(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireRate;                                          // 0x0818(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MuzzleSpeed;                                       // 0x081C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityDamageScale;                               // 0x0820(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_824[0x4];                                      // 0x0824(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseProjectile>            ProjectileClass;                                   // 0x0828(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0830(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0834(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentReloadTimer;                                // 0x0838(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83C[0x4];                                      // 0x083C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAmmunition>                AmmoClass;                                         // 0x0840(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentAmmo;                                       // 0x0848(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClipSize;                                          // 0x084C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadTime;                                        // 0x0850(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadCockTime;                                    // 0x0854(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReloadModeClip;                                    // 0x0858(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoReload;                                        // 0x0859(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReloading;                                       // 0x085A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85B[0x15];                                     // 0x085B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_OnReloadFail();
	void Client_OnReloadSuccess(int32 NewAmmo);
	class ABaseProjectile* CreateProjectile(TSubclassOf<class ABaseProjectile> InProjectileClass, const struct FLocalFireEvent& FireEvent, const struct FRotator& Direction, int32 VolleyIndex);
	void FireVolley(TSubclassOf<class ABaseProjectile> InProjectileClass, const struct FLocalFireEvent& FireEvent);
	int32 GetAndDestroyAmmoFromInventory(int32 DesiredAmmoToDestroy);
	struct FRotator GetFireDirection();
	struct FTransform GetMuzzleFlashTransform();
	void Multicast_ForceCurrentAmmo(int32 NewAmmo);
	void Multicast_OnReloadSuccess(int32 NewAmmo);
	void Native_CosmeticsOnReload();
	void OnAmmoChanged(int32 NewAmmoCount);
	void OnAmmoChanged_Multicast(uint8 NewAmmoCount);
	void OnRep_FiringMode();
	void Server_NotifyLocalFireEvent_Cooked(float SyncedTimeStamp, const struct FVector& ShootPos, const struct FRotator& ShootRot, uint16 InBulletIndex, float CookTime);
	void Server_NotifyLocalReloadEvent(float SyncedTimeStamp);
	void Server_SetFiringMode(int32 firingModeIndex);
	void SpawnBulletCase();

	int32 GetAvailableAmmo() const;
	int32 GetClipSize() const;
	float GetCookProgress() const;
	int32 GetCurrentAmmo() const;
	float GetCurrentCookTime() const;
	int32 GetCurrentFiringMode() const;
	struct FRotator GetCurrentKickRotation() const;
	struct FVector GetCurrentKickTranslation() const;
	struct FFirearmFeelResult GetCurrentWeaponFeel() const;
	class AMagazineAttachment* GetMagazineAttachment() const;
	const struct FFirearmMode GetMode() const;
	float GetReloadTime() const;
	bool IsChambering() const;
	bool IsFeederReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Firearm">();
	}
	static class AFirearm* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirearm>();
	}
};
static_assert(alignof(AFirearm) == 0x000010, "Wrong alignment on AFirearm");
static_assert(sizeof(AFirearm) == 0x000870, "Wrong size on AFirearm");
static_assert(offsetof(AFirearm, FirearmType) == 0x000560, "Member 'AFirearm::FirearmType' has a wrong offset!");
static_assert(offsetof(AFirearm, CustomFeelTimeDilation) == 0x000570, "Member 'AFirearm::CustomFeelTimeDilation' has a wrong offset!");
static_assert(offsetof(AFirearm, ReloadSoundRef) == 0x000578, "Member 'AFirearm::ReloadSoundRef' has a wrong offset!");
static_assert(offsetof(AFirearm, CrosshairAmplitudFactor) == 0x000580, "Member 'AFirearm::CrosshairAmplitudFactor' has a wrong offset!");
static_assert(offsetof(AFirearm, BulletCaseImpulse) == 0x000584, "Member 'AFirearm::BulletCaseImpulse' has a wrong offset!");
static_assert(offsetof(AFirearm, BulletCaseSpawnDelay) == 0x000588, "Member 'AFirearm::BulletCaseSpawnDelay' has a wrong offset!");
static_assert(offsetof(AFirearm, MuzzleScaleOnADS) == 0x00058C, "Member 'AFirearm::MuzzleScaleOnADS' has a wrong offset!");
static_assert(offsetof(AFirearm, MuzzleSocketName) == 0x000590, "Member 'AFirearm::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(AFirearm, BulletCaseClass) == 0x000598, "Member 'AFirearm::BulletCaseClass' has a wrong offset!");
static_assert(offsetof(AFirearm, ProjectileExtraVisual) == 0x0005A0, "Member 'AFirearm::ProjectileExtraVisual' has a wrong offset!");
static_assert(offsetof(AFirearm, MuzzleFlash) == 0x0005A8, "Member 'AFirearm::MuzzleFlash' has a wrong offset!");
static_assert(offsetof(AFirearm, FireSound) == 0x0005B0, "Member 'AFirearm::FireSound' has a wrong offset!");
static_assert(offsetof(AFirearm, LastBulletFireSound) == 0x000608, "Member 'AFirearm::LastBulletFireSound' has a wrong offset!");
static_assert(offsetof(AFirearm, ReloadSound) == 0x000660, "Member 'AFirearm::ReloadSound' has a wrong offset!");
static_assert(offsetof(AFirearm, FireModeChangeSound) == 0x0006B8, "Member 'AFirearm::FireModeChangeSound' has a wrong offset!");
static_assert(offsetof(AFirearm, NoBulletsSound) == 0x000710, "Member 'AFirearm::NoBulletsSound' has a wrong offset!");
static_assert(offsetof(AFirearm, FirearmAkComponent) == 0x000768, "Member 'AFirearm::FirearmAkComponent' has a wrong offset!");
static_assert(offsetof(AFirearm, ReloadAkComponent) == 0x000770, "Member 'AFirearm::ReloadAkComponent' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentWeaponFeel) == 0x000778, "Member 'AFirearm::CurrentWeaponFeel' has a wrong offset!");
static_assert(offsetof(AFirearm, ADSFOV) == 0x0007D8, "Member 'AFirearm::ADSFOV' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentAdsFoV) == 0x0007DC, "Member 'AFirearm::CurrentAdsFoV' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentFireTimer) == 0x0007E0, "Member 'AFirearm::CurrentFireTimer' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentBurstTimer) == 0x0007E4, "Member 'AFirearm::CurrentBurstTimer' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentFiringMode) == 0x0007E8, "Member 'AFirearm::CurrentFiringMode' has a wrong offset!");
static_assert(offsetof(AFirearm, IsFiring) == 0x0007EC, "Member 'AFirearm::IsFiring' has a wrong offset!");
static_assert(offsetof(AFirearm, IsLockedBySemiMode) == 0x0007ED, "Member 'AFirearm::IsLockedBySemiMode' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentBurstShot) == 0x0007F0, "Member 'AFirearm::CurrentBurstShot' has a wrong offset!");
static_assert(offsetof(AFirearm, FiringModes) == 0x0007F8, "Member 'AFirearm::FiringModes' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentChamberTimer) == 0x000808, "Member 'AFirearm::CurrentChamberTimer' has a wrong offset!");
static_assert(offsetof(AFirearm, ChamberTimeDuration) == 0x00080C, "Member 'AFirearm::ChamberTimeDuration' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentTriggeringTimer) == 0x000810, "Member 'AFirearm::CurrentTriggeringTimer' has a wrong offset!");
static_assert(offsetof(AFirearm, bChambered) == 0x000814, "Member 'AFirearm::bChambered' has a wrong offset!");
static_assert(offsetof(AFirearm, FireRate) == 0x000818, "Member 'AFirearm::FireRate' has a wrong offset!");
static_assert(offsetof(AFirearm, MuzzleSpeed) == 0x00081C, "Member 'AFirearm::MuzzleSpeed' has a wrong offset!");
static_assert(offsetof(AFirearm, VelocityDamageScale) == 0x000820, "Member 'AFirearm::VelocityDamageScale' has a wrong offset!");
static_assert(offsetof(AFirearm, ProjectileClass) == 0x000828, "Member 'AFirearm::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AFirearm, Drag) == 0x000830, "Member 'AFirearm::Drag' has a wrong offset!");
static_assert(offsetof(AFirearm, GravityScale) == 0x000834, "Member 'AFirearm::GravityScale' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentReloadTimer) == 0x000838, "Member 'AFirearm::CurrentReloadTimer' has a wrong offset!");
static_assert(offsetof(AFirearm, AmmoClass) == 0x000840, "Member 'AFirearm::AmmoClass' has a wrong offset!");
static_assert(offsetof(AFirearm, CurrentAmmo) == 0x000848, "Member 'AFirearm::CurrentAmmo' has a wrong offset!");
static_assert(offsetof(AFirearm, ClipSize) == 0x00084C, "Member 'AFirearm::ClipSize' has a wrong offset!");
static_assert(offsetof(AFirearm, ReloadTime) == 0x000850, "Member 'AFirearm::ReloadTime' has a wrong offset!");
static_assert(offsetof(AFirearm, ReloadCockTime) == 0x000854, "Member 'AFirearm::ReloadCockTime' has a wrong offset!");
static_assert(offsetof(AFirearm, ReloadModeClip) == 0x000858, "Member 'AFirearm::ReloadModeClip' has a wrong offset!");
static_assert(offsetof(AFirearm, AutoReload) == 0x000859, "Member 'AFirearm::AutoReload' has a wrong offset!");
static_assert(offsetof(AFirearm, IsReloading) == 0x00085A, "Member 'AFirearm::IsReloading' has a wrong offset!");

// Class UnrealProject.GainCurveFirearmFeelComponent
// 0x0018 (0x0168 - 0x0150)
class UGainCurveFirearmFeelComponent : public UGainFirearmFeelComponent
{
public:
	struct FLinearScalableCurve                   Curve;                                             // 0x0150(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GainCurveFirearmFeelComponent">();
	}
	static class UGainCurveFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGainCurveFirearmFeelComponent>();
	}
};
static_assert(alignof(UGainCurveFirearmFeelComponent) == 0x000008, "Wrong alignment on UGainCurveFirearmFeelComponent");
static_assert(sizeof(UGainCurveFirearmFeelComponent) == 0x000168, "Wrong size on UGainCurveFirearmFeelComponent");
static_assert(offsetof(UGainCurveFirearmFeelComponent, Curve) == 0x000150, "Member 'UGainCurveFirearmFeelComponent::Curve' has a wrong offset!");

// Class UnrealProject.HealingConsumable
// 0x0008 (0x0330 - 0x0328)
class AHealingConsumable final : public AConsumable
{
public:
	float                                         HealingAmmount;                                    // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealingLimit;                                      // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealingConsumable">();
	}
	static class AHealingConsumable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHealingConsumable>();
	}
};
static_assert(alignof(AHealingConsumable) == 0x000008, "Wrong alignment on AHealingConsumable");
static_assert(sizeof(AHealingConsumable) == 0x000330, "Wrong size on AHealingConsumable");
static_assert(offsetof(AHealingConsumable, HealingAmmount) == 0x000328, "Member 'AHealingConsumable::HealingAmmount' has a wrong offset!");
static_assert(offsetof(AHealingConsumable, HealingLimit) == 0x00032C, "Member 'AHealingConsumable::HealingLimit' has a wrong offset!");

// Class UnrealProject.HGSpectatorPawn
// 0x0018 (0x02B8 - 0x02A0)
class AHGSpectatorPawn final : public ASpectatorPawn
{
public:
	float                                         TargetInterpPosSpeed;                              // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetInterpRotSpeed;                              // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ADSInterpModifier;                                 // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANGDCharacter*                          TargetToSpectate;                                  // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HGSpectatorPawn">();
	}
	static class AHGSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHGSpectatorPawn>();
	}
};
static_assert(alignof(AHGSpectatorPawn) == 0x000008, "Wrong alignment on AHGSpectatorPawn");
static_assert(sizeof(AHGSpectatorPawn) == 0x0002B8, "Wrong size on AHGSpectatorPawn");
static_assert(offsetof(AHGSpectatorPawn, TargetInterpPosSpeed) == 0x0002A0, "Member 'AHGSpectatorPawn::TargetInterpPosSpeed' has a wrong offset!");
static_assert(offsetof(AHGSpectatorPawn, TargetInterpRotSpeed) == 0x0002A4, "Member 'AHGSpectatorPawn::TargetInterpRotSpeed' has a wrong offset!");
static_assert(offsetof(AHGSpectatorPawn, ADSInterpModifier) == 0x0002A8, "Member 'AHGSpectatorPawn::ADSInterpModifier' has a wrong offset!");
static_assert(offsetof(AHGSpectatorPawn, TargetToSpectate) == 0x0002B0, "Member 'AHGSpectatorPawn::TargetToSpectate' has a wrong offset!");

// Class UnrealProject.InventoryComponent
// 0x0058 (0x0108 - 0x00B0)
class UInventoryComponent final : public UActorComponent
{
public:
	TArray<struct FEquipmentSlot>                 EquipmentSlots;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDefaultItemConfig>             DefaultItems;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         BaseCapacity;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemPickup>                LootBoxClass;                                      // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AItem*>                          Items;                                             // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FActiveWeaponData                      ActiveWeaponData;                                  // 0x00F0(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AConsumable*                            ActiveConsumable;                                  // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 DestroyItem(class AItem* Item, int32 Quantity);
	int32 DestroyItemsOfClass(TSubclassOf<class AItem> ItemClass, int32 Quantity);
	int32 GetPotencialEquipmentSlotIndex(class AEquipment* Equipment);
	void ServerAcquireEquipment(class AEquipment* Item, int32 SlotIndex);
	void ServerAcquireItem(class AItem* Item);
	void ServerDestroyAllItems();
	void ServerDestroyItem(class AItem* Item, int32 Quantity);
	void ServerDestroyItemsOfClass(TSubclassOf<class AItem> ItemClass, int32 Quantity);
	void ServerDropAllItems();
	void ServerDropItem(class AItem* Item, int32 Quantity);
	void ServerEquip(class AEquipment* InEquipment, int32 InSlotIndex);
	void ServerPickupItem(class AItemPickup* ItemPickup, class AItem* Item, int32 Quantity);
	void ServerPickupItems(class AItemPickup* ItemPickup);
	void ServerSetActiveWeapon(class AWeapon* InWeapon, bool bSetLastActiveWeapon);
	void ServerSwapItems(int32 IndexA, int32 IndexB);
	void ServerUnequip(class AEquipment* InEquipment);

	class AWeapon* GetActiveWeapon() const;
	class AConsumable* GetConsumingItem() const;
	class AEquipment* GetEquipmentBySlotType(const class FString& SlotType) const;
	const TArray<struct FEquipmentSlot> GetEquipmentSlots() const;
	float GetFreeCapacity() const;
	class AItem* GetItemOfClass(TSubclassOf<class AItem> ItemClass) const;
	int32 GetItemQuantityByClass(TSubclassOf<class AItem> ItemClass) const;
	TArray<class AItem*> GetItemsOfClass(TSubclassOf<class AItem> ItemClass) const;
	class AWeapon* GetLastActiveWeapon() const;
	class ANGDCharacter* GetOwnerCharacter() const;
	int32 GetSlotIndexOfEquipmentSlot(const struct FEquipmentSlot& InEquipmentSlot) const;
	float GetTakenCapacity() const;
	float GetTotalCapacity() const;
	bool IsConsumingItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x000108, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, EquipmentSlots) == 0x0000B0, "Member 'UInventoryComponent::EquipmentSlots' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, DefaultItems) == 0x0000C0, "Member 'UInventoryComponent::DefaultItems' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, BaseCapacity) == 0x0000D0, "Member 'UInventoryComponent::BaseCapacity' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LootBoxClass) == 0x0000D8, "Member 'UInventoryComponent::LootBoxClass' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, Items) == 0x0000E0, "Member 'UInventoryComponent::Items' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ActiveWeaponData) == 0x0000F0, "Member 'UInventoryComponent::ActiveWeaponData' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ActiveConsumable) == 0x000100, "Member 'UInventoryComponent::ActiveConsumable' has a wrong offset!");

// Class UnrealProject.ItemPickup
// 0x0018 (0x0250 - 0x0238)
class AItemPickup final : public ANGDInteractableActor
{
public:
	class UStaticMeshComponent*                   PickupMesh;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AItem*>                          Items;                                             // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPickup">();
	}
	static class AItemPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemPickup>();
	}
};
static_assert(alignof(AItemPickup) == 0x000008, "Wrong alignment on AItemPickup");
static_assert(sizeof(AItemPickup) == 0x000250, "Wrong size on AItemPickup");
static_assert(offsetof(AItemPickup, PickupMesh) == 0x000238, "Member 'AItemPickup::PickupMesh' has a wrong offset!");
static_assert(offsetof(AItemPickup, Items) == 0x000240, "Member 'AItemPickup::Items' has a wrong offset!");

// Class UnrealProject.KickFirearmFeelComponent
// 0x0068 (0x01A0 - 0x0138)
class UKickFirearmFeelComponent final : public UBaseFirearmFeelComponent
{
public:
	class UCurveFloat*                            KickCurve;                                         // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickRecoveryStartTime;                             // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickDuration;                                      // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickInDegrees;                                     // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickClampFactor;                                   // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawRange;                                          // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawTendency;                                       // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickToControllerFactor;                            // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickToFireDirectionFactor;                         // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickToWeaponIKFactor;                              // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickYawToCameraRollFactor;                         // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x38];                                     // 0x0168(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KickFirearmFeelComponent">();
	}
	static class UKickFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKickFirearmFeelComponent>();
	}
};
static_assert(alignof(UKickFirearmFeelComponent) == 0x000008, "Wrong alignment on UKickFirearmFeelComponent");
static_assert(sizeof(UKickFirearmFeelComponent) == 0x0001A0, "Wrong size on UKickFirearmFeelComponent");
static_assert(offsetof(UKickFirearmFeelComponent, KickCurve) == 0x000138, "Member 'UKickFirearmFeelComponent::KickCurve' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, KickRecoveryStartTime) == 0x000140, "Member 'UKickFirearmFeelComponent::KickRecoveryStartTime' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, KickDuration) == 0x000144, "Member 'UKickFirearmFeelComponent::KickDuration' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, KickInDegrees) == 0x000148, "Member 'UKickFirearmFeelComponent::KickInDegrees' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, KickClampFactor) == 0x00014C, "Member 'UKickFirearmFeelComponent::KickClampFactor' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, YawRange) == 0x000150, "Member 'UKickFirearmFeelComponent::YawRange' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, YawTendency) == 0x000154, "Member 'UKickFirearmFeelComponent::YawTendency' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, KickToControllerFactor) == 0x000158, "Member 'UKickFirearmFeelComponent::KickToControllerFactor' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, KickToFireDirectionFactor) == 0x00015C, "Member 'UKickFirearmFeelComponent::KickToFireDirectionFactor' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, KickToWeaponIKFactor) == 0x000160, "Member 'UKickFirearmFeelComponent::KickToWeaponIKFactor' has a wrong offset!");
static_assert(offsetof(UKickFirearmFeelComponent, KickYawToCameraRollFactor) == 0x000164, "Member 'UKickFirearmFeelComponent::KickYawToCameraRollFactor' has a wrong offset!");

// Class UnrealProject.LootSpawn
// 0x0010 (0x0240 - 0x0230)
class ALootSpawn final : public ABaseActor
{
public:
	TSubclassOf<class AItem>                      ItemToSpawn;                                       // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Quantity;                                          // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootSpawn">();
	}
	static class ALootSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALootSpawn>();
	}
};
static_assert(alignof(ALootSpawn) == 0x000008, "Wrong alignment on ALootSpawn");
static_assert(sizeof(ALootSpawn) == 0x000240, "Wrong size on ALootSpawn");
static_assert(offsetof(ALootSpawn, ItemToSpawn) == 0x000230, "Member 'ALootSpawn::ItemToSpawn' has a wrong offset!");
static_assert(offsetof(ALootSpawn, Quantity) == 0x000238, "Member 'ALootSpawn::Quantity' has a wrong offset!");

// Class UnrealProject.MagazineAttachment
// 0x0070 (0x0410 - 0x03A0)
class AMagazineAttachment final : public AFirearmAttachment
{
public:
	struct FMagazineAttachmentConfig              DefaultMagazineAttachmentConfig;                   // 0x03A0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class AFirearm>, struct FMagazineAttachmentConfig> MagazineConfigs;             // 0x03C0(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnReloadStep(EMagazineReloadStep ReloadStep, bool bAttachToWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagazineAttachment">();
	}
	static class AMagazineAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagazineAttachment>();
	}
};
static_assert(alignof(AMagazineAttachment) == 0x000010, "Wrong alignment on AMagazineAttachment");
static_assert(sizeof(AMagazineAttachment) == 0x000410, "Wrong size on AMagazineAttachment");
static_assert(offsetof(AMagazineAttachment, DefaultMagazineAttachmentConfig) == 0x0003A0, "Member 'AMagazineAttachment::DefaultMagazineAttachmentConfig' has a wrong offset!");
static_assert(offsetof(AMagazineAttachment, MagazineConfigs) == 0x0003C0, "Member 'AMagazineAttachment::MagazineConfigs' has a wrong offset!");

// Class UnrealProject.MeleeWeapon
// 0x00B0 (0x0610 - 0x0560)
class AMeleeWeapon final : public AWeapon
{
public:
	class UNGDPhysicalMaterial*                   DefaultImpactMaterial;                             // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          HitCollider;                                       // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannelForCollision;                          // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LineTraceStartSocketName;                          // 0x0574(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LineTraceDistanceInMeters;                         // 0x057C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFiring;                                          // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x3];                                      // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireRate;                                          // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwingDuration;                                     // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwingStartTime;                                    // 0x058C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwingEndTime;                                      // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanHitMultipleTargets;                             // 0x0594(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_595[0x7B];                                     // 0x0595(0x007B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanHitTargets();
	bool IsSwinging();
	void OnHit(const struct FHitResult& InHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeWeapon">();
	}
	static class AMeleeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeleeWeapon>();
	}
};
static_assert(alignof(AMeleeWeapon) == 0x000010, "Wrong alignment on AMeleeWeapon");
static_assert(sizeof(AMeleeWeapon) == 0x000610, "Wrong size on AMeleeWeapon");
static_assert(offsetof(AMeleeWeapon, DefaultImpactMaterial) == 0x000560, "Member 'AMeleeWeapon::DefaultImpactMaterial' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, HitCollider) == 0x000568, "Member 'AMeleeWeapon::HitCollider' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, TraceChannelForCollision) == 0x000570, "Member 'AMeleeWeapon::TraceChannelForCollision' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, LineTraceStartSocketName) == 0x000574, "Member 'AMeleeWeapon::LineTraceStartSocketName' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, LineTraceDistanceInMeters) == 0x00057C, "Member 'AMeleeWeapon::LineTraceDistanceInMeters' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, IsFiring) == 0x000580, "Member 'AMeleeWeapon::IsFiring' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, FireRate) == 0x000584, "Member 'AMeleeWeapon::FireRate' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, SwingDuration) == 0x000588, "Member 'AMeleeWeapon::SwingDuration' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, SwingStartTime) == 0x00058C, "Member 'AMeleeWeapon::SwingStartTime' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, SwingEndTime) == 0x000590, "Member 'AMeleeWeapon::SwingEndTime' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, CanHitMultipleTargets) == 0x000594, "Member 'AMeleeWeapon::CanHitMultipleTargets' has a wrong offset!");

// Class UnrealProject.MuzzleAttachment
// 0x00B0 (0x0450 - 0x03A0)
class AMuzzleAttachment final : public AFirearmAttachment
{
public:
	TMap<TSubclassOf<class AFirearm>, struct FAttachmentMuzzleConfig> FireMuzzleConfigs;             // 0x03A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAttachmentMuzzleConfig                DefaultFireMuzzleConfig;                           // 0x03F0(0x0060)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MuzzleAttachment">();
	}
	static class AMuzzleAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMuzzleAttachment>();
	}
};
static_assert(alignof(AMuzzleAttachment) == 0x000010, "Wrong alignment on AMuzzleAttachment");
static_assert(sizeof(AMuzzleAttachment) == 0x000450, "Wrong size on AMuzzleAttachment");
static_assert(offsetof(AMuzzleAttachment, FireMuzzleConfigs) == 0x0003A0, "Member 'AMuzzleAttachment::FireMuzzleConfigs' has a wrong offset!");
static_assert(offsetof(AMuzzleAttachment, DefaultFireMuzzleConfig) == 0x0003F0, "Member 'AMuzzleAttachment::DefaultFireMuzzleConfig' has a wrong offset!");

// Class UnrealProject.NGDAIController
// 0x0020 (0x0340 - 0x0320)
class ANGDAIController final : public AAIController
{
public:
	EBotStates                                    BotState;                                          // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelTime;                                        // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpTime;                                          // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x14];                                     // 0x032C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDAIController">();
	}
	static class ANGDAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDAIController>();
	}
};
static_assert(alignof(ANGDAIController) == 0x000008, "Wrong alignment on ANGDAIController");
static_assert(sizeof(ANGDAIController) == 0x000340, "Wrong size on ANGDAIController");
static_assert(offsetof(ANGDAIController, BotState) == 0x000320, "Member 'ANGDAIController::BotState' has a wrong offset!");
static_assert(offsetof(ANGDAIController, TravelTime) == 0x000324, "Member 'ANGDAIController::TravelTime' has a wrong offset!");
static_assert(offsetof(ANGDAIController, JumpTime) == 0x000328, "Member 'ANGDAIController::JumpTime' has a wrong offset!");

// Class UnrealProject.NGDAkComponentCarEngine
// 0x0030 (0x0410 - 0x03E0)
class UNGDAkComponentCarEngine final : public UNGDAkComponent
{
public:
	class FString                                 RTCPRPMName;                                       // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RTCPBuggyDistanceName;                             // 0x03F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRTCPOutput;                                     // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRTCPOutput;                                     // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDAkComponentCarEngine">();
	}
	static class UNGDAkComponentCarEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDAkComponentCarEngine>();
	}
};
static_assert(alignof(UNGDAkComponentCarEngine) == 0x000010, "Wrong alignment on UNGDAkComponentCarEngine");
static_assert(sizeof(UNGDAkComponentCarEngine) == 0x000410, "Wrong size on UNGDAkComponentCarEngine");
static_assert(offsetof(UNGDAkComponentCarEngine, RTCPRPMName) == 0x0003E0, "Member 'UNGDAkComponentCarEngine::RTCPRPMName' has a wrong offset!");
static_assert(offsetof(UNGDAkComponentCarEngine, RTCPBuggyDistanceName) == 0x0003F0, "Member 'UNGDAkComponentCarEngine::RTCPBuggyDistanceName' has a wrong offset!");
static_assert(offsetof(UNGDAkComponentCarEngine, MinDistance) == 0x000400, "Member 'UNGDAkComponentCarEngine::MinDistance' has a wrong offset!");
static_assert(offsetof(UNGDAkComponentCarEngine, MaxDistance) == 0x000404, "Member 'UNGDAkComponentCarEngine::MaxDistance' has a wrong offset!");
static_assert(offsetof(UNGDAkComponentCarEngine, MinRTCPOutput) == 0x000408, "Member 'UNGDAkComponentCarEngine::MinRTCPOutput' has a wrong offset!");
static_assert(offsetof(UNGDAkComponentCarEngine, MaxRTCPOutput) == 0x00040C, "Member 'UNGDAkComponentCarEngine::MaxRTCPOutput' has a wrong offset!");

// Class UnrealProject.NGDAkListener
// 0x0000 (0x03D0 - 0x03D0)
class UNGDAkListener final : public UAkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDAkListener">();
	}
	static class UNGDAkListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDAkListener>();
	}
};
static_assert(alignof(UNGDAkListener) == 0x000010, "Wrong alignment on UNGDAkListener");
static_assert(sizeof(UNGDAkListener) == 0x0003D0, "Wrong size on UNGDAkListener");

// Class UnrealProject.NGDAudio
// 0x0000 (0x0028 - 0x0028)
class UNGDAudio final : public UBlueprintFunctionLibrary
{
public:
	static int32 PostCallbackableAssociatedEvent(class UNGDAkComponent* InAkComponent, const struct FPostSoundParams& Params_0);
	static class UNGDAkComponent* PostSound(const struct FNGDSoundConfig& InAudioConfig, const struct FVector& InPosition, class AActor* InContext, bool InAutoPost, bool InAutoDestroy, class UNGDAkComponent* AkComponentToPostFrom, const struct FRotator& InRotation);
	static class UNGDAkComponent* PostSoundWithParams(const struct FPostSoundParams& Params_0);
	static class UNGDAkComponent* PostSoundWithSwitch(const struct FNGDSoundConfig& InAudioConfig, const struct FVector& InPosition, class AActor* InContext, const struct FNGDSoundSwitch& AdditionalSwitches, bool InAutoPost, bool InAutoDestroy, class UNGDAkComponent* AkComponentToPostFrom, const struct FRotator& InRotation);
	static class UNGDAkComponent* PostSoundWithSwitches(const struct FNGDSoundConfig& InAudioConfig, const struct FVector& InPosition, class AActor* InContext, const TArray<struct FNGDSoundSwitch>& AdditionalSwitches, bool InAutoPost, bool InAutoDestroy, class UNGDAkComponent* AkComponentToPostFrom, const struct FRotator& InRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDAudio">();
	}
	static class UNGDAudio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDAudio>();
	}
};
static_assert(alignof(UNGDAudio) == 0x000008, "Wrong alignment on UNGDAudio");
static_assert(sizeof(UNGDAudio) == 0x000028, "Wrong size on UNGDAudio");

// Class UnrealProject.NGDBodyPart
// 0x0008 (0x0030 - 0x0028)
class UNGDBodyPart : public UObject
{
public:
	float                                         DamageModifier;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDBodyPart">();
	}
	static class UNGDBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDBodyPart>();
	}
};
static_assert(alignof(UNGDBodyPart) == 0x000008, "Wrong alignment on UNGDBodyPart");
static_assert(sizeof(UNGDBodyPart) == 0x000030, "Wrong size on UNGDBodyPart");
static_assert(offsetof(UNGDBodyPart, DamageModifier) == 0x000028, "Member 'UNGDBodyPart::DamageModifier' has a wrong offset!");

// Class UnrealProject.NGDCharacter
// 0x02E0 (0x0910 - 0x0630)
class ANGDCharacter : public ACharacter
{
public:
	uint8                                         Pad_628[0x10];                                     // 0x0628(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MeshTP;                                            // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayTestComponent*                     PlayTestComponent;                                 // 0x0640(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PlayerName;                                        // 0x0648(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusFOVAnimProgress;                              // 0x0658(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65C[0x8];                                      // 0x065C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToAddWarningIntensity;                         // 0x0664(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WarningIntensityDecrease;                          // 0x0668(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      ShotDetectionCollider;                             // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_678[0x4];                                      // 0x0678(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootstepsRelevantDistance;                         // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootstepsMaxRate;                                  // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootstepsTraceOffset;                              // 0x0684(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootstepsTraceLength;                              // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68C[0x4];                                      // 0x068C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDPhysicalMaterial*                   DefaultFootstepsPhysicalMaterial;                  // 0x0690(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 BlockedShootDecalInstance;                         // 0x0698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDAkComponent*                        FootstepsAkComponent;                              // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        SoundConfig_OnSlideStart;                          // 0x06A8(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FNGDSoundConfig                        SoundConfig_OnSlideEnd;                            // 0x0700(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ADecalActor>                BlockedShootDecal;                                 // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float ForwardBackDirection, float RightLeftDirection, float Intensity)> OnShotPassedNearbyEvent; // 0x0760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsInsideBuilding;                                 // 0x0770(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_771[0x3];                                      // 0x0771(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseSensitivity;                                  // 0x0774(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScopeSensitivity;                                  // 0x0778(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDCameraComponent*                    CameraComponent;                                   // 0x0780(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantsFirstPerson;                                 // 0x0788(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_789[0x7];                                      // 0x0789(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool BoolParam)> OnFreeLookingEvent;                               // 0x0790(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A0[0x18];                                     // 0x07A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnToggleFireMode;                                  // 0x07B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C8[0x14];                                     // 0x07C8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneMaxPitch;                                     // 0x07DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProneMinPitch;                                     // 0x07E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintMaxDeltaAngleDeg;                            // 0x07E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultMaxPitch;                                   // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultMinPitch;                                   // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchLerpSpeed;                                   // 0x07F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandLerpSpeed;                                    // 0x07F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENGDCharacterLocomotionFlags                  LocomotionFlags;                                   // 0x07F8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENGDCharacterExtraFlags                       ExtraFlags;                                        // 0x07F9(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7FA[0x6];                                      // 0x07FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDCharacterMovementComponent*         NGDCharacterMovement;                              // 0x0800(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ControllerRotation;                                // 0x0808(0x000C)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_814[0x4];                                      // 0x0814(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FControllerRotationData>        ControllerRotationsCache;                          // 0x0818(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_828[0x10];                                     // 0x0828(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsProned : 1;                                     // 0x0838(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_839[0x7];                                      // 0x0839(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedBeforeCancelConsumable;                    // 0x0840(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_844[0x4];                                      // 0x0844(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDInteractionComponent*               InteractionComponent;                              // 0x0848(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryComponent*                    InventoryComponent;                                // 0x0850(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class FName>                SocketBoneBodyNameMap;                             // 0x0858(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A8[0x8];                                      // 0x08A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  BoardedVehicle;                                    // 0x08B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUnBoardContract                       AcceptedUnBoardContract;                           // 0x08B8(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoardContract                         AcceptedBoardContract;                             // 0x08D0(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      RewindCollider;                                    // 0x08E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HitRegistrationCollider;                           // 0x08E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDRewindComponent*                    RewindComponent;                                   // 0x08F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDPostUpdateWorkComponent*            NGDPostUpdateWorkComponent;                        // 0x08F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDMortalityComponent*                 MortalityComponent;                                // 0x0900(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityVectorLerpSpeed;                           // 0x0908(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedVerticalLerpSpeed;                            // 0x090C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClientOnAcceptBoardContract(const struct FBoardContract& InBoardContract);
	void ClientOnAcceptUnBoardContract(const struct FUnBoardContract& InUnBoardContract);
	void ClientOnFailBoardContract(const class FString& ErrorStr);
	void ClientOnFailUnBoardContract(const class FString& ErrorStr);
	void InterruptCastings();
	void Kill(class ANGDCharacter* Character, struct FNGDDamageEvent* DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void MoveForward(float Value);
	void MoveRight(float Value);
	void MulticastOnDeath(const struct FNGDDamageEvent& DamageEvent, class ANGDCharacter* EventInstigator, class AActor* DamageCauser);
	void OnAnimNotifySwitchWeapons();
	void OnCameraChanged();
	void OnDeath(const struct FNGDDamageEvent& DamageEvent, class AController* InstigatorController, class AActor* DamageCauser);
	void OnDeathCosmetics(const struct FNGDDamageEvent& DamageEvent, class ANGDCharacter* EventInstigator, class AActor* DamageCauser);
	void OnPostUpdateWorkTick();
	void OnRep_BoardContract(const struct FBoardContract& LastBoardContract);
	void OnRep_ControllerRotation(const struct FRotator& OldRotator);
	void OnRep_ExtraFlags(ENGDCharacterExtraFlags OldExtraFlag);
	void OnRep_IsProned();
	void OnRep_LocomotionFlags(ENGDCharacterLocomotionFlags OldLocomotionFlag);
	void OnRep_UnBoardContract(const struct FUnBoardContract& LastUnBoardContract);
	void OnStartAim();
	void OnStartFire();
	void OnStopAim();
	void OnStopFire();
	float OnTakeDamage(float Damage, const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void RefreshCharacterRotation(const struct FRotator& InRotationToSet);
	void Reload();
	void ServerRequestBoardContract(class APawn* Vehicle);
	void ServerRequestUnBoardContract(class APawn* Vehicle);
	void SetMouseSensitivity(float InMouseSensitivity);
	void SetScopeSensitivity(float InScopeSensitivity);
	void UpdateAnimData(class UNGDCharacterAnimInstance* Instance);

	const ENGDCharacterExtraFlags GetExtraFlags() const;
	class UCapsuleComponent* GetHitRegistrationCollider() const;
	const ENGDCharacterLocomotionFlags GetLocomotionFlags() const;
	class UNGDMortalityComponent* GetMortalityComponent() const;
	struct FVector GetMovementInputVector() const;
	class UMeshComponent* GetRewindableMeshComponent() const;
	class UCapsuleComponent* GetRewindCollider() const;
	class UNGDRewindComponent* GetRewindComponent() const;
	class FString GetWWiseActorGroupSwitchValue() const;
	bool IsADS() const;
	bool IsBoarded() const;
	bool IsConsuming() const;
	bool IsCrouched() const;
	bool IsFalling() const;
	bool IsFiring() const;
	bool IsFirstPerson() const;
	bool IsFlagCrouching() const;
	bool IsFlagJumping() const;
	bool IsFlagReloading() const;
	bool IsFlagWeaponDrawed() const;
	bool IsFlying() const;
	bool IsFocusing() const;
	bool IsFreeLooking() const;
	bool IsInsideBuilding() const;
	bool IsInventoryOpen() const;
	bool IsLeaningLeft() const;
	bool IsLeaningRight() const;
	bool IsLocalPlayer() const;
	bool IsProning() const;
	bool IsReloading() const;
	bool IsRewindRelevant() const;
	bool IsSliding() const;
	bool IsSlowDown() const;
	bool IsSprinting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDCharacter">();
	}
	static class ANGDCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDCharacter>();
	}
};
static_assert(alignof(ANGDCharacter) == 0x000010, "Wrong alignment on ANGDCharacter");
static_assert(sizeof(ANGDCharacter) == 0x000910, "Wrong size on ANGDCharacter");
static_assert(offsetof(ANGDCharacter, MeshTP) == 0x000638, "Member 'ANGDCharacter::MeshTP' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, PlayTestComponent) == 0x000640, "Member 'ANGDCharacter::PlayTestComponent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, PlayerName) == 0x000648, "Member 'ANGDCharacter::PlayerName' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, FocusFOVAnimProgress) == 0x000658, "Member 'ANGDCharacter::FocusFOVAnimProgress' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, TimeToAddWarningIntensity) == 0x000664, "Member 'ANGDCharacter::TimeToAddWarningIntensity' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, WarningIntensityDecrease) == 0x000668, "Member 'ANGDCharacter::WarningIntensityDecrease' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, ShotDetectionCollider) == 0x000670, "Member 'ANGDCharacter::ShotDetectionCollider' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, FootstepsRelevantDistance) == 0x00067C, "Member 'ANGDCharacter::FootstepsRelevantDistance' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, FootstepsMaxRate) == 0x000680, "Member 'ANGDCharacter::FootstepsMaxRate' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, FootstepsTraceOffset) == 0x000684, "Member 'ANGDCharacter::FootstepsTraceOffset' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, FootstepsTraceLength) == 0x000688, "Member 'ANGDCharacter::FootstepsTraceLength' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, DefaultFootstepsPhysicalMaterial) == 0x000690, "Member 'ANGDCharacter::DefaultFootstepsPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, BlockedShootDecalInstance) == 0x000698, "Member 'ANGDCharacter::BlockedShootDecalInstance' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, FootstepsAkComponent) == 0x0006A0, "Member 'ANGDCharacter::FootstepsAkComponent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, SoundConfig_OnSlideStart) == 0x0006A8, "Member 'ANGDCharacter::SoundConfig_OnSlideStart' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, SoundConfig_OnSlideEnd) == 0x000700, "Member 'ANGDCharacter::SoundConfig_OnSlideEnd' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, BlockedShootDecal) == 0x000758, "Member 'ANGDCharacter::BlockedShootDecal' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, OnShotPassedNearbyEvent) == 0x000760, "Member 'ANGDCharacter::OnShotPassedNearbyEvent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, bIsInsideBuilding) == 0x000770, "Member 'ANGDCharacter::bIsInsideBuilding' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, MouseSensitivity) == 0x000774, "Member 'ANGDCharacter::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, ScopeSensitivity) == 0x000778, "Member 'ANGDCharacter::ScopeSensitivity' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, CameraComponent) == 0x000780, "Member 'ANGDCharacter::CameraComponent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, bWantsFirstPerson) == 0x000788, "Member 'ANGDCharacter::bWantsFirstPerson' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, OnFreeLookingEvent) == 0x000790, "Member 'ANGDCharacter::OnFreeLookingEvent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, OnToggleFireMode) == 0x0007B8, "Member 'ANGDCharacter::OnToggleFireMode' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, ProneMaxPitch) == 0x0007DC, "Member 'ANGDCharacter::ProneMaxPitch' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, ProneMinPitch) == 0x0007E0, "Member 'ANGDCharacter::ProneMinPitch' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, SprintMaxDeltaAngleDeg) == 0x0007E4, "Member 'ANGDCharacter::SprintMaxDeltaAngleDeg' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, DefaultMaxPitch) == 0x0007E8, "Member 'ANGDCharacter::DefaultMaxPitch' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, DefaultMinPitch) == 0x0007EC, "Member 'ANGDCharacter::DefaultMinPitch' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, CrouchLerpSpeed) == 0x0007F0, "Member 'ANGDCharacter::CrouchLerpSpeed' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, StandLerpSpeed) == 0x0007F4, "Member 'ANGDCharacter::StandLerpSpeed' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, LocomotionFlags) == 0x0007F8, "Member 'ANGDCharacter::LocomotionFlags' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, ExtraFlags) == 0x0007F9, "Member 'ANGDCharacter::ExtraFlags' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, NGDCharacterMovement) == 0x000800, "Member 'ANGDCharacter::NGDCharacterMovement' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, ControllerRotation) == 0x000808, "Member 'ANGDCharacter::ControllerRotation' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, ControllerRotationsCache) == 0x000818, "Member 'ANGDCharacter::ControllerRotationsCache' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, MaxSpeedBeforeCancelConsumable) == 0x000840, "Member 'ANGDCharacter::MaxSpeedBeforeCancelConsumable' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, InteractionComponent) == 0x000848, "Member 'ANGDCharacter::InteractionComponent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, InventoryComponent) == 0x000850, "Member 'ANGDCharacter::InventoryComponent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, SocketBoneBodyNameMap) == 0x000858, "Member 'ANGDCharacter::SocketBoneBodyNameMap' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, BoardedVehicle) == 0x0008B0, "Member 'ANGDCharacter::BoardedVehicle' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, AcceptedUnBoardContract) == 0x0008B8, "Member 'ANGDCharacter::AcceptedUnBoardContract' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, AcceptedBoardContract) == 0x0008D0, "Member 'ANGDCharacter::AcceptedBoardContract' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, RewindCollider) == 0x0008E0, "Member 'ANGDCharacter::RewindCollider' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, HitRegistrationCollider) == 0x0008E8, "Member 'ANGDCharacter::HitRegistrationCollider' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, RewindComponent) == 0x0008F0, "Member 'ANGDCharacter::RewindComponent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, NGDPostUpdateWorkComponent) == 0x0008F8, "Member 'ANGDCharacter::NGDPostUpdateWorkComponent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, MortalityComponent) == 0x000900, "Member 'ANGDCharacter::MortalityComponent' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, VelocityVectorLerpSpeed) == 0x000908, "Member 'ANGDCharacter::VelocityVectorLerpSpeed' has a wrong offset!");
static_assert(offsetof(ANGDCharacter, SpeedVerticalLerpSpeed) == 0x00090C, "Member 'ANGDCharacter::SpeedVerticalLerpSpeed' has a wrong offset!");

// Class UnrealProject.NGDCharacterAnimInstance
// 0x0100 (0x0370 - 0x0270)
#pragma pack(push, 0x1)
class alignas(0x10) UNGDCharacterAnimInstance : public UNGDAnimInstance
{
public:
	uint8                                         CharacterLocomotionFlags;                          // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CharacterExtraFlags;                               // 0x0269(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         WeaponFlags;                                       // 0x026A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B[0x1];                                      // 0x026B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CharacterControllerRotation;                       // 0x026C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CharacterLegsRotation;                             // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CharacterVelocity;                                 // 0x0284(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WeaponKickRotation;                                // 0x0290(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                WeaponKickTranslation;                             // 0x029C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalPlayer;                                    // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponDrawed;                                     // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimationShouldShoot;                             // 0x02AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZValue;                                            // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralSpeed;                                      // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      VehicleAnimation;                                  // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDeltaTime;                                     // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnimationLocked;                                 // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTurningInPlace;                                  // 0x02C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6[0x2];                                      // 0x02C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VelocityVectorLerp;                                // 0x02C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedHorizontal;                                   // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedVertical;                                     // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAlpha;                                          // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdle;                                             // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpState;                                         // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reload;                                            // 0x02EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSprinting;                                       // 0x02ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalizedFallSpeed;                               // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIM_Vertical;                                      // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIM_Horizontal;                                    // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InSync;                                            // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD[0x3];                                      // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TurnAnim;                                          // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAnimAngleMax;                                  // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsMovingThresholdSpeed;                            // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityVectorLerpSpeed;                           // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedVerticalLerpSpeed;                            // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleSpeedThreshold;                                // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              JumpStateClampInBound;                             // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              JumpStateClampOutBound;                            // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAlphaBound;                                     // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAlphaLerpSpeed;                                 // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegsRotationLerpSpeed;                             // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              NormalizeFallSpeedClampInBound;                    // 0x0334(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              NormalizeFallSpeedClampOutBound;                   // 0x033C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanRotationRate;                                  // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeanRotationInBound;                               // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeanRotationOutBound;                              // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpeedHorizontalInBound;                            // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpeedHorizontalOutBound;                           // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CharacterHasExtraFlag(ENGDCharacterExtraFlags FlagToCheck);
	bool CharacterHasLocomotionFlag(ENGDCharacterLocomotionFlags FlagToCheck);
	class ANGDCharacter* GetOwnerCharacter();
	void OnFootstepEvent(bool isLeftFoot, bool isLanding);
	void OnWeaponDraw(class AWeapon* WeaponDrawed);
	void OnWeaponHolster(class AWeapon* WeaponHolsted);
	bool WeaponHasFlag(EItemFlags FlagToCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDCharacterAnimInstance">();
	}
	static class UNGDCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDCharacterAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNGDCharacterAnimInstance) == 0x000010, "Wrong alignment on UNGDCharacterAnimInstance");
static_assert(sizeof(UNGDCharacterAnimInstance) == 0x000370, "Wrong size on UNGDCharacterAnimInstance");
static_assert(offsetof(UNGDCharacterAnimInstance, CharacterLocomotionFlags) == 0x000268, "Member 'UNGDCharacterAnimInstance::CharacterLocomotionFlags' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, CharacterExtraFlags) == 0x000269, "Member 'UNGDCharacterAnimInstance::CharacterExtraFlags' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, WeaponFlags) == 0x00026A, "Member 'UNGDCharacterAnimInstance::WeaponFlags' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, CharacterControllerRotation) == 0x00026C, "Member 'UNGDCharacterAnimInstance::CharacterControllerRotation' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, CharacterLegsRotation) == 0x000278, "Member 'UNGDCharacterAnimInstance::CharacterLegsRotation' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, CharacterVelocity) == 0x000284, "Member 'UNGDCharacterAnimInstance::CharacterVelocity' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, WeaponKickRotation) == 0x000290, "Member 'UNGDCharacterAnimInstance::WeaponKickRotation' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, WeaponKickTranslation) == 0x00029C, "Member 'UNGDCharacterAnimInstance::WeaponKickTranslation' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, bIsLocalPlayer) == 0x0002A8, "Member 'UNGDCharacterAnimInstance::bIsLocalPlayer' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, bWeaponDrawed) == 0x0002A9, "Member 'UNGDCharacterAnimInstance::bWeaponDrawed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, bIsFalling) == 0x0002AA, "Member 'UNGDCharacterAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, bAnimationShouldShoot) == 0x0002AB, "Member 'UNGDCharacterAnimInstance::bAnimationShouldShoot' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, ZValue) == 0x0002AC, "Member 'UNGDCharacterAnimInstance::ZValue' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, LateralSpeed) == 0x0002B0, "Member 'UNGDCharacterAnimInstance::LateralSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, VehicleAnimation) == 0x0002B8, "Member 'UNGDCharacterAnimInstance::VehicleAnimation' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, AnimDeltaTime) == 0x0002C0, "Member 'UNGDCharacterAnimInstance::AnimDeltaTime' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, IsAnimationLocked) == 0x0002C4, "Member 'UNGDCharacterAnimInstance::IsAnimationLocked' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, IsTurningInPlace) == 0x0002C5, "Member 'UNGDCharacterAnimInstance::IsTurningInPlace' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, VelocityVectorLerp) == 0x0002C8, "Member 'UNGDCharacterAnimInstance::VelocityVectorLerp' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, SpeedHorizontal) == 0x0002D4, "Member 'UNGDCharacterAnimInstance::SpeedHorizontal' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, SpeedVertical) == 0x0002D8, "Member 'UNGDCharacterAnimInstance::SpeedVertical' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, AimAlpha) == 0x0002DC, "Member 'UNGDCharacterAnimInstance::AimAlpha' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, bIdle) == 0x0002E0, "Member 'UNGDCharacterAnimInstance::bIdle' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, JumpState) == 0x0002E4, "Member 'UNGDCharacterAnimInstance::JumpState' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, Direction) == 0x0002E8, "Member 'UNGDCharacterAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, Reload) == 0x0002EC, "Member 'UNGDCharacterAnimInstance::Reload' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, IsSprinting) == 0x0002ED, "Member 'UNGDCharacterAnimInstance::IsSprinting' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, NormalizedFallSpeed) == 0x0002F0, "Member 'UNGDCharacterAnimInstance::NormalizedFallSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, AIM_Vertical) == 0x0002F4, "Member 'UNGDCharacterAnimInstance::AIM_Vertical' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, AIM_Horizontal) == 0x0002F8, "Member 'UNGDCharacterAnimInstance::AIM_Horizontal' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, InSync) == 0x0002FC, "Member 'UNGDCharacterAnimInstance::InSync' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, TurnAnim) == 0x000300, "Member 'UNGDCharacterAnimInstance::TurnAnim' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, TurnAnimAngleMax) == 0x000304, "Member 'UNGDCharacterAnimInstance::TurnAnimAngleMax' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, IsMovingThresholdSpeed) == 0x000308, "Member 'UNGDCharacterAnimInstance::IsMovingThresholdSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, VelocityVectorLerpSpeed) == 0x00030C, "Member 'UNGDCharacterAnimInstance::VelocityVectorLerpSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, SpeedVerticalLerpSpeed) == 0x000310, "Member 'UNGDCharacterAnimInstance::SpeedVerticalLerpSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, IdleSpeedThreshold) == 0x000314, "Member 'UNGDCharacterAnimInstance::IdleSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, JumpStateClampInBound) == 0x000318, "Member 'UNGDCharacterAnimInstance::JumpStateClampInBound' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, JumpStateClampOutBound) == 0x000320, "Member 'UNGDCharacterAnimInstance::JumpStateClampOutBound' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, AimAlphaBound) == 0x000328, "Member 'UNGDCharacterAnimInstance::AimAlphaBound' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, AimAlphaLerpSpeed) == 0x00032C, "Member 'UNGDCharacterAnimInstance::AimAlphaLerpSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, LegsRotationLerpSpeed) == 0x000330, "Member 'UNGDCharacterAnimInstance::LegsRotationLerpSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, NormalizeFallSpeedClampInBound) == 0x000334, "Member 'UNGDCharacterAnimInstance::NormalizeFallSpeedClampInBound' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, NormalizeFallSpeedClampOutBound) == 0x00033C, "Member 'UNGDCharacterAnimInstance::NormalizeFallSpeedClampOutBound' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, LeanRotationRate) == 0x000344, "Member 'UNGDCharacterAnimInstance::LeanRotationRate' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, LeanRotationInBound) == 0x000348, "Member 'UNGDCharacterAnimInstance::LeanRotationInBound' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, LeanRotationOutBound) == 0x000350, "Member 'UNGDCharacterAnimInstance::LeanRotationOutBound' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, SpeedHorizontalInBound) == 0x000358, "Member 'UNGDCharacterAnimInstance::SpeedHorizontalInBound' has a wrong offset!");
static_assert(offsetof(UNGDCharacterAnimInstance, SpeedHorizontalOutBound) == 0x000360, "Member 'UNGDCharacterAnimInstance::SpeedHorizontalOutBound' has a wrong offset!");

// Class UnrealProject.NGDCharacterMovementComponent
// 0x0140 (0x0810 - 0x06D0)
#pragma pack(push, 0x1)
class alignas(0x10) UNGDCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         bWantsToProne : 1;                                 // 0x06D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSliding : 1;                                    // 0x06D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D1[0xB];                                      // 0x06D1(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThresholdToStartSlopeSpeedPenalty;                 // 0x06DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModifierPickingUpSpeed;                            // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModifierSlopeSpeed;                                // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStandSpeed;                                     // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStandAcceleration;                              // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlowStandSpeed;                                 // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlowStandAcceleration;                          // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFastStandSpeed;                                 // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFastStandAcceleration;                          // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCrouchSpeed;                                    // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCrouchAcceleration;                             // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlowCrouchSpeed;                                // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlowCrouchAcceleration;                         // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFastCrouchSpeed;                                // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFastCrouchAcceleration;                         // 0x0714(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneHeight;                                       // 0x0718(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneMeshOffset;                                   // 0x071C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxProneSpeed;                                     // 0x0720(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxProneAcceleration;                              // 0x0724(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlowProneSpeed;                                 // 0x0728(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlowProneAcceleration;                          // 0x072C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFastProneSpeed;                                 // 0x0730(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFastProneAcceleration;                          // 0x0734(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanSphereCheckerRadius;                           // 0x0738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanHorizontalOffset;                              // 0x073C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlideSprintDuration;                            // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlideSpeed;                                     // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlideSpeed;                                     // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlideAcceleration;                              // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHorizontalSpeed;                                // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideGravityScale;                                 // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SlideLaunchVelocityScalar;                         // 0x0758(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SlideEfficiencyScalar;                             // 0x0760(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideBrakingDeceleration;                          // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideGroundFriction;                               // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_770[0x4];                                      // 0x0770(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlideTimegapAfterSprint;                           // 0x0774(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSlideTimegapAfterSprint;                    // 0x0778(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidePenaltyDefaultCooldown;                       // 0x077C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_780[0x4];                                      // 0x0780(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlideSprintDuration;                               // 0x0784(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentMoveVector;                                 // 0x0788(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CurrentCharRotator;                                // 0x0794(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FallSpeed;                                         // 0x07A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LateralSpeed;                                      // 0x07A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredAngle;                                      // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunMoveVectorSpeed;                                // 0x07AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintMoveVectorSpeed;                             // 0x07B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunRotationSpeed;                                  // 0x07B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintRotationSpeed;                               // 0x07B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LegsRotationSpeed;                                 // 0x07BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LegsRotationVelocityThreshold;                     // 0x07C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallingMoveVectorSpeed;                            // 0x07C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFallingSpeed;                                   // 0x07C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFallingAcceleration;                            // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxGlideAngle;                                     // 0x07D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinGlideAngle;                                     // 0x07D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallSpeedSmoothFactor;                             // 0x07D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LateralSpeedSmoothFactor;                          // 0x07DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFallingDeltaSpeed;                              // 0x07E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidePercentFromForward;                           // 0x07E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LateralRotationAngle;                              // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallingScale;                                      // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalVelocityLimit;                             // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalJumpBrake;                                   // 0x07F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighJumpBrake;                                     // 0x07F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7FC[0x4];                                      // 0x07FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANGDCharacter*                          CastedCharacterOwner;                              // 0x0800(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ServerCustomMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint8 PendingExtraFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 NewExtraFlags, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode);
	void ServerCustomMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, uint8 OldMoveFlags, uint8 OldExtraFlags);
	void StartSlide();
	void StopSlide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDCharacterMovementComponent">();
	}
	static class UNGDCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDCharacterMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNGDCharacterMovementComponent) == 0x000010, "Wrong alignment on UNGDCharacterMovementComponent");
static_assert(sizeof(UNGDCharacterMovementComponent) == 0x000810, "Wrong size on UNGDCharacterMovementComponent");
static_assert(offsetof(UNGDCharacterMovementComponent, ThresholdToStartSlopeSpeedPenalty) == 0x0006DC, "Member 'UNGDCharacterMovementComponent::ThresholdToStartSlopeSpeedPenalty' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, ModifierPickingUpSpeed) == 0x0006E0, "Member 'UNGDCharacterMovementComponent::ModifierPickingUpSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, ModifierSlopeSpeed) == 0x0006E4, "Member 'UNGDCharacterMovementComponent::ModifierSlopeSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxStandSpeed) == 0x0006E8, "Member 'UNGDCharacterMovementComponent::MaxStandSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxStandAcceleration) == 0x0006EC, "Member 'UNGDCharacterMovementComponent::MaxStandAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxSlowStandSpeed) == 0x0006F0, "Member 'UNGDCharacterMovementComponent::MaxSlowStandSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxSlowStandAcceleration) == 0x0006F4, "Member 'UNGDCharacterMovementComponent::MaxSlowStandAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFastStandSpeed) == 0x0006F8, "Member 'UNGDCharacterMovementComponent::MaxFastStandSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFastStandAcceleration) == 0x0006FC, "Member 'UNGDCharacterMovementComponent::MaxFastStandAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxCrouchSpeed) == 0x000700, "Member 'UNGDCharacterMovementComponent::MaxCrouchSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxCrouchAcceleration) == 0x000704, "Member 'UNGDCharacterMovementComponent::MaxCrouchAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxSlowCrouchSpeed) == 0x000708, "Member 'UNGDCharacterMovementComponent::MaxSlowCrouchSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxSlowCrouchAcceleration) == 0x00070C, "Member 'UNGDCharacterMovementComponent::MaxSlowCrouchAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFastCrouchSpeed) == 0x000710, "Member 'UNGDCharacterMovementComponent::MaxFastCrouchSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFastCrouchAcceleration) == 0x000714, "Member 'UNGDCharacterMovementComponent::MaxFastCrouchAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, ProneHeight) == 0x000718, "Member 'UNGDCharacterMovementComponent::ProneHeight' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, ProneMeshOffset) == 0x00071C, "Member 'UNGDCharacterMovementComponent::ProneMeshOffset' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxProneSpeed) == 0x000720, "Member 'UNGDCharacterMovementComponent::MaxProneSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxProneAcceleration) == 0x000724, "Member 'UNGDCharacterMovementComponent::MaxProneAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxSlowProneSpeed) == 0x000728, "Member 'UNGDCharacterMovementComponent::MaxSlowProneSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxSlowProneAcceleration) == 0x00072C, "Member 'UNGDCharacterMovementComponent::MaxSlowProneAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFastProneSpeed) == 0x000730, "Member 'UNGDCharacterMovementComponent::MaxFastProneSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFastProneAcceleration) == 0x000734, "Member 'UNGDCharacterMovementComponent::MaxFastProneAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, LeanSphereCheckerRadius) == 0x000738, "Member 'UNGDCharacterMovementComponent::LeanSphereCheckerRadius' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, LeanHorizontalOffset) == 0x00073C, "Member 'UNGDCharacterMovementComponent::LeanHorizontalOffset' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MinSlideSprintDuration) == 0x000740, "Member 'UNGDCharacterMovementComponent::MinSlideSprintDuration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MinSlideSpeed) == 0x000744, "Member 'UNGDCharacterMovementComponent::MinSlideSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxSlideSpeed) == 0x000748, "Member 'UNGDCharacterMovementComponent::MaxSlideSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxSlideAcceleration) == 0x00074C, "Member 'UNGDCharacterMovementComponent::MaxSlideAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxHorizontalSpeed) == 0x000750, "Member 'UNGDCharacterMovementComponent::MaxHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlideGravityScale) == 0x000754, "Member 'UNGDCharacterMovementComponent::SlideGravityScale' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlideLaunchVelocityScalar) == 0x000758, "Member 'UNGDCharacterMovementComponent::SlideLaunchVelocityScalar' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlideEfficiencyScalar) == 0x000760, "Member 'UNGDCharacterMovementComponent::SlideEfficiencyScalar' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlideBrakingDeceleration) == 0x000768, "Member 'UNGDCharacterMovementComponent::SlideBrakingDeceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlideGroundFriction) == 0x00076C, "Member 'UNGDCharacterMovementComponent::SlideGroundFriction' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlideTimegapAfterSprint) == 0x000774, "Member 'UNGDCharacterMovementComponent::SlideTimegapAfterSprint' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, CurrentSlideTimegapAfterSprint) == 0x000778, "Member 'UNGDCharacterMovementComponent::CurrentSlideTimegapAfterSprint' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlidePenaltyDefaultCooldown) == 0x00077C, "Member 'UNGDCharacterMovementComponent::SlidePenaltyDefaultCooldown' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlideSprintDuration) == 0x000784, "Member 'UNGDCharacterMovementComponent::SlideSprintDuration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, CurrentMoveVector) == 0x000788, "Member 'UNGDCharacterMovementComponent::CurrentMoveVector' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, CurrentCharRotator) == 0x000794, "Member 'UNGDCharacterMovementComponent::CurrentCharRotator' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, FallSpeed) == 0x0007A0, "Member 'UNGDCharacterMovementComponent::FallSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, LateralSpeed) == 0x0007A4, "Member 'UNGDCharacterMovementComponent::LateralSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, DesiredAngle) == 0x0007A8, "Member 'UNGDCharacterMovementComponent::DesiredAngle' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, RunMoveVectorSpeed) == 0x0007AC, "Member 'UNGDCharacterMovementComponent::RunMoveVectorSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SprintMoveVectorSpeed) == 0x0007B0, "Member 'UNGDCharacterMovementComponent::SprintMoveVectorSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, RunRotationSpeed) == 0x0007B4, "Member 'UNGDCharacterMovementComponent::RunRotationSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SprintRotationSpeed) == 0x0007B8, "Member 'UNGDCharacterMovementComponent::SprintRotationSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, LegsRotationSpeed) == 0x0007BC, "Member 'UNGDCharacterMovementComponent::LegsRotationSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, LegsRotationVelocityThreshold) == 0x0007C0, "Member 'UNGDCharacterMovementComponent::LegsRotationVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, FallingMoveVectorSpeed) == 0x0007C4, "Member 'UNGDCharacterMovementComponent::FallingMoveVectorSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFallingSpeed) == 0x0007C8, "Member 'UNGDCharacterMovementComponent::MaxFallingSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFallingAcceleration) == 0x0007CC, "Member 'UNGDCharacterMovementComponent::MaxFallingAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxGlideAngle) == 0x0007D0, "Member 'UNGDCharacterMovementComponent::MaxGlideAngle' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MinGlideAngle) == 0x0007D4, "Member 'UNGDCharacterMovementComponent::MinGlideAngle' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, FallSpeedSmoothFactor) == 0x0007D8, "Member 'UNGDCharacterMovementComponent::FallSpeedSmoothFactor' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, LateralSpeedSmoothFactor) == 0x0007DC, "Member 'UNGDCharacterMovementComponent::LateralSpeedSmoothFactor' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, MaxFallingDeltaSpeed) == 0x0007E0, "Member 'UNGDCharacterMovementComponent::MaxFallingDeltaSpeed' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, SlidePercentFromForward) == 0x0007E4, "Member 'UNGDCharacterMovementComponent::SlidePercentFromForward' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, LateralRotationAngle) == 0x0007E8, "Member 'UNGDCharacterMovementComponent::LateralRotationAngle' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, FallingScale) == 0x0007EC, "Member 'UNGDCharacterMovementComponent::FallingScale' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, VerticalVelocityLimit) == 0x0007F0, "Member 'UNGDCharacterMovementComponent::VerticalVelocityLimit' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, NormalJumpBrake) == 0x0007F4, "Member 'UNGDCharacterMovementComponent::NormalJumpBrake' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, HighJumpBrake) == 0x0007F8, "Member 'UNGDCharacterMovementComponent::HighJumpBrake' has a wrong offset!");
static_assert(offsetof(UNGDCharacterMovementComponent, CastedCharacterOwner) == 0x000800, "Member 'UNGDCharacterMovementComponent::CastedCharacterOwner' has a wrong offset!");

// Class UnrealProject.NGDPlayerController
// 0x0140 (0x06A8 - 0x0568)
class ANGDPlayerController : public APlayerController
{
public:
	class UNGDAkListener*                         ListenerComponent;                                 // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANGDCharacter*                          TargetSpectating;                                  // 0x0570(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_578[0x5];                                      // 0x0578(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          SwitchToSpectatorOnDeath;                          // 0x057D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57E[0x2];                                      // 0x057E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDWeaponEventManagerComponent*        WeaponEventManager;                                // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x120];                                    // 0x0588(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientForceSpectatorLocationAndRotation(const struct FVector& InLocation, const struct FRotator& InRotation);
	void ClientSetTargetToSpectate(class ANGDCharacter* InTargetToSpectate);
	void ClientStorePoseOnHit(const TArray<struct FActorSample>& ActorsSamples, int32 AmmoIndex, const struct FVector& ShootPos, const struct FVector& ShootDir, const struct FVector& HitPos, bool Acknowledged);
	void ClientStorePoseOnHitByBot(const TArray<struct FActorSample>& ActorsSamples, int32 AmmoIndex, const struct FVector& ShootPos, const struct FVector& ShootDir, const struct FVector& HitPos, bool Acknowledged);
	void ClientStoreValidationResult(uint8 ValidationResult);
	void DrawCharacterStatus();
	void DrawShoot(int32 AmmoIndex);
	void LocalStorePoseOnHit(const TArray<struct FActorSample>& ActorsSamples, int32 AmmoIndex, const struct FVector& ShootPos, const struct FVector& ShootDir, const struct FVector& HitPos);
	void PrintHitRegistrationResults();
	void ServerCheat(const class FString& Msg);
	void ServerReportPlayer(const struct FUniqueNetIdRepl& ReportedUniqueNetId, EPlayerReportType ReportType, const class FString& ReportDescription);
	void ServerRequestTargetToSpectate(int8 InRequestedIndex);
	void ServerStartSpectate();

	class ANGDCharacter* TryGetCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerController">();
	}
	static class ANGDPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDPlayerController>();
	}
};
static_assert(alignof(ANGDPlayerController) == 0x000008, "Wrong alignment on ANGDPlayerController");
static_assert(sizeof(ANGDPlayerController) == 0x0006A8, "Wrong size on ANGDPlayerController");
static_assert(offsetof(ANGDPlayerController, ListenerComponent) == 0x000568, "Member 'ANGDPlayerController::ListenerComponent' has a wrong offset!");
static_assert(offsetof(ANGDPlayerController, TargetSpectating) == 0x000570, "Member 'ANGDPlayerController::TargetSpectating' has a wrong offset!");
static_assert(offsetof(ANGDPlayerController, SwitchToSpectatorOnDeath) == 0x00057D, "Member 'ANGDPlayerController::SwitchToSpectatorOnDeath' has a wrong offset!");
static_assert(offsetof(ANGDPlayerController, WeaponEventManager) == 0x000580, "Member 'ANGDPlayerController::WeaponEventManager' has a wrong offset!");

// Class UnrealProject.NGDCrosshairWidget
// 0x0010 (0x0290 - 0x0280)
class UNGDCrosshairWidget : public UNGDUserWidget
{
public:
	class AWeapon*                                Weapon;                                            // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangedADS(const bool bNewValue);
	void OnSpreadChanged(float Spread);
	void SetWeapon(class AWeapon* InWeapon);
	void UpdateCrosshairColor(int32 ColorIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDCrosshairWidget">();
	}
	static class UNGDCrosshairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDCrosshairWidget>();
	}
};
static_assert(alignof(UNGDCrosshairWidget) == 0x000008, "Wrong alignment on UNGDCrosshairWidget");
static_assert(sizeof(UNGDCrosshairWidget) == 0x000290, "Wrong size on UNGDCrosshairWidget");
static_assert(offsetof(UNGDCrosshairWidget, Weapon) == 0x000280, "Member 'UNGDCrosshairWidget::Weapon' has a wrong offset!");

// Class UnrealProject.NGDDamageable
// 0x0000 (0x0000 - 0x0000)
class INGDDamageable final
{
public:
	void Kill(class ANGDCharacter* Character, struct FNGDDamageEvent* DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void NGDDamageable_SetCanBeDamaged(bool CanBeDamaged);
	void OnDeath(const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	float OnTakeDamage(float Damage, const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void TakeDamage(float Damage, const struct FNGDDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);

	bool GetCanBeDamaged() const;
	float GetHealth() const;
	float GetMaxHealth() const;
	class UNGDMortalityComponent* GetMortalityComponent() const;
	bool IsAlive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDDamageable">();
	}
	static class INGDDamageable* GetDefaultObj()
	{
		return GetDefaultObjImpl<INGDDamageable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INGDDamageable) == 0x000001, "Wrong alignment on INGDDamageable");
static_assert(sizeof(INGDDamageable) == 0x000001, "Wrong size on INGDDamageable");

// Class UnrealProject.NGDDedicatedServerGameMode
// 0x0060 (0x0360 - 0x0300)
class ANGDDedicatedServerGameMode final : public AGameMode
{
public:
	struct FSoftObjectPath                        MapToLoadPath;                                     // 0x0300(0x0018)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x48];                                     // 0x0318(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDDedicatedServerGameMode">();
	}
	static class ANGDDedicatedServerGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDDedicatedServerGameMode>();
	}
};
static_assert(alignof(ANGDDedicatedServerGameMode) == 0x000008, "Wrong alignment on ANGDDedicatedServerGameMode");
static_assert(sizeof(ANGDDedicatedServerGameMode) == 0x000360, "Wrong size on ANGDDedicatedServerGameMode");
static_assert(offsetof(ANGDDedicatedServerGameMode, MapToLoadPath) == 0x000300, "Member 'ANGDDedicatedServerGameMode::MapToLoadPath' has a wrong offset!");

// Class UnrealProject.NGDDoor
// 0x0018 (0x0250 - 0x0238)
class ANGDDoor final : public ANGDInteractableActor
{
public:
	float                                         OpenStateYawValue;                                 // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseStateYawValue;                                // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenCloseSpeed;                                    // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDoorRepState                          RepState;                                          // 0x0244(0x0002)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_246[0x2];                                      // 0x0246(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Pivot;                                             // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClosed();
	void OnOpened();
	void OnRep_State(const struct FDoorRepState& LastRepState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDDoor">();
	}
	static class ANGDDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDDoor>();
	}
};
static_assert(alignof(ANGDDoor) == 0x000008, "Wrong alignment on ANGDDoor");
static_assert(sizeof(ANGDDoor) == 0x000250, "Wrong size on ANGDDoor");
static_assert(offsetof(ANGDDoor, OpenStateYawValue) == 0x000238, "Member 'ANGDDoor::OpenStateYawValue' has a wrong offset!");
static_assert(offsetof(ANGDDoor, CloseStateYawValue) == 0x00023C, "Member 'ANGDDoor::CloseStateYawValue' has a wrong offset!");
static_assert(offsetof(ANGDDoor, OpenCloseSpeed) == 0x000240, "Member 'ANGDDoor::OpenCloseSpeed' has a wrong offset!");
static_assert(offsetof(ANGDDoor, RepState) == 0x000244, "Member 'ANGDDoor::RepState' has a wrong offset!");
static_assert(offsetof(ANGDDoor, Pivot) == 0x000248, "Member 'ANGDDoor::Pivot' has a wrong offset!");

// Class UnrealProject.NGDFlyPropellerMovementComponent
// 0x0040 (0x0178 - 0x0138)
class UNGDFlyPropellerMovementComponent final : public UPawnMovementComponent
{
public:
	float                                         MaxSpeed;                                          // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Acceleration;                                      // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesAcceleration;                                   // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDrawDebugs;                                 // 0x0144(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugLifeTime;                                     // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerClientDistanceToleranceSQR;                  // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BounceFactor;                                      // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PingScaleUntilNextCorrection;                      // 0x0154(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenTimeStampResets;                     // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAfkTimeUntilServerTakeTheControl;               // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x18];                                     // 0x0160(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientAckGoodMove(float Timestamp);
	void ClientAdjustMovement(float Timestamp, const struct FVector& CorrectLocation, const struct FVector& CorrectVelocity);
	void ServerMove(float Timestamp, const struct FVector_NetQuantize10& AccelerationDir, const struct FVector_NetQuantize100& ClientLocation);
	void ServerMoveOld(float Timestamp, const struct FVector_NetQuantize10& AccelerationDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDFlyPropellerMovementComponent">();
	}
	static class UNGDFlyPropellerMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDFlyPropellerMovementComponent>();
	}
};
static_assert(alignof(UNGDFlyPropellerMovementComponent) == 0x000008, "Wrong alignment on UNGDFlyPropellerMovementComponent");
static_assert(sizeof(UNGDFlyPropellerMovementComponent) == 0x000178, "Wrong size on UNGDFlyPropellerMovementComponent");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, MaxSpeed) == 0x000138, "Member 'UNGDFlyPropellerMovementComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, Acceleration) == 0x00013C, "Member 'UNGDFlyPropellerMovementComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, DesAcceleration) == 0x000140, "Member 'UNGDFlyPropellerMovementComponent::DesAcceleration' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, bShouldDrawDebugs) == 0x000144, "Member 'UNGDFlyPropellerMovementComponent::bShouldDrawDebugs' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, DebugLifeTime) == 0x000148, "Member 'UNGDFlyPropellerMovementComponent::DebugLifeTime' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, ServerClientDistanceToleranceSQR) == 0x00014C, "Member 'UNGDFlyPropellerMovementComponent::ServerClientDistanceToleranceSQR' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, BounceFactor) == 0x000150, "Member 'UNGDFlyPropellerMovementComponent::BounceFactor' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, PingScaleUntilNextCorrection) == 0x000154, "Member 'UNGDFlyPropellerMovementComponent::PingScaleUntilNextCorrection' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, MinTimeBetweenTimeStampResets) == 0x000158, "Member 'UNGDFlyPropellerMovementComponent::MinTimeBetweenTimeStampResets' has a wrong offset!");
static_assert(offsetof(UNGDFlyPropellerMovementComponent, MaxAfkTimeUntilServerTakeTheControl) == 0x00015C, "Member 'UNGDFlyPropellerMovementComponent::MaxAfkTimeUntilServerTakeTheControl' has a wrong offset!");

// Class UnrealProject.NGDFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UNGDFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ApplyRadialDamage(const struct FVector& Origin, float BaseDamage, float Radius, class AActor* DamageCauser, const TArray<class AActor*>& IgnoreActors, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel, float ImpulseForce);
	static bool ApplyRadialDamageWithFalloff(const struct FVector& Origin, const struct FNGDRadialDamageConfig& RadialConfig, class AActor* DamageCauser, const TArray<class AActor*>& IgnoreActors, class AController* InstigatedByController, bool InWantFalloffDamage);
	static void BP_DrawDebugLine(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& Color, float LifeTime, float Thickness);
	static struct FCollisionResult CheckSphereAgainstBox(const struct FVector& BoxCenter, const struct FVector& BoxExtent, const struct FQuat& BoxQuat, const struct FVector& sphereStartPos, const struct FVector& sphereEndPos, float SphereRadius);
	static struct FCollisionResult CheckSphereAgainstBoxComponent(class UBoxComponent* BoxComponent, const struct FVector& sphereStartPos, const struct FVector& sphereEndPos, float SphereRadius);
	static struct FCollisionResult CheckSphereAgainstCapsule(class UObject* C, const struct FVector& CapsuleLocation, const struct FRotator& capsuleRotation, float capsuleRadius, float CapsuleHalfHeight, const struct FVector& sphereStartPos, const struct FVector& sphereEndPos, float SphereRadius);
	static struct FCollisionResult CheckSphereAgainstCapsuleComponent(class UObject* C, class UCapsuleComponent* capsule, const struct FVector& sphereStartPos, const struct FVector& sphereEndPos, float SphereRadius);
	static struct FCollisionResult CheckSphereAgainstCapsuleRaw(class UObject* C, const struct FVector& capsulePointA, const struct FVector& capsulePointB, float capsuleRadius, const struct FVector& sphereStartPos, const struct FVector& sphereEndPos, float SphereRadius);
	static float DegreesBetweenVectors(const struct FVector& Vector1, const struct FVector& Vector2);
	static void DrawDebug2DGraph(class UCanvas* Canvas, const struct FVector2D& CenterOffset, const struct FVector2D& Extents, const struct FVector2D& DataExtent, const class FString& Header);
	static void DrawDebugCapsule(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugSphere(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugString(class UObject* WorldContextObject, const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration);
	static void DrawDebugVector2DGraph(class UCanvas* Canvas, const struct FVector2D& CenterOffset, const struct FVector2D& Extents, const struct FVector2D& Data, const struct FVector2D& DataExtent, const class FString& Header);
	static class FName GetClosestBodyInstanceToBone(class USkeletalMeshComponent* MeshTP, const class FName& BoneName);
	static float GetDistanceToLocalViewer(const class UObject* InContext, const struct FVector& InLocation);
	static class UNGDGameInstance* GetGameInstance(class UObject* Context);
	static class FString GetGameVersionString();
	static class ANGDHUD* GetHUD(class UObject* WorldContextObject);
	static class ANGDCharacter* GetLocalCharacter(const class UObject* Context);
	static class ANGDCharacter* GetLocalCharacterOrSpectating(class UObject* Context);
	static class ANGDPlayerController* GetLocalController(const class UObject* Context);
	static struct FVector GetLocalViewerPosition(const class UObject* InContext);
	static class FString GetPlayerUniqueNetId(class APlayerState* PlayerState);
	static class ANGDCharacter* GetSpectatingCharacter(class UObject* Context);
	static bool HasAllThisFlags(const uint8 CurrentFlags, const uint8 FlagsToCheck);
	static bool HasAnyFlag(const uint8 CurrentFlags);
	static bool HasAnyThisFlags(const uint8 CurrentFlags, const uint8 FlagsToCheck);
	static bool HasOnlyThisFlags(const uint8 CurrentFlags, const uint8 FlagsToCheck);
	static bool IsActorInShootingAngle(const class AActor* Shooter, const class AActor* ActorToCheck);
	static bool IsDedicatedServer(const class UObject* Context);
	static bool IsListenServer(const class UObject* Context);
	static bool IsStandalone(const class UObject* Context);
	static struct FVector LimitVectorRange(const struct FVector& Origin, const struct FVector& Desired, float Limit);
	static struct FCollisionResult LineTraceAgainstAABB(const struct FBox& Box, const struct FVector& Start, const struct FVector& End, struct FVector* OutExitHitPoint);
	static struct FCollisionResult LineTraceAgainstCube(const struct FQuat& BoxRotation, const struct FBox& Box, const struct FVector& Start, const struct FVector& End, float Tolerance, class UObject* DebugObject);
	static float PerlinNoise1D(float X);
	static float RadiansBetweenVectors(const struct FVector& Vector1, const struct FVector& Vector2);
	static struct FVector RandomPointInCircle(float Radius);
	static bool SaveStringTextToFile(const class FString& SaveDirectory, const class FString& Filename, const class FString& SaveText, bool AllowOverWriting);
	static struct FVector Slerp(const struct FVector& A, const struct FVector& B, const float Alpha);
	static struct FCollisionResult TracePointAgainstCube(const struct FQuat& BoxRotation, const struct FBox& Box, const struct FVector& Point, const struct FVector& Tolerance, class UObject* DebugObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDFunctionLibrary">();
	}
	static class UNGDFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDFunctionLibrary>();
	}
};
static_assert(alignof(UNGDFunctionLibrary) == 0x000008, "Wrong alignment on UNGDFunctionLibrary");
static_assert(sizeof(UNGDFunctionLibrary) == 0x000028, "Wrong size on UNGDFunctionLibrary");

// Class UnrealProject.NGDGameInstance
// 0x00B8 (0x0220 - 0x0168)
class UNGDGameInstance : public UGameInstance
{
public:
	TMulticastInlineDelegate<void(const class FString& ErrorString)> OnNetworkError;                 // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x3];                                      // 0x0178(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoDestroyServer;                                // 0x017B(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStoreReplaysOnClient;                             // 0x017C(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ANGDCharacter>              SelectedPawnClass;                                 // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                LoadingScreenWidgetClass;                          // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            LoadingScreenWidget;                               // 0x0190(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDBackendAccount*                     BackendAccount;                                    // 0x01A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDBackendServer*                      BackendServer;                                     // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDOnlineServiceBase*                  OnlineService;                                     // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x4C];                                     // 0x01B8(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionChannel                             RewindTraceChannel;                                // 0x0204(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             RemoteTraceChannel;                                // 0x0205(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             StaticTraceChannel;                                // 0x0206(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TerrainTraceChannel;                               // 0x0207(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x18];                                     // 0x0208(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AccountUpdatePlayerData();
	void CheckForInventoryItem(const class FString& SKU);
	void DestroyGameSession();
	void DominanceBoard(int32 Start, int32 Stop, const class FString& MatchType, const class FString& TeamType, const class FString& Period);
	void DumpPlayerStats();
	void FlushMemoryUssage(bool FullReport);
	void ForceLogin(const class FString& UserName, const class FString& Password);
	class UNGDBackendServer* GetBackendServer();
	class UNGDOnlineServiceBase* GetOnlineService();
	void HideLoadingScreen();
	void JoinOnlineServer(const class FString& ServerAddress);
	void Matchmaking(const class FString& RuleName, const class FString& ClientVersion, const class FString& LastPlayedMap);
	void MatchmakingWithTicket(const class FString& MatchmakingTicketId);
	void NGDLogin(const class FString& UserName, const class FString& Password);
	void OnLeaderboardsRequestComplete(bool bWasSuccessful, const class FString& ErrorString, TArray<struct FNGDBackendGlobalLeaderboardEntry>* LeaderboardEntries, const struct FNGDBackendGlobalLeaderboardEntry& OwnEntry);
	bool RunConsoleCommand(const class FString& Command);
	void SetSelectedPawnClass(TSubclassOf<class ANGDCharacter> PawnClass);
	bool ShouldStartRecordingReplay();
	void ShowLoadingScreen(bool bAutoHide);
	void SteamBuyItem(const class FString& ItemName);
	void SteamLobbyPoll();
	void TestBuyInventoryItem(const class FString& SKU);
	void TestLoading();

	bool IsPlayingReplay() const;
	bool IsRecordingReplay() const;
	bool IsUsingGamepad() const;
	void OpenStorePremiumAccount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDGameInstance">();
	}
	static class UNGDGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDGameInstance>();
	}
};
static_assert(alignof(UNGDGameInstance) == 0x000008, "Wrong alignment on UNGDGameInstance");
static_assert(sizeof(UNGDGameInstance) == 0x000220, "Wrong size on UNGDGameInstance");
static_assert(offsetof(UNGDGameInstance, OnNetworkError) == 0x000168, "Member 'UNGDGameInstance::OnNetworkError' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, bAutoDestroyServer) == 0x00017B, "Member 'UNGDGameInstance::bAutoDestroyServer' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, bStoreReplaysOnClient) == 0x00017C, "Member 'UNGDGameInstance::bStoreReplaysOnClient' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, SelectedPawnClass) == 0x000180, "Member 'UNGDGameInstance::SelectedPawnClass' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, LoadingScreenWidgetClass) == 0x000188, "Member 'UNGDGameInstance::LoadingScreenWidgetClass' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, LoadingScreenWidget) == 0x000190, "Member 'UNGDGameInstance::LoadingScreenWidget' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, BackendAccount) == 0x0001A0, "Member 'UNGDGameInstance::BackendAccount' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, BackendServer) == 0x0001A8, "Member 'UNGDGameInstance::BackendServer' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, OnlineService) == 0x0001B0, "Member 'UNGDGameInstance::OnlineService' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, RewindTraceChannel) == 0x000204, "Member 'UNGDGameInstance::RewindTraceChannel' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, RemoteTraceChannel) == 0x000205, "Member 'UNGDGameInstance::RemoteTraceChannel' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, StaticTraceChannel) == 0x000206, "Member 'UNGDGameInstance::StaticTraceChannel' has a wrong offset!");
static_assert(offsetof(UNGDGameInstance, TerrainTraceChannel) == 0x000207, "Member 'UNGDGameInstance::TerrainTraceChannel' has a wrong offset!");

// Class UnrealProject.NGDGameMode
// 0x00B0 (0x03B0 - 0x0300)
class ANGDGameMode : public AGameMode
{
public:
	class UNGDTeamComponent*                      TeamComponent;                                     // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FUniqueNetIdRepl, class FString>  PlayerSessionIds;                                  // 0x0308(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UNGDRewindTickComponent*                RewindTickComponent;                               // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerTimeUpdateDelay;                             // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANGDCharacter*>                  GamePlayers;                                       // 0x0368(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UNGDPlayerUtilityComponent*             PlayerUtilityComponent;                            // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x30];                                     // 0x0380(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAccountValidated(bool bWasSuccessful, const struct FUniqueNetIdRepl& PlayerStateUniqueId, const class FString& UserId, int32 CoinBalance, const class FString& UserName);
	void OnValidateAccountResponse(const struct FUniqueNetIdRepl& PlayerStateUniqueId, const class FString& AccountTicket, const class FString& UserId, int32 CoinBalance, const class FString& UserName, bool bWasSuccessful, const class FString& ErrorString, int32 AttemptIndex);

	class UNGDTeamComponent* GetTeamComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDGameMode">();
	}
	static class ANGDGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDGameMode>();
	}
};
static_assert(alignof(ANGDGameMode) == 0x000008, "Wrong alignment on ANGDGameMode");
static_assert(sizeof(ANGDGameMode) == 0x0003B0, "Wrong size on ANGDGameMode");
static_assert(offsetof(ANGDGameMode, TeamComponent) == 0x000300, "Member 'ANGDGameMode::TeamComponent' has a wrong offset!");
static_assert(offsetof(ANGDGameMode, PlayerSessionIds) == 0x000308, "Member 'ANGDGameMode::PlayerSessionIds' has a wrong offset!");
static_assert(offsetof(ANGDGameMode, RewindTickComponent) == 0x000358, "Member 'ANGDGameMode::RewindTickComponent' has a wrong offset!");
static_assert(offsetof(ANGDGameMode, ServerTimeUpdateDelay) == 0x000360, "Member 'ANGDGameMode::ServerTimeUpdateDelay' has a wrong offset!");
static_assert(offsetof(ANGDGameMode, GamePlayers) == 0x000368, "Member 'ANGDGameMode::GamePlayers' has a wrong offset!");
static_assert(offsetof(ANGDGameMode, PlayerUtilityComponent) == 0x000378, "Member 'ANGDGameMode::PlayerUtilityComponent' has a wrong offset!");

// Class UnrealProject.NGDGameSession
// 0x0000 (0x0230 - 0x0230)
class ANGDGameSession : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDGameSession">();
	}
	static class ANGDGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDGameSession>();
	}
};
static_assert(alignof(ANGDGameSession) == 0x000008, "Wrong alignment on ANGDGameSession");
static_assert(sizeof(ANGDGameSession) == 0x000230, "Wrong size on ANGDGameSession");

// Class UnrealProject.NGDGameState
// 0x0070 (0x02E8 - 0x0278)
class ANGDGameState : public AGameState
{
public:
	TArray<class ANGDTeamState*>                  LocalPlayerTeams;                                  // 0x0278(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         ServerTime;                                        // 0x0288(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReportablePlayer>              ReportablePlayers;                                 // 0x0290(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCheatsEnabled;                                    // 0x02A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x47];                                     // 0x02A1(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSynchronizedTime();
	void MulticastShowScreenDebugMessage(const class FString& Message, float TimeToDisplay, EScreenMessageKey Key);
	void OnRep_ServerTime();
	void RegisterTeamState(class ANGDTeamState* State);
	void SetServerTime(int32 InTimeMs);
	void UnRegisterTeamState(class ANGDTeamState* State);

	bool IsGameplayActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDGameState">();
	}
	static class ANGDGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDGameState>();
	}
};
static_assert(alignof(ANGDGameState) == 0x000008, "Wrong alignment on ANGDGameState");
static_assert(sizeof(ANGDGameState) == 0x0002E8, "Wrong size on ANGDGameState");
static_assert(offsetof(ANGDGameState, LocalPlayerTeams) == 0x000278, "Member 'ANGDGameState::LocalPlayerTeams' has a wrong offset!");
static_assert(offsetof(ANGDGameState, ServerTime) == 0x000288, "Member 'ANGDGameState::ServerTime' has a wrong offset!");
static_assert(offsetof(ANGDGameState, ReportablePlayers) == 0x000290, "Member 'ANGDGameState::ReportablePlayers' has a wrong offset!");
static_assert(offsetof(ANGDGameState, bCheatsEnabled) == 0x0002A0, "Member 'ANGDGameState::bCheatsEnabled' has a wrong offset!");

// Class UnrealProject.NGDGameViewportClient
// 0x0000 (0x02E8 - 0x02E8)
class UNGDGameViewportClient : public UGameViewportClient
{
public:
	void ActionToDoAfterReceiveFocus();
	void ActionToDoBeforeLostFocus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDGameViewportClient">();
	}
	static class UNGDGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDGameViewportClient>();
	}
};
static_assert(alignof(UNGDGameViewportClient) == 0x000008, "Wrong alignment on UNGDGameViewportClient");
static_assert(sizeof(UNGDGameViewportClient) == 0x0002E8, "Wrong size on UNGDGameViewportClient");

// Class UnrealProject.NGDHitRegistrationLibrary
// 0x0000 (0x0028 - 0x0028)
class UNGDHitRegistrationLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FHitResult CheckForHitAtTime(class UObject* WeaponAsContext, const TArray<class AActor*>& InRewindableActors, const struct FVector& from, const struct FVector& to, float TimeToCheckHit, const struct FValidationPriorityHit& ValidationPriority, const float ValidationThreshold, const struct FHitRegistrationBullet& HitRegistrationBullet, float FixedDeltaTime);
	static TArray<struct FHitResult> CheckForMultiHitAtTime(class UObject* Context, const TArray<class AActor*>& InRewindableActors, const struct FVector& from, const struct FVector& to, float Radius, float TimeOffsetToCheckHit, const float ValidationThreshold);
	static TArray<class AActor*> GetRewindableActorsOfInterest(class UObject* WeaponAsContext, const struct FVector& from, const struct FVector& NormalizedDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDHitRegistrationLibrary">();
	}
	static class UNGDHitRegistrationLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDHitRegistrationLibrary>();
	}
};
static_assert(alignof(UNGDHitRegistrationLibrary) == 0x000008, "Wrong alignment on UNGDHitRegistrationLibrary");
static_assert(sizeof(UNGDHitRegistrationLibrary) == 0x000028, "Wrong size on UNGDHitRegistrationLibrary");

// Class UnrealProject.NGDHUD
// 0x0000 (0x0308 - 0x0308)
class ANGDHUD final : public AHUD
{
public:
	bool IsInventoryOpen();
	void OnAmmountOfCarriedConsumablesChange(int32 AmmountOfConsumables);
	void OnChangedADS(const bool bNewValue);
	void OnChangeIsConsuming(bool bIsConsuming);
	void OnChangeShowCrosshair(const bool bNewValue);
	void OnFocusInteractableActor(const TScriptInterface<class INGDInteractableInterface>& InInteractableActorFocused);
	void OnFocusVehicle(const TScriptInterface<class INGDInteractableInterface>& InInteractableActorFocused, bool IsBoarded);
	void OnInteractComponentChanged();
	void OnInventoryChanged();
	void OnSpectatorStateChanged(class FName CurrentSpectatorState);
	void OnSpectatorTargetChanged(class FName CurrentTargetName);
	void OnUnfocusInteractableActor();
	void OnVehicleBoardedChange(class AActor* VehicleImplementingActor);
	void OnWeaponChanged(class AWeapon* InWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDHUD">();
	}
	static class ANGDHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDHUD>();
	}
};
static_assert(alignof(ANGDHUD) == 0x000008, "Wrong alignment on ANGDHUD");
static_assert(sizeof(ANGDHUD) == 0x000308, "Wrong size on ANGDHUD");

// Class UnrealProject.NGDInteractableInterface
// 0x0000 (0x0000 - 0x0000)
class INGDInteractableInterface final
{
public:
	bool EnterInteractZone(class ANGDCharacter* InCharacter);
	bool Interact(class ANGDCharacter* InCharacter);
	bool LeaveInteractZone(class ANGDCharacter* InCharacter);
	void OnEnterInteractZone(class ANGDCharacter* InCharacter);
	void OnInteract(class ANGDCharacter* InCharacter);
	void OnLeaveInteractZone(class ANGDCharacter* InCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDInteractableInterface">();
	}
	static class INGDInteractableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INGDInteractableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INGDInteractableInterface) == 0x000001, "Wrong alignment on INGDInteractableInterface");
static_assert(sizeof(INGDInteractableInterface) == 0x000001, "Wrong size on INGDInteractableInterface");

// Class UnrealProject.NGDInteractAction
// 0x0040 (0x00A0 - 0x0060)
class UNGDInteractAction final : public UAction
{
public:
	class UNGDInteractionComponent*               InteractionComponent;                              // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActionParams                          ActionParams;                                      // 0x0070(0x0030)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void EventUpdate(float DeltaTime);
	void Initialize_Implementation(const struct FActionParams& InActionParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDInteractAction">();
	}
	static class UNGDInteractAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDInteractAction>();
	}
};
static_assert(alignof(UNGDInteractAction) == 0x000008, "Wrong alignment on UNGDInteractAction");
static_assert(sizeof(UNGDInteractAction) == 0x0000A0, "Wrong size on UNGDInteractAction");
static_assert(offsetof(UNGDInteractAction, InteractionComponent) == 0x000060, "Member 'UNGDInteractAction::InteractionComponent' has a wrong offset!");
static_assert(offsetof(UNGDInteractAction, PlayTestComp) == 0x000068, "Member 'UNGDInteractAction::PlayTestComp' has a wrong offset!");
static_assert(offsetof(UNGDInteractAction, ActionParams) == 0x000070, "Member 'UNGDInteractAction::ActionParams' has a wrong offset!");

// Class UnrealProject.NGDLevel
// 0x0008 (0x0228 - 0x0220)
class ANGDLevel final : public ALevelScriptActor
{
public:
	float                                         fLevelWidth;                                       // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fLevelHeight;                                      // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDLevel">();
	}
	static class ANGDLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDLevel>();
	}
};
static_assert(alignof(ANGDLevel) == 0x000008, "Wrong alignment on ANGDLevel");
static_assert(sizeof(ANGDLevel) == 0x000228, "Wrong size on ANGDLevel");
static_assert(offsetof(ANGDLevel, fLevelWidth) == 0x000220, "Member 'ANGDLevel::fLevelWidth' has a wrong offset!");
static_assert(offsetof(ANGDLevel, fLevelHeight) == 0x000224, "Member 'ANGDLevel::fLevelHeight' has a wrong offset!");

// Class UnrealProject.NGDLineRendererComponent
// 0x0018 (0x00C8 - 0x00B0)
class UNGDLineRendererComponent final : public UActorComponent
{
public:
	class UParticleSystem*                        ParticleTemplate;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UParticleSystemComponent*>       BeamsPool;                                         // 0x00B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void ClearBeamsPool();
	void DrawBeams(const TArray<struct FVector>& PointsPositions);
	void SetBeam(class UParticleSystemComponent* BeamParticle, const struct FVector& SourcePoint, const struct FVector& TargetPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDLineRendererComponent">();
	}
	static class UNGDLineRendererComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDLineRendererComponent>();
	}
};
static_assert(alignof(UNGDLineRendererComponent) == 0x000008, "Wrong alignment on UNGDLineRendererComponent");
static_assert(sizeof(UNGDLineRendererComponent) == 0x0000C8, "Wrong size on UNGDLineRendererComponent");
static_assert(offsetof(UNGDLineRendererComponent, ParticleTemplate) == 0x0000B0, "Member 'UNGDLineRendererComponent::ParticleTemplate' has a wrong offset!");
static_assert(offsetof(UNGDLineRendererComponent, BeamsPool) == 0x0000B8, "Member 'UNGDLineRendererComponent::BeamsPool' has a wrong offset!");

// Class UnrealProject.NGDMortalityComponent
// 0x0068 (0x0118 - 0x00B0)
class UNGDMortalityComponent final : public UActorComponent
{
public:
	TMap<class FName, TSubclassOf<class UNGDBodyPart>> DamageModifierMap;                            // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         DeathImpulseForce;                                 // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Health;                                            // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHealth;                                         // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHealthVariation;                                // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeDamaged;                                     // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDMortalityComponent">();
	}
	static class UNGDMortalityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDMortalityComponent>();
	}
};
static_assert(alignof(UNGDMortalityComponent) == 0x000008, "Wrong alignment on UNGDMortalityComponent");
static_assert(sizeof(UNGDMortalityComponent) == 0x000118, "Wrong size on UNGDMortalityComponent");
static_assert(offsetof(UNGDMortalityComponent, DamageModifierMap) == 0x0000B0, "Member 'UNGDMortalityComponent::DamageModifierMap' has a wrong offset!");
static_assert(offsetof(UNGDMortalityComponent, DeathImpulseForce) == 0x000100, "Member 'UNGDMortalityComponent::DeathImpulseForce' has a wrong offset!");
static_assert(offsetof(UNGDMortalityComponent, Health) == 0x000104, "Member 'UNGDMortalityComponent::Health' has a wrong offset!");
static_assert(offsetof(UNGDMortalityComponent, MaxHealth) == 0x000108, "Member 'UNGDMortalityComponent::MaxHealth' has a wrong offset!");
static_assert(offsetof(UNGDMortalityComponent, MinHealthVariation) == 0x00010C, "Member 'UNGDMortalityComponent::MinHealthVariation' has a wrong offset!");
static_assert(offsetof(UNGDMortalityComponent, bCanBeDamaged) == 0x000110, "Member 'UNGDMortalityComponent::bCanBeDamaged' has a wrong offset!");

// Class UnrealProject.NGDPawnVehicle
// 0x0038 (0x02B0 - 0x0278)
class ANGDPawnVehicle : public APawn
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPawnMovementComponent*                 VehicleMovement;                                   // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionBox;                                    // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        UnboardContainer;                                  // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNGDVehicleComponent*                   VehicleComponent;                                  // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ServerRequestDriverUnBoardContract();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPawnVehicle">();
	}
	static class ANGDPawnVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDPawnVehicle>();
	}
};
static_assert(alignof(ANGDPawnVehicle) == 0x000008, "Wrong alignment on ANGDPawnVehicle");
static_assert(sizeof(ANGDPawnVehicle) == 0x0002B0, "Wrong size on ANGDPawnVehicle");
static_assert(offsetof(ANGDPawnVehicle, Mesh) == 0x000288, "Member 'ANGDPawnVehicle::Mesh' has a wrong offset!");
static_assert(offsetof(ANGDPawnVehicle, VehicleMovement) == 0x000290, "Member 'ANGDPawnVehicle::VehicleMovement' has a wrong offset!");
static_assert(offsetof(ANGDPawnVehicle, InteractionBox) == 0x000298, "Member 'ANGDPawnVehicle::InteractionBox' has a wrong offset!");
static_assert(offsetof(ANGDPawnVehicle, UnboardContainer) == 0x0002A0, "Member 'ANGDPawnVehicle::UnboardContainer' has a wrong offset!");
static_assert(offsetof(ANGDPawnVehicle, VehicleComponent) == 0x0002A8, "Member 'ANGDPawnVehicle::VehicleComponent' has a wrong offset!");

// Class UnrealProject.NGDPlane
// 0x0000 (0x02B0 - 0x02B0)
class ANGDPlane final : public ANGDPawnVehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlane">();
	}
	static class ANGDPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDPlane>();
	}
};
static_assert(alignof(ANGDPlane) == 0x000008, "Wrong alignment on ANGDPlane");
static_assert(sizeof(ANGDPlane) == 0x0002B0, "Wrong size on ANGDPlane");

// Class UnrealProject.NGDPlayerCameraManager
// 0x0000 (0x26D0 - 0x26D0)
class ANGDPlayerCameraManager : public APlayerCameraManager
{
public:
	TSubclassOf<class UCameraShake>               SprintCameraShakeClass;                            // 0x26C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsShakeAnimActive(TSubclassOf<class UCameraShake> ShakeClass);
	void PlayShakeAnim(TSubclassOf<class UCameraShake> ShakeClass, float Scale);
	void StopShakeAnim(TSubclassOf<class UCameraShake> ShakeClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerCameraManager">();
	}
	static class ANGDPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDPlayerCameraManager>();
	}
};
static_assert(alignof(ANGDPlayerCameraManager) == 0x000010, "Wrong alignment on ANGDPlayerCameraManager");
static_assert(sizeof(ANGDPlayerCameraManager) == 0x0026D0, "Wrong size on ANGDPlayerCameraManager");
static_assert(offsetof(ANGDPlayerCameraManager, SprintCameraShakeClass) == 0x0026C8, "Member 'ANGDPlayerCameraManager::SprintCameraShakeClass' has a wrong offset!");

// Class UnrealProject.NGDPlayerFilter
// 0x0000 (0x0028 - 0x0028)
class UNGDPlayerFilter : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilter">();
	}
	static class UNGDPlayerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilter>();
	}
};
static_assert(alignof(UNGDPlayerFilter) == 0x000008, "Wrong alignment on UNGDPlayerFilter");
static_assert(sizeof(UNGDPlayerFilter) == 0x000028, "Wrong size on UNGDPlayerFilter");

// Class UnrealProject.NGDPlayerFilterAnd
// 0x0010 (0x0038 - 0x0028)
class UNGDPlayerFilterAnd final : public UNGDPlayerFilter
{
public:
	TArray<class UNGDPlayerFilter*>               Filters;                                           // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterAnd">();
	}
	static class UNGDPlayerFilterAnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterAnd>();
	}
};
static_assert(alignof(UNGDPlayerFilterAnd) == 0x000008, "Wrong alignment on UNGDPlayerFilterAnd");
static_assert(sizeof(UNGDPlayerFilterAnd) == 0x000038, "Wrong size on UNGDPlayerFilterAnd");
static_assert(offsetof(UNGDPlayerFilterAnd, Filters) == 0x000028, "Member 'UNGDPlayerFilterAnd::Filters' has a wrong offset!");

// Class UnrealProject.NGDPlayerFilterOr
// 0x0010 (0x0038 - 0x0028)
class UNGDPlayerFilterOr final : public UNGDPlayerFilter
{
public:
	TArray<class UNGDPlayerFilter*>               Filters;                                           // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterOr">();
	}
	static class UNGDPlayerFilterOr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterOr>();
	}
};
static_assert(alignof(UNGDPlayerFilterOr) == 0x000008, "Wrong alignment on UNGDPlayerFilterOr");
static_assert(sizeof(UNGDPlayerFilterOr) == 0x000038, "Wrong size on UNGDPlayerFilterOr");
static_assert(offsetof(UNGDPlayerFilterOr, Filters) == 0x000028, "Member 'UNGDPlayerFilterOr::Filters' has a wrong offset!");

// Class UnrealProject.NGDPlayerFilterNegate
// 0x0008 (0x0030 - 0x0028)
class UNGDPlayerFilterNegate final : public UNGDPlayerFilter
{
public:
	class UNGDPlayerFilter*                       FilterA;                                           // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterNegate">();
	}
	static class UNGDPlayerFilterNegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterNegate>();
	}
};
static_assert(alignof(UNGDPlayerFilterNegate) == 0x000008, "Wrong alignment on UNGDPlayerFilterNegate");
static_assert(sizeof(UNGDPlayerFilterNegate) == 0x000030, "Wrong size on UNGDPlayerFilterNegate");
static_assert(offsetof(UNGDPlayerFilterNegate, FilterA) == 0x000028, "Member 'UNGDPlayerFilterNegate::FilterA' has a wrong offset!");

// Class UnrealProject.NGDPlayerFilterPlayerAlive
// 0x0000 (0x0028 - 0x0028)
class UNGDPlayerFilterPlayerAlive final : public UNGDPlayerFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterPlayerAlive">();
	}
	static class UNGDPlayerFilterPlayerAlive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterPlayerAlive>();
	}
};
static_assert(alignof(UNGDPlayerFilterPlayerAlive) == 0x000008, "Wrong alignment on UNGDPlayerFilterPlayerAlive");
static_assert(sizeof(UNGDPlayerFilterPlayerAlive) == 0x000028, "Wrong size on UNGDPlayerFilterPlayerAlive");

// Class UnrealProject.NGDPlayerFilterPlayerInBuilding
// 0x0000 (0x0028 - 0x0028)
class UNGDPlayerFilterPlayerInBuilding final : public UNGDPlayerFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterPlayerInBuilding">();
	}
	static class UNGDPlayerFilterPlayerInBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterPlayerInBuilding>();
	}
};
static_assert(alignof(UNGDPlayerFilterPlayerInBuilding) == 0x000008, "Wrong alignment on UNGDPlayerFilterPlayerInBuilding");
static_assert(sizeof(UNGDPlayerFilterPlayerInBuilding) == 0x000028, "Wrong size on UNGDPlayerFilterPlayerInBuilding");

// Class UnrealProject.NGDPlayerFilterPlayerInCircle
// 0x0010 (0x0038 - 0x0028)
class UNGDPlayerFilterPlayerInCircle final : public UNGDPlayerFilter
{
public:
	struct FVector                                Center;                                            // 0x0028(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadiusSQR;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterPlayerInCircle">();
	}
	static class UNGDPlayerFilterPlayerInCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterPlayerInCircle>();
	}
};
static_assert(alignof(UNGDPlayerFilterPlayerInCircle) == 0x000008, "Wrong alignment on UNGDPlayerFilterPlayerInCircle");
static_assert(sizeof(UNGDPlayerFilterPlayerInCircle) == 0x000038, "Wrong size on UNGDPlayerFilterPlayerInCircle");
static_assert(offsetof(UNGDPlayerFilterPlayerInCircle, Center) == 0x000028, "Member 'UNGDPlayerFilterPlayerInCircle::Center' has a wrong offset!");
static_assert(offsetof(UNGDPlayerFilterPlayerInCircle, RadiusSQR) == 0x000034, "Member 'UNGDPlayerFilterPlayerInCircle::RadiusSQR' has a wrong offset!");

// Class UnrealProject.NGDPlayerFilterNearToPlayer
// 0x0008 (0x0030 - 0x0028)
class UNGDPlayerFilterNearToPlayer final : public UNGDPlayerFilter
{
public:
	float                                         DistanceSQR;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterNearToPlayer">();
	}
	static class UNGDPlayerFilterNearToPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterNearToPlayer>();
	}
};
static_assert(alignof(UNGDPlayerFilterNearToPlayer) == 0x000008, "Wrong alignment on UNGDPlayerFilterNearToPlayer");
static_assert(sizeof(UNGDPlayerFilterNearToPlayer) == 0x000030, "Wrong size on UNGDPlayerFilterNearToPlayer");
static_assert(offsetof(UNGDPlayerFilterNearToPlayer, DistanceSQR) == 0x000028, "Member 'UNGDPlayerFilterNearToPlayer::DistanceSQR' has a wrong offset!");

// Class UnrealProject.NGDPlayerFilterRemainingHealth
// 0x0008 (0x0030 - 0x0028)
class UNGDPlayerFilterRemainingHealth final : public UNGDPlayerFilter
{
public:
	float                                         Health;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENGDPlayerFilterComparative                   ComparativeMethod;                                 // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterRemainingHealth">();
	}
	static class UNGDPlayerFilterRemainingHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterRemainingHealth>();
	}
};
static_assert(alignof(UNGDPlayerFilterRemainingHealth) == 0x000008, "Wrong alignment on UNGDPlayerFilterRemainingHealth");
static_assert(sizeof(UNGDPlayerFilterRemainingHealth) == 0x000030, "Wrong size on UNGDPlayerFilterRemainingHealth");
static_assert(offsetof(UNGDPlayerFilterRemainingHealth, Health) == 0x000028, "Member 'UNGDPlayerFilterRemainingHealth::Health' has a wrong offset!");
static_assert(offsetof(UNGDPlayerFilterRemainingHealth, ComparativeMethod) == 0x00002C, "Member 'UNGDPlayerFilterRemainingHealth::ComparativeMethod' has a wrong offset!");

// Class UnrealProject.NGDPlayerFilterPlayersInVehicle
// 0x0000 (0x0028 - 0x0028)
class UNGDPlayerFilterPlayersInVehicle final : public UNGDPlayerFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterPlayersInVehicle">();
	}
	static class UNGDPlayerFilterPlayersInVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterPlayersInVehicle>();
	}
};
static_assert(alignof(UNGDPlayerFilterPlayersInVehicle) == 0x000008, "Wrong alignment on UNGDPlayerFilterPlayersInVehicle");
static_assert(sizeof(UNGDPlayerFilterPlayersInVehicle) == 0x000028, "Wrong size on UNGDPlayerFilterPlayersInVehicle");

// Class UnrealProject.NGDPlayerFilterAll
// 0x0000 (0x0028 - 0x0028)
class UNGDPlayerFilterAll final : public UNGDPlayerFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterAll">();
	}
	static class UNGDPlayerFilterAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterAll>();
	}
};
static_assert(alignof(UNGDPlayerFilterAll) == 0x000008, "Wrong alignment on UNGDPlayerFilterAll");
static_assert(sizeof(UNGDPlayerFilterAll) == 0x000028, "Wrong size on UNGDPlayerFilterAll");

// Class UnrealProject.NGDPlayerFilterPlayerInSameTeam
// 0x0000 (0x0028 - 0x0028)
class UNGDPlayerFilterPlayerInSameTeam final : public UNGDPlayerFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterPlayerInSameTeam">();
	}
	static class UNGDPlayerFilterPlayerInSameTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterPlayerInSameTeam>();
	}
};
static_assert(alignof(UNGDPlayerFilterPlayerInSameTeam) == 0x000008, "Wrong alignment on UNGDPlayerFilterPlayerInSameTeam");
static_assert(sizeof(UNGDPlayerFilterPlayerInSameTeam) == 0x000028, "Wrong size on UNGDPlayerFilterPlayerInSameTeam");

// Class UnrealProject.NGDPlayerFilterPlayerWithItem
// 0x0010 (0x0038 - 0x0028)
class UNGDPlayerFilterPlayerWithItem final : public UNGDPlayerFilter
{
public:
	TSubclassOf<class AItem>                      ItemClass;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Quantity;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENGDPlayerFilterComparative                   ComparativeMethod;                                 // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerFilterPlayerWithItem">();
	}
	static class UNGDPlayerFilterPlayerWithItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerFilterPlayerWithItem>();
	}
};
static_assert(alignof(UNGDPlayerFilterPlayerWithItem) == 0x000008, "Wrong alignment on UNGDPlayerFilterPlayerWithItem");
static_assert(sizeof(UNGDPlayerFilterPlayerWithItem) == 0x000038, "Wrong size on UNGDPlayerFilterPlayerWithItem");
static_assert(offsetof(UNGDPlayerFilterPlayerWithItem, ItemClass) == 0x000028, "Member 'UNGDPlayerFilterPlayerWithItem::ItemClass' has a wrong offset!");
static_assert(offsetof(UNGDPlayerFilterPlayerWithItem, Quantity) == 0x000030, "Member 'UNGDPlayerFilterPlayerWithItem::Quantity' has a wrong offset!");
static_assert(offsetof(UNGDPlayerFilterPlayerWithItem, ComparativeMethod) == 0x000034, "Member 'UNGDPlayerFilterPlayerWithItem::ComparativeMethod' has a wrong offset!");

// Class UnrealProject.NGDPlayerState
// 0x0010 (0x0350 - 0x0340)
class ANGDPlayerState : public APlayerState
{
public:
	class FString                                 UserId;                                            // 0x0340(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ServerValidateAccount(const class FString& AccountTicket);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerState">();
	}
	static class ANGDPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDPlayerState>();
	}
};
static_assert(alignof(ANGDPlayerState) == 0x000008, "Wrong alignment on ANGDPlayerState");
static_assert(sizeof(ANGDPlayerState) == 0x000350, "Wrong size on ANGDPlayerState");
static_assert(offsetof(ANGDPlayerState, UserId) == 0x000340, "Member 'ANGDPlayerState::UserId' has a wrong offset!");

// Class UnrealProject.NGDPlayerUtilityComponent
// 0x0000 (0x00B0 - 0x00B0)
class UNGDPlayerUtilityComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPlayerUtilityComponent">();
	}
	static class UNGDPlayerUtilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPlayerUtilityComponent>();
	}
};
static_assert(alignof(UNGDPlayerUtilityComponent) == 0x000008, "Wrong alignment on UNGDPlayerUtilityComponent");
static_assert(sizeof(UNGDPlayerUtilityComponent) == 0x0000B0, "Wrong size on UNGDPlayerUtilityComponent");

// Class UnrealProject.NGDPostProcessCameraConfig
// 0x0530 (0x0560 - 0x0030)
class UNGDPostProcessCameraConfig final : public UDataAsset
{
public:
	struct FPostProcessSettings                   Settings;                                          // 0x0030(0x0530)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPostProcessCameraConfig">();
	}
	static class UNGDPostProcessCameraConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPostProcessCameraConfig>();
	}
};
static_assert(alignof(UNGDPostProcessCameraConfig) == 0x000010, "Wrong alignment on UNGDPostProcessCameraConfig");
static_assert(sizeof(UNGDPostProcessCameraConfig) == 0x000560, "Wrong size on UNGDPostProcessCameraConfig");
static_assert(offsetof(UNGDPostProcessCameraConfig, Settings) == 0x000030, "Member 'UNGDPostProcessCameraConfig::Settings' has a wrong offset!");

// Class UnrealProject.NGDPostUpdateWorkComponent
// 0x0010 (0x00C0 - 0x00B0)
class UNGDPostUpdateWorkComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnPostUpdateWorkTick;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDPostUpdateWorkComponent">();
	}
	static class UNGDPostUpdateWorkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDPostUpdateWorkComponent>();
	}
};
static_assert(alignof(UNGDPostUpdateWorkComponent) == 0x000008, "Wrong alignment on UNGDPostUpdateWorkComponent");
static_assert(sizeof(UNGDPostUpdateWorkComponent) == 0x0000C0, "Wrong size on UNGDPostUpdateWorkComponent");
static_assert(offsetof(UNGDPostUpdateWorkComponent, OnPostUpdateWorkTick) == 0x0000B0, "Member 'UNGDPostUpdateWorkComponent::OnPostUpdateWorkTick' has a wrong offset!");

// Class UnrealProject.NGDRewindComponent
// 0x00A0 (0x0150 - 0x00B0)
class UNGDRewindComponent final : public UActorComponent
{
public:
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            StaticPhysicsAsset;                                // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x90];                                      // 0x00C0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDRewindComponent">();
	}
	static class UNGDRewindComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDRewindComponent>();
	}
};
static_assert(alignof(UNGDRewindComponent) == 0x000008, "Wrong alignment on UNGDRewindComponent");
static_assert(sizeof(UNGDRewindComponent) == 0x000150, "Wrong size on UNGDRewindComponent");
static_assert(offsetof(UNGDRewindComponent, PhysicsAsset) == 0x0000B0, "Member 'UNGDRewindComponent::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(UNGDRewindComponent, StaticPhysicsAsset) == 0x0000B8, "Member 'UNGDRewindComponent::StaticPhysicsAsset' has a wrong offset!");

// Class UnrealProject.NGDRewindTickComponent
// 0x0008 (0x00B8 - 0x00B0)
class UNGDRewindTickComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDRewindTickComponent">();
	}
	static class UNGDRewindTickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDRewindTickComponent>();
	}
};
static_assert(alignof(UNGDRewindTickComponent) == 0x000008, "Wrong alignment on UNGDRewindTickComponent");
static_assert(sizeof(UNGDRewindTickComponent) == 0x0000B8, "Wrong size on UNGDRewindTickComponent");

// Class UnrealProject.NGDSpringArmComponent
// 0x0050 (0x02D0 - 0x0280)
class UNGDSpringArmComponent final : public USpringArmComponent
{
public:
	struct FSpringArmConfig                       SpringArmConfig;                                   // 0x0280(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDSpringArmComponent">();
	}
	static class UNGDSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDSpringArmComponent>();
	}
};
static_assert(alignof(UNGDSpringArmComponent) == 0x000010, "Wrong alignment on UNGDSpringArmComponent");
static_assert(sizeof(UNGDSpringArmComponent) == 0x0002D0, "Wrong size on UNGDSpringArmComponent");
static_assert(offsetof(UNGDSpringArmComponent, SpringArmConfig) == 0x000280, "Member 'UNGDSpringArmComponent::SpringArmConfig' has a wrong offset!");

// Class UnrealProject.NGDTeamComponent
// 0x0078 (0x0128 - 0x00B0)
class UNGDTeamComponent final : public UActorComponent
{
public:
	TSubclassOf<class ANGDTeamState>              TeamStateClass;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FriendlyFireFactor;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANGDTeamState*>                  TeamStates;                                        // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class AController*, int32>               PlayerTeamMap;                                     // 0x00D0(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFriendlyFireFactor(class AController* Controller, class AController* Instigator);

	int32 GetTeamNumber(const class AController* Player) const;
	bool HasFriendlyFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDTeamComponent">();
	}
	static class UNGDTeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDTeamComponent>();
	}
};
static_assert(alignof(UNGDTeamComponent) == 0x000008, "Wrong alignment on UNGDTeamComponent");
static_assert(sizeof(UNGDTeamComponent) == 0x000128, "Wrong size on UNGDTeamComponent");
static_assert(offsetof(UNGDTeamComponent, TeamStateClass) == 0x0000B0, "Member 'UNGDTeamComponent::TeamStateClass' has a wrong offset!");
static_assert(offsetof(UNGDTeamComponent, FriendlyFireFactor) == 0x0000B8, "Member 'UNGDTeamComponent::FriendlyFireFactor' has a wrong offset!");
static_assert(offsetof(UNGDTeamComponent, TeamStates) == 0x0000C0, "Member 'UNGDTeamComponent::TeamStates' has a wrong offset!");
static_assert(offsetof(UNGDTeamComponent, PlayerTeamMap) == 0x0000D0, "Member 'UNGDTeamComponent::PlayerTeamMap' has a wrong offset!");

// Class UnrealProject.NGDTeamState
// 0x0018 (0x0230 - 0x0218)
class ANGDTeamState final : public AInfo
{
public:
	int32                                         TeamNumber;                                        // 0x0218(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AController*>                    TeamMembers;                                       // 0x0220(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetSize() const;
	int32 GetTeamNumber() const;
	bool HasMember(const class AController* Member) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDTeamState">();
	}
	static class ANGDTeamState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDTeamState>();
	}
};
static_assert(alignof(ANGDTeamState) == 0x000008, "Wrong alignment on ANGDTeamState");
static_assert(sizeof(ANGDTeamState) == 0x000230, "Wrong size on ANGDTeamState");
static_assert(offsetof(ANGDTeamState, TeamNumber) == 0x000218, "Member 'ANGDTeamState::TeamNumber' has a wrong offset!");
static_assert(offsetof(ANGDTeamState, TeamMembers) == 0x000220, "Member 'ANGDTeamState::TeamMembers' has a wrong offset!");

// Class UnrealProject.NGDVehicle
// 0x0110 (0x0388 - 0x0278)
class ANGDVehicle final : public APawn
{
public:
	int32                                         MaxPassangers;                                     // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bControlledByDriver;                               // 0x027C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDisableCollisionOnBoard;                    // 0x027D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEnableCollisionOnUnBoard;                   // 0x027E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27F[0x1];                                      // 0x027F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        BoardSound;                                        // 0x0288(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNGDSoundConfig                        UnBoardSound;                                      // 0x02E0(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class ANGDCharacter*>             PassengersMap;                                     // 0x0338(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void ServerRequestDriverUnBoardContract();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDVehicle">();
	}
	static class ANGDVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANGDVehicle>();
	}
};
static_assert(alignof(ANGDVehicle) == 0x000008, "Wrong alignment on ANGDVehicle");
static_assert(sizeof(ANGDVehicle) == 0x000388, "Wrong size on ANGDVehicle");
static_assert(offsetof(ANGDVehicle, MaxPassangers) == 0x000278, "Member 'ANGDVehicle::MaxPassangers' has a wrong offset!");
static_assert(offsetof(ANGDVehicle, bControlledByDriver) == 0x00027C, "Member 'ANGDVehicle::bControlledByDriver' has a wrong offset!");
static_assert(offsetof(ANGDVehicle, bShouldDisableCollisionOnBoard) == 0x00027D, "Member 'ANGDVehicle::bShouldDisableCollisionOnBoard' has a wrong offset!");
static_assert(offsetof(ANGDVehicle, bShouldEnableCollisionOnUnBoard) == 0x00027E, "Member 'ANGDVehicle::bShouldEnableCollisionOnUnBoard' has a wrong offset!");
static_assert(offsetof(ANGDVehicle, Mesh) == 0x000280, "Member 'ANGDVehicle::Mesh' has a wrong offset!");
static_assert(offsetof(ANGDVehicle, BoardSound) == 0x000288, "Member 'ANGDVehicle::BoardSound' has a wrong offset!");
static_assert(offsetof(ANGDVehicle, UnBoardSound) == 0x0002E0, "Member 'ANGDVehicle::UnBoardSound' has a wrong offset!");
static_assert(offsetof(ANGDVehicle, PassengersMap) == 0x000338, "Member 'ANGDVehicle::PassengersMap' has a wrong offset!");

// Class UnrealProject.NGDVehicleInterface
// 0x0000 (0x0000 - 0x0000)
class INGDVehicleInterface final
{
public:
	class ANGDCharacter* GetDriver() const;
	class UNGDVehicleComponent* GetVehicleComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDVehicleInterface">();
	}
	static class INGDVehicleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INGDVehicleInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INGDVehicleInterface) == 0x000001, "Wrong alignment on INGDVehicleInterface");
static_assert(sizeof(INGDVehicleInterface) == 0x000001, "Wrong size on INGDVehicleInterface");

// Class UnrealProject.NGDWeaponEventManagerComponent
// 0x0040 (0x00F0 - 0x00B0)
class UNGDWeaponEventManagerComponent final : public UActorComponent
{
public:
	TArray<struct FRemoteFireEvent>               FireEvents;                                        // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FRemoteDesyncFireEvent>         DesyncFireEvents;                                  // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FRemoteHitEvent>                HitEvents;                                         // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FRemoteReloadEvent>             ReloadEvents;                                      // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void ClientPushDesyncFireEvent(const struct FRemoteDesyncFireEvent& InDesyncFireEvent);
	void ClientPushFireEvent(const struct FRemoteFireEvent& InFireEvent);
	void ClientPushHitEvent(const struct FRemoteHitEvent& InHitEvent);
	void ClientPushReloadEvent(const struct FRemoteReloadEvent& InReloadEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDWeaponEventManagerComponent">();
	}
	static class UNGDWeaponEventManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDWeaponEventManagerComponent>();
	}
};
static_assert(alignof(UNGDWeaponEventManagerComponent) == 0x000008, "Wrong alignment on UNGDWeaponEventManagerComponent");
static_assert(sizeof(UNGDWeaponEventManagerComponent) == 0x0000F0, "Wrong size on UNGDWeaponEventManagerComponent");
static_assert(offsetof(UNGDWeaponEventManagerComponent, FireEvents) == 0x0000B0, "Member 'UNGDWeaponEventManagerComponent::FireEvents' has a wrong offset!");
static_assert(offsetof(UNGDWeaponEventManagerComponent, DesyncFireEvents) == 0x0000C0, "Member 'UNGDWeaponEventManagerComponent::DesyncFireEvents' has a wrong offset!");
static_assert(offsetof(UNGDWeaponEventManagerComponent, HitEvents) == 0x0000D0, "Member 'UNGDWeaponEventManagerComponent::HitEvents' has a wrong offset!");
static_assert(offsetof(UNGDWeaponEventManagerComponent, ReloadEvents) == 0x0000E0, "Member 'UNGDWeaponEventManagerComponent::ReloadEvents' has a wrong offset!");

// Class UnrealProject.NGDWheeledMovementComponent
// 0x0138 (0x0540 - 0x0408)
class UNGDWheeledMovementComponent final : public UWheeledVehicleMovementComponent4W
{
public:
	bool                                          bShouldDrawDebugs;                                 // 0x0408(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldPrintDebugs;                                // 0x0409(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40A[0x2];                                      // 0x040A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PositionDeltaThresholdSquare;                      // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationDeltaThreshold;                            // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondsToRecordMoves;                              // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondsToRestoreAuthorityAfterCollision;           // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondsToDisableFullyLocalPhysics;                 // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondsToBlendInAfterFullyLocalPhysics;            // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x10C];                                    // 0x0424(0x010C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasClientMovementAuthority;                       // 0x0530(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasServerAuthorityForCollisions;                  // 0x0531(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAfterCollisionSwitchToFullyLocalPhysics;          // 0x0532(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_533[0xD];                                      // 0x0533(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerForceClientCorrection(const struct FVehicleSample& InClientCorrection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGDWheeledMovementComponent">();
	}
	static class UNGDWheeledMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGDWheeledMovementComponent>();
	}
};
static_assert(alignof(UNGDWheeledMovementComponent) == 0x000008, "Wrong alignment on UNGDWheeledMovementComponent");
static_assert(sizeof(UNGDWheeledMovementComponent) == 0x000540, "Wrong size on UNGDWheeledMovementComponent");
static_assert(offsetof(UNGDWheeledMovementComponent, bShouldDrawDebugs) == 0x000408, "Member 'UNGDWheeledMovementComponent::bShouldDrawDebugs' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, bShouldPrintDebugs) == 0x000409, "Member 'UNGDWheeledMovementComponent::bShouldPrintDebugs' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, PositionDeltaThresholdSquare) == 0x00040C, "Member 'UNGDWheeledMovementComponent::PositionDeltaThresholdSquare' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, RotationDeltaThreshold) == 0x000410, "Member 'UNGDWheeledMovementComponent::RotationDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, SecondsToRecordMoves) == 0x000414, "Member 'UNGDWheeledMovementComponent::SecondsToRecordMoves' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, SecondsToRestoreAuthorityAfterCollision) == 0x000418, "Member 'UNGDWheeledMovementComponent::SecondsToRestoreAuthorityAfterCollision' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, SecondsToDisableFullyLocalPhysics) == 0x00041C, "Member 'UNGDWheeledMovementComponent::SecondsToDisableFullyLocalPhysics' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, SecondsToBlendInAfterFullyLocalPhysics) == 0x000420, "Member 'UNGDWheeledMovementComponent::SecondsToBlendInAfterFullyLocalPhysics' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, bHasClientMovementAuthority) == 0x000530, "Member 'UNGDWheeledMovementComponent::bHasClientMovementAuthority' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, bHasServerAuthorityForCollisions) == 0x000531, "Member 'UNGDWheeledMovementComponent::bHasServerAuthorityForCollisions' has a wrong offset!");
static_assert(offsetof(UNGDWheeledMovementComponent, bAfterCollisionSwitchToFullyLocalPhysics) == 0x000532, "Member 'UNGDWheeledMovementComponent::bAfterCollisionSwitchToFullyLocalPhysics' has a wrong offset!");

// Class UnrealProject.PrePhysicsComponent
// 0x0000 (0x00B0 - 0x00B0)
class UPrePhysicsComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrePhysicsComponent">();
	}
	static class UPrePhysicsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrePhysicsComponent>();
	}
};
static_assert(alignof(UPrePhysicsComponent) == 0x000008, "Wrong alignment on UPrePhysicsComponent");
static_assert(sizeof(UPrePhysicsComponent) == 0x0000B0, "Wrong size on UPrePhysicsComponent");

// Class UnrealProject.PushbackFirearmFeelComponent
// 0x00C0 (0x01F8 - 0x0138)
class UPushbackFirearmFeelComponent final : public UBaseFirearmFeelComponent
{
public:
	struct FScalableVectorCurve                   TranslationCurve;                                  // 0x0138(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableVectorCurve                   RotationCurve;                                     // 0x0158(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         LocationAmount;                                    // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationScalar;                                    // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PushbackDuration;                                  // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAnimationRemainder;                            // 0x0184(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseADSValues;                                     // 0x0185(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_186[0x2];                                      // 0x0186(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableVectorCurve                   ADSTranslationCurve;                               // 0x0188(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableVectorCurve                   ADSRotationCurve;                                  // 0x01A8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         ADSLocationAmount;                                 // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ADSRotationScalar;                                 // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ADSPushbackDuration;                               // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0x24];                                     // 0x01D4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushbackFirearmFeelComponent">();
	}
	static class UPushbackFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPushbackFirearmFeelComponent>();
	}
};
static_assert(alignof(UPushbackFirearmFeelComponent) == 0x000008, "Wrong alignment on UPushbackFirearmFeelComponent");
static_assert(sizeof(UPushbackFirearmFeelComponent) == 0x0001F8, "Wrong size on UPushbackFirearmFeelComponent");
static_assert(offsetof(UPushbackFirearmFeelComponent, TranslationCurve) == 0x000138, "Member 'UPushbackFirearmFeelComponent::TranslationCurve' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, RotationCurve) == 0x000158, "Member 'UPushbackFirearmFeelComponent::RotationCurve' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, LocationAmount) == 0x000178, "Member 'UPushbackFirearmFeelComponent::LocationAmount' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, RotationScalar) == 0x00017C, "Member 'UPushbackFirearmFeelComponent::RotationScalar' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, PushbackDuration) == 0x000180, "Member 'UPushbackFirearmFeelComponent::PushbackDuration' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, bUseAnimationRemainder) == 0x000184, "Member 'UPushbackFirearmFeelComponent::bUseAnimationRemainder' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, bUseADSValues) == 0x000185, "Member 'UPushbackFirearmFeelComponent::bUseADSValues' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, ADSTranslationCurve) == 0x000188, "Member 'UPushbackFirearmFeelComponent::ADSTranslationCurve' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, ADSRotationCurve) == 0x0001A8, "Member 'UPushbackFirearmFeelComponent::ADSRotationCurve' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, ADSLocationAmount) == 0x0001C8, "Member 'UPushbackFirearmFeelComponent::ADSLocationAmount' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, ADSRotationScalar) == 0x0001CC, "Member 'UPushbackFirearmFeelComponent::ADSRotationScalar' has a wrong offset!");
static_assert(offsetof(UPushbackFirearmFeelComponent, ADSPushbackDuration) == 0x0001D0, "Member 'UPushbackFirearmFeelComponent::ADSPushbackDuration' has a wrong offset!");

// Class UnrealProject.RecoilFirearmFeelComponent
// 0x0040 (0x01A8 - 0x0168)
class URecoilFirearmFeelComponent final : public UGainCurveFirearmFeelComponent
{
public:
	struct FScalableCurve                         FixedTendencyCurve;                                // 0x0168(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableCurve                         RandomTendencyCurve;                               // 0x0180(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0xC];                                      // 0x019C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecoilFirearmFeelComponent">();
	}
	static class URecoilFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecoilFirearmFeelComponent>();
	}
};
static_assert(alignof(URecoilFirearmFeelComponent) == 0x000008, "Wrong alignment on URecoilFirearmFeelComponent");
static_assert(sizeof(URecoilFirearmFeelComponent) == 0x0001A8, "Wrong size on URecoilFirearmFeelComponent");
static_assert(offsetof(URecoilFirearmFeelComponent, FixedTendencyCurve) == 0x000168, "Member 'URecoilFirearmFeelComponent::FixedTendencyCurve' has a wrong offset!");
static_assert(offsetof(URecoilFirearmFeelComponent, RandomTendencyCurve) == 0x000180, "Member 'URecoilFirearmFeelComponent::RandomTendencyCurve' has a wrong offset!");
static_assert(offsetof(URecoilFirearmFeelComponent, Speed) == 0x000198, "Member 'URecoilFirearmFeelComponent::Speed' has a wrong offset!");

// Class UnrealProject.ShotgunShell
// 0x0010 (0x0378 - 0x0368)
class AShotgunShell final : public ABaseProjectile
{
public:
	int32                                         PelletsAmount;                                     // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelletRadius;                                      // 0x036C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShotgunShell">();
	}
	static class AShotgunShell* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShotgunShell>();
	}
};
static_assert(alignof(AShotgunShell) == 0x000008, "Wrong alignment on AShotgunShell");
static_assert(sizeof(AShotgunShell) == 0x000378, "Wrong size on AShotgunShell");
static_assert(offsetof(AShotgunShell, PelletsAmount) == 0x000368, "Member 'AShotgunShell::PelletsAmount' has a wrong offset!");
static_assert(offsetof(AShotgunShell, PelletRadius) == 0x00036C, "Member 'AShotgunShell::PelletRadius' has a wrong offset!");

// Class UnrealProject.SoundNodeVehicleEngine
// 0x0020 (0x0060 - 0x0040)
class USoundNodeVehicleEngine final : public USoundNode
{
public:
	TArray<struct FVehicleEngineDatum>            EngineSamples;                                     // 0x0040(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x4];                                       // 0x0050(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentRPM;                                        // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeVehicleEngine">();
	}
	static class USoundNodeVehicleEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeVehicleEngine>();
	}
};
static_assert(alignof(USoundNodeVehicleEngine) == 0x000008, "Wrong alignment on USoundNodeVehicleEngine");
static_assert(sizeof(USoundNodeVehicleEngine) == 0x000060, "Wrong size on USoundNodeVehicleEngine");
static_assert(offsetof(USoundNodeVehicleEngine, EngineSamples) == 0x000040, "Member 'USoundNodeVehicleEngine::EngineSamples' has a wrong offset!");
static_assert(offsetof(USoundNodeVehicleEngine, CurrentRPM) == 0x000054, "Member 'USoundNodeVehicleEngine::CurrentRPM' has a wrong offset!");

// Class UnrealProject.SpreadFirearmFeelComponent
// 0x0018 (0x0180 - 0x0168)
class USpreadFirearmFeelComponent final : public UGainCurveFirearmFeelComponent
{
public:
	float                                         SpreadToControllerFactor;                          // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurrentSpreadMagnitude() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpreadFirearmFeelComponent">();
	}
	static class USpreadFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpreadFirearmFeelComponent>();
	}
};
static_assert(alignof(USpreadFirearmFeelComponent) == 0x000008, "Wrong alignment on USpreadFirearmFeelComponent");
static_assert(sizeof(USpreadFirearmFeelComponent) == 0x000180, "Wrong size on USpreadFirearmFeelComponent");
static_assert(offsetof(USpreadFirearmFeelComponent, SpreadToControllerFactor) == 0x000168, "Member 'USpreadFirearmFeelComponent::SpreadToControllerFactor' has a wrong offset!");
static_assert(offsetof(USpreadFirearmFeelComponent, Speed) == 0x00016C, "Member 'USpreadFirearmFeelComponent::Speed' has a wrong offset!");

// Class UnrealProject.StopAimingAction
// 0x0020 (0x0080 - 0x0060)
class UStopAimingAction final : public UAction
{
public:
	class UPlayTestComponent*                     PlayTestComp;                                      // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTargetLocation;                                 // 0x0068(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AimTargetActor;                                    // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EventUpdate(float Delta);
	void Initialize_Implementation(const struct FActionParams& ActionParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StopAimingAction">();
	}
	static class UStopAimingAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStopAimingAction>();
	}
};
static_assert(alignof(UStopAimingAction) == 0x000008, "Wrong alignment on UStopAimingAction");
static_assert(sizeof(UStopAimingAction) == 0x000080, "Wrong size on UStopAimingAction");
static_assert(offsetof(UStopAimingAction, PlayTestComp) == 0x000060, "Member 'UStopAimingAction::PlayTestComp' has a wrong offset!");
static_assert(offsetof(UStopAimingAction, AimTargetLocation) == 0x000068, "Member 'UStopAimingAction::AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UStopAimingAction, AimTargetActor) == 0x000078, "Member 'UStopAimingAction::AimTargetActor' has a wrong offset!");

// Class UnrealProject.SwayFirearmFeelComponent
// 0x0000 (0x0138 - 0x0138)
class USwayFirearmFeelComponent final : public UBaseFirearmFeelComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwayFirearmFeelComponent">();
	}
	static class USwayFirearmFeelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwayFirearmFeelComponent>();
	}
};
static_assert(alignof(USwayFirearmFeelComponent) == 0x000008, "Wrong alignment on USwayFirearmFeelComponent");
static_assert(sizeof(USwayFirearmFeelComponent) == 0x000138, "Wrong size on USwayFirearmFeelComponent");

// Class UnrealProject.Throwable
// 0x0080 (0x05E0 - 0x0560)
class AThrowable final : public AWeapon
{
public:
	TSubclassOf<class AThrowableProjectile>       ProjectileClass;                                   // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchRotation;                                    // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHoldTimerBeforeReleasing;                       // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             ProjectilePathTraceChannel;                        // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowCooldown;                                     // 0x0578(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLeverReleased;                                  // 0x0580(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLaunched;                                       // 0x0581(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_582[0x2];                                      // 0x0582(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FirePosition;                                      // 0x0584(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FireDirection;                                     // 0x0590(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                Velocity;                                          // 0x059C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETimerMode                                    TimerMode;                                         // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A9[0x7];                                      // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AThrowableProjectile*                   ProjectileSpawned;                                 // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayForLaunchAnimation;                           // 0x05B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAnimFinish;                                       // 0x05C0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNGDLineRendererComponent*              LineRendererComponent;                             // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAiming;                                         // 0x05D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectileLaunchSpeed;                             // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearLineRendererComponent();
	void OnAnimationFinish();
	void Reset();
	void ResetThrowCooldown();
	void Server_OnFinishAnimation();
	void Server_RPCCancelShooting();
	void Server_RPCReleaseLever();
	void SetAnimState(bool bNewAnimState);
	void SetIsAiming(bool bAiming);
	void SetLaunchState(bool bNewLaunchState);
	void SetLeverState(bool bNewLeverState);

	bool CanFireNextGrenade() const;
	const struct FRotator GetFireDirection() const;
	const struct FVector GetFirePosition() const;
	const struct FVector GetLaunchVelocity() const;
	bool IsAiming() const;
	bool IsLaunched() const;
	bool IsLeverReleased() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Throwable">();
	}
	static class AThrowable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrowable>();
	}
};
static_assert(alignof(AThrowable) == 0x000010, "Wrong alignment on AThrowable");
static_assert(sizeof(AThrowable) == 0x0005E0, "Wrong size on AThrowable");
static_assert(offsetof(AThrowable, ProjectileClass) == 0x000560, "Member 'AThrowable::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AThrowable, LaunchRotation) == 0x000568, "Member 'AThrowable::LaunchRotation' has a wrong offset!");
static_assert(offsetof(AThrowable, MaxHoldTimerBeforeReleasing) == 0x00056C, "Member 'AThrowable::MaxHoldTimerBeforeReleasing' has a wrong offset!");
static_assert(offsetof(AThrowable, ProjectilePathTraceChannel) == 0x000570, "Member 'AThrowable::ProjectilePathTraceChannel' has a wrong offset!");
static_assert(offsetof(AThrowable, ThrowCooldown) == 0x000578, "Member 'AThrowable::ThrowCooldown' has a wrong offset!");
static_assert(offsetof(AThrowable, bIsLeverReleased) == 0x000580, "Member 'AThrowable::bIsLeverReleased' has a wrong offset!");
static_assert(offsetof(AThrowable, bIsLaunched) == 0x000581, "Member 'AThrowable::bIsLaunched' has a wrong offset!");
static_assert(offsetof(AThrowable, FirePosition) == 0x000584, "Member 'AThrowable::FirePosition' has a wrong offset!");
static_assert(offsetof(AThrowable, FireDirection) == 0x000590, "Member 'AThrowable::FireDirection' has a wrong offset!");
static_assert(offsetof(AThrowable, Velocity) == 0x00059C, "Member 'AThrowable::Velocity' has a wrong offset!");
static_assert(offsetof(AThrowable, TimerMode) == 0x0005A8, "Member 'AThrowable::TimerMode' has a wrong offset!");
static_assert(offsetof(AThrowable, ProjectileSpawned) == 0x0005B0, "Member 'AThrowable::ProjectileSpawned' has a wrong offset!");
static_assert(offsetof(AThrowable, DelayForLaunchAnimation) == 0x0005B8, "Member 'AThrowable::DelayForLaunchAnimation' has a wrong offset!");
static_assert(offsetof(AThrowable, bAnimFinish) == 0x0005C0, "Member 'AThrowable::bAnimFinish' has a wrong offset!");
static_assert(offsetof(AThrowable, LineRendererComponent) == 0x0005C8, "Member 'AThrowable::LineRendererComponent' has a wrong offset!");
static_assert(offsetof(AThrowable, bIsAiming) == 0x0005D0, "Member 'AThrowable::bIsAiming' has a wrong offset!");
static_assert(offsetof(AThrowable, ProjectileLaunchSpeed) == 0x0005D4, "Member 'AThrowable::ProjectileLaunchSpeed' has a wrong offset!");

// Class UnrealProject.VehicleDustType
// 0x0040 (0x0070 - 0x0030)
class UVehicleDustType final : public UDataAsset
{
public:
	class UParticleSystem*                        AsphaltFX;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DirtFX;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        WaterFX;                                           // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GrassFX;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GravelFX;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AsphaltMinSpeed;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirtMinSpeed;                                      // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterMinSpeed;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrassMinSpeed;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravelMinSpeed;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleDustType">();
	}
	static class UVehicleDustType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleDustType>();
	}
};
static_assert(alignof(UVehicleDustType) == 0x000008, "Wrong alignment on UVehicleDustType");
static_assert(sizeof(UVehicleDustType) == 0x000070, "Wrong size on UVehicleDustType");
static_assert(offsetof(UVehicleDustType, AsphaltFX) == 0x000030, "Member 'UVehicleDustType::AsphaltFX' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, DirtFX) == 0x000038, "Member 'UVehicleDustType::DirtFX' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, WaterFX) == 0x000040, "Member 'UVehicleDustType::WaterFX' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, GrassFX) == 0x000048, "Member 'UVehicleDustType::GrassFX' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, GravelFX) == 0x000050, "Member 'UVehicleDustType::GravelFX' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, AsphaltMinSpeed) == 0x000058, "Member 'UVehicleDustType::AsphaltMinSpeed' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, DirtMinSpeed) == 0x00005C, "Member 'UVehicleDustType::DirtMinSpeed' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, WaterMinSpeed) == 0x000060, "Member 'UVehicleDustType::WaterMinSpeed' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, GrassMinSpeed) == 0x000064, "Member 'UVehicleDustType::GrassMinSpeed' has a wrong offset!");
static_assert(offsetof(UVehicleDustType, GravelMinSpeed) == 0x000068, "Member 'UVehicleDustType::GravelMinSpeed' has a wrong offset!");

}

